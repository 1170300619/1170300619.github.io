<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="热爱技术，笔耕不辍">
<meta property="og:type" content="website">
<meta property="og:title" content="漱石斋笔谈">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="漱石斋笔谈">
<meta property="og:description" content="热爱技术，笔耕不辍">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="gaotf">
<meta property="article:tag" content="PostgreSQL">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>漱石斋笔谈</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">漱石斋笔谈</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">gaotf 的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gaotf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">gaotf</p>
  <div class="site-description" itemprop="description">热爱技术，笔耕不辍</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/1170300619" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1170300619" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3469205806@qq.com" title="E-Mail → 3469205806@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/%E6%9C%AD%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/%E6%9C%AD%E8%AE%B0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-17 09:51:28" itemprop="dateModified" datetime="2021-05-17T09:51:28+08:00">2021-05-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h2 id="title-札记date-2019-11-05-21-57-53tags"><a href="#title-札记date-2019-11-05-21-57-53tags" class="headerlink" title="title: 札记date: 2019-11-05 21:57:53tags:"></a>title: 札记<br>date: 2019-11-05 21:57:53<br>tags:</h2><p>状态不佳，似乎又回到了失语症的状态，和现实有些不交融，有时候能明显的感觉自己在故意的压抑情绪。</p>
<p>最近在看村上的《1Q84》，自己像极了里面的深绘里，经历了一些事情以后丧失了说话的能力，只能向外界以短暂而无意义的华语表达自己的困境</p>
<p>这种状态我心知肚明是怎样逐渐发生的，又是逐渐加重的，但是暂时并没有自愈的能力，只能无助的看着这一层迷雾逐渐笼罩自身</p>
<p>也许下了雪就会好一点吧，能找回片刻的宁静</p>
<p>“青豆用手捂住下半边脸，继续凝望着那两只月亮，确实，有什么事情正在发生。她想。心脏的跳动加速。不是世界出了毛病，就是我自己出了毛病。是瓶子有问题呢，还是盖子又问题？”</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%94%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%94%E6%9C%9F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-06-24 14:41:39" itemprop="dateModified" datetime="2019-06-24T14:41:39+08:00">2019-06-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h2 id="软件构造知识点总结第五期"><a href="#软件构造知识点总结第五期" class="headerlink" title="软件构造知识点总结第五期"></a>软件构造知识点总结第五期</h2><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><hr>
<h2 id="第一节-软件构造性能的度量原理"><a href="#第一节-软件构造性能的度量原理" class="headerlink" title="第一节 软件构造性能的度量原理"></a>第一节 软件构造性能的度量原理</h2><h3 id="性能度量指标"><a href="#性能度量指标" class="headerlink" title="性能度量指标"></a><em>性能度量指标</em></h3><ul>
<li>时间性能<ul>
<li>每条指令、每个控制 结构、整个程序的执行时间</li>
<li>不同语句或控制结构执行时间的分布情况</li>
<li>时间瓶颈在哪里</li>
</ul>
</li>
<li>空间性能<ul>
<li>每个变量、每个复杂结构、整个程序的内存消耗</li>
<li>不同变量&#x2F;数据结构的相对消耗</li>
<li>空间瓶颈在哪里</li>
<li>随时间的变化情况</li>
</ul>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><em>内存管理</em></h3><p><strong>对象管理模型</strong></p>
<ul>
<li><p>三者的差异在于：如何与何时在程序对象与内存对象之间建立联系</p>
</li>
<li><p>静态</p>
<ul>
<li><strong>定义</strong>：静态内存是指在程序开始运行时由编译器分配的内存，它的分配是在程序开始编译时完成的，不占用CPU资源。</li>
<li>程序中的各种变量，在编译时系统已经为其分配了所需的内存空间，当该变量在作用域内使用完毕时，系统会自动释放所占用的内存空间；</li>
<li>不支持递归，不支持动态创建可变长的复杂数据类型；</li>
<li>在程序执行期内实体至多关联一个运行时对象</li>
<li>eg: 基本类型，数组</li>
</ul>
</li>
<li><p>动态-基于栈</p>
<ul>
<li>栈定义：方法调用和局部变量的存储位置，保存基本类型<ul>
<li>如果一个方法被调用，它的栈帧被放到调用栈的顶部</li>
<li>栈帧保存方法的状态，包括执行哪行代码以及所有局部变量的值</li>
<li>栈顶始终是当前运行方法</li>
</ul>
</li>
<li>一个实体可以在运行时连续地连接到多个对象，并且运行时机制以堆栈中的<strong>后进先出</strong>顺序分配和释放这些对象</li>
<li>栈无法支持复杂数据结构</li>
</ul>
</li>
<li><p>动态-基于堆</p>
<ul>
<li><strong>堆定义</strong>：在一块内存里分为多个小块，每块包含 一个对象，或者未被占用</li>
<li>自由模式的内存管理，动态分配，可管理复杂的动态数据结构</li>
<li>代码中的一个变量可以在不同时间被关联到不同的内存对象上，无法在编译阶段确定。内存对象也可以进一步指向其他对象</li>
</ul>
</li>
</ul>
<h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a><em>Java垃圾回收机制</em></h3><p><strong>内存回收的三种方式</strong></p>
<p>​    ①静态模式下的内存回收：在静态内存分配模式下，无需进行内存回收：所有都是已确定的。</p>
<p>​    ②在栈模式下的内存回收：按block（某个方法）整体进行</p>
<p>​    ③在堆模式下的内存回收：在heap上进行内存空间回收，最复杂——无法提前预知某个object是否已经变得无用。</p>
<p> <strong>动态垃圾回收相关概念</strong></p>
<ul>
<li>GC（Garbage Collection）：识别垃圾并释放其占用的内存<ul>
<li>垃圾回收器根据对象的“活性”(从root的可达性)来决定是否回收该对象的内存，”死“的对象是需要回收的垃圾</li>
</ul>
</li>
<li>Root<ul>
<li>根集合由root对象和局部对象构成</li>
<li>root对象：<code>Class</code>（不能被回收）、<code>Thread</code>、Java方法&#x2F;接口的本地变量或参数、全局接口引用等</li>
</ul>
</li>
<li>可达&#x2F;不可达对象（Reachable&#x2F;Unreachable）：free模式<ul>
<li>从根可以直接或间接到达的对象为可达的，否则为不可达的</li>
<li>从根开始，不断将指向的对象加入活动集，剩下的是垃圾</li>
</ul>
</li>
<li>活动&#x2F;死亡对象（Live&#x2F;dead）：<ul>
<li>在stack和free的结合模式下，对象的引用被视为有向图，可以从根访问的对象为活动对象，否则为死亡对象。</li>
</ul>
</li>
</ul>
<p><strong>GC的四种算法</strong></p>
<ul>
<li><p>引用计数</p>
<ul>
<li><strong>基本思想</strong>：为每个object存储一个计数RC，当有其他 reference指向它时，RC++；当其他reference与其断开时，RC–；如 果RC&#x3D;&#x3D;0，则回收它。</li>
<li><strong>优点</strong>：简单、计算代价分散，“幽灵时间”短 为0</li>
<li><strong>缺点</strong>：不全面（容易漏掉循环引用的对象）、并发支 持较弱、占用额外内存空间、等</li>
</ul>
</li>
<li><p>Mark-Sweep（标记-清除）算法</p>
<ul>
<li><strong>基本思想</strong>：为每个object设定状态位(live&#x2F;dead)并记录，即mark阶段；将标记为dead的对象进行清理，即sweep可阶段。</li>
<li><strong>优点：</strong>可以处理循环调用，指针操作无开销，对象不变</li>
<li><strong>缺点</strong>：复杂度为O(heap),高　堆的占用比高时影响性能，容易造成碎片，需要找到root</li>
</ul>
</li>
<li><p>Copying（复制）算法</p>
<ul>
<li><strong>基本思想</strong>：为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。</li>
<li><strong>优势</strong>：运行高效、不易产生内存碎片</li>
<li><strong>缺点</strong>：复制花费大量的时间，牺牲内存空间</li>
</ul>
</li>
<li><p>Mark-Compact（标记-整理）算法</p>
<ul>
<li>基本思想：为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</li>
</ul>
</li>
</ul>
<h3 id="JVM中的GC"><a href="#JVM中的GC" class="headerlink" title="JVM中的GC"></a><em>JVM中的GC</em></h3><p>Java GC将堆分为不同的区域，各区域采用不同的GC策略，以提高GC的效率</p>
<ul>
<li><p>Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。</p>
</li>
<li><p>对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）</p>
</li>
<li><p>年轻代：</p>
<ul>
<li>对象被创建时，内存的分配首先发生在年轻代（大对象可以直接 被创建在年老代）</li>
<li>大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消 亡的）</li>
<li>为减少GC代价，<strong>使用copying算法</strong></li>
<li>具体过程<ol>
<li>绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</li>
<li>当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；</li>
<li>此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；</li>
<li>当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）。</li>
<li>当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</li>
</ol>
</li>
</ul>
</li>
<li><p>年老代：</p>
<ul>
<li>对象如果在年轻代存活了足够长的时间而没有被清理掉，则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。</li>
<li>使用Mark-Sweep或Mark-Compact算法；</li>
<li>Minor GC和full GC独立进行，减小代价；</li>
<li>当perm generation满了之后，无法存储更多的元数据，也启动full GC。</li>
</ul>
</li>
</ul>
<h3 id="GVM-GC性能调优"><a href="#GVM-GC性能调优" class="headerlink" title="GVM GC性能调优"></a><em>GVM GC性能调优</em></h3><ul>
<li>尽可能减少GC时间，一般不超过程序执行时间的5%</li>
<li>一旦初始分配给程序的内存满了，就抛出内存溢出异常，</li>
<li>在启动程序时，可为其配置内存分配的具体大小</li>
<li>堆的大小决定着VM将会以何种频度进行GC、每次GC的时间多长。<ul>
<li>这两个指标具体取值多少为“优”，需要针对特定应用进行分析。</li>
<li>较大的heap会导致较少发生GC，但每次GC时间很长</li>
<li>如果根据程序需要来设置heap大小，则需要频繁GC，但每次GC的时间较短</li>
</ul>
</li>
<li>设定堆的大小的具体方法</li>
</ul>
<pre><code>-   `Xmx/-Xms`：指定年轻代和老年代空间的初始值和最大值；`Xms`小于`Xmx`时，年轻代和老年代所消耗的空间量可以根据应用程序的需求增长或收缩；Java堆的增长不会比`Xms`大，也不会比`Xmx`小
-   `XX: NewSize=&lt;n&gt;[g|m|k]`：年轻代空间的初始和最小尺寸，`&lt;n&gt;`是大小，`[g | m | k]`指示大小是否应解释为千兆字节，兆字节或千字节
-   `XX: MaxNewSize=&lt;n&gt;[g|m|k]`：年轻代空间的最大值
-   `Xmn&lt;n&gt;[g|m|k]`：将年轻代的初始值、最小值、最大值设为同一值
</code></pre>
<ul>
<li><p>GC模式选择</p>
<ul>
<li>增长或收缩年轻代或老年代的空间时需要Full GC</li>
<li>Full GC可能会降低吞吐量并导致超出期望的延迟</li>
<li>串行收集器（-XX:+UseSerialGC）：使用单个线程执行所有垃圾收集工作</li>
<li>并行收集器（-XX:+UseParallelGC）：并行执行Minor GC，显著减少垃圾收集开销</li>
<li>并发低暂停收集器（-XX:+UseConcMarkSweepGC）：收集持久代，与执行应用程序同时执行大部分收集，在收集期间会暂停一小段时间</li>
<li>增量低暂停收集器（-XX:+UseTrainGC）：收集每个Minor的部分老年代，并尽量减少Major的大停顿</li>
<li>-verbose:gc：打印GC信息</li>
</ul>
</li>
<li><p>堆设置<br>-Xms：初始堆大小<br>-Xmx：最大堆大小<br>-XX:NewSize&#x3D;n：设置年轻代大小<br>-XX:NewRatio&#x3D;n：设置年轻代和年老代的比值。如：为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4<br>-XX:SurvivorRatio&#x3D;n：年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor&#x3D;3:2，一个Survivor区占整个年轻代的1&#x2F;5<br>-XX:MaxPermSize&#x3D;n：设置持久代大小</p>
</li>
<li><p>收集器设置<br>-XX:+UseSerialGC：设置串行收集器<br>-XX:+UseParallelGC：设置并行收集器<br>-XX:+UseParalledlOldGC：设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC：设置并发收集器</p>
</li>
<li><p>垃圾回收统计信息<br>-XX：+PrintGC<br>-XX：+PrintGCDetails<br>-XX：+PrintGCTimeStamps<br>-Xloggc：filename</p>
</li>
<li><p>并行收集器设置<br>-XX:ParallelGCThreads&#x3D;n：设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis&#x3D;n：设置并行收集最大暂停时间<br>-XX:GCTimeRatio&#x3D;n：设置垃圾回收时间占程序运行时间的百分比。公式为$\frac{1}{1+n}$</p>
</li>
<li><p>并发收集器设置<br>-XX:+CMSIncrementalMode：设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads&#x3D;n：设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
</li>
</ul>
<h2 id="第二节-动态程序分析方法与工具"><a href="#第二节-动态程序分析方法与工具" class="headerlink" title="第二节 动态程序分析方法与工具"></a>第二节 动态程序分析方法与工具</h2><ul>
<li>Jstat：获取JVM的Heap使用和GC的性能统计数据，命令如-gcutil</li>
<li>Jmap：输出内存中的对象分布情况  如：jmap -clstats</li>
<li>Jhat：导出heap dump，浏览&#x2F;查询其中的对象分布情况</li>
<li>jstack：获取Java线程的stack trace 具体用途如下：<ul>
<li>定位线程出现长时间停顿的原因，如多线程间死锁、死循环、请求外部资源 导致的长时间等待等。</li>
<li>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没 有响应的线程到底在后台做什么事情，或者等待什么资源。</li>
</ul>
</li>
<li>Visual VM：提供了一个可视化界面，用于查看Java应用程序在JVM上运行时的详细信息，使用各种技术，包括jvmstat，JMX，Serviceability Agent（SA）和Attach API等</li>
<li>MAT：内存堆导出文件的分析工具，生成饼状图等，能够对问题发生时刻的系统内存状态获取一个整体印象，找到最有可能导致内存泄露的对象，进一步查看其是否有异常行为。</li>
</ul>
<h3 id="Memory-Dump（堆转储文件）"><a href="#Memory-Dump（堆转储文件）" class="headerlink" title="Memory Dump（堆转储文件）"></a><em>Memory Dump（堆转储文件）</em></h3><p>正如Thread Dump文件记录了当时JVM中线程运行的情况一样，Heap Dump记录了JVM中堆内存运行的情况，可使用jmap或JConsole命令生成，jhat分析。</p>
<p><strong>使用 jmap 命令生成</strong></p>
<p><strong>使用JConsole生成</strong></p>
<p><strong>使用jhat分析</strong> </p>
<h3 id="Stack-Trace"><a href="#Stack-Trace" class="headerlink" title="Stack Trace"></a><em>Stack Trace</em></h3><p>　　可使用jstack查看，定位线程出现长时间停顿的原因。</p>
<h2 id="第三节-代码调优的设计模式和I-O"><a href="#第三节-代码调优的设计模式和I-O" class="headerlink" title="第三节 代码调优的设计模式和I&#x2F;O"></a>第三节 代码调优的设计模式和I&#x2F;O</h2><h2 id="代码调优"><a href="#代码调优" class="headerlink" title="代码调优"></a>代码调优</h2><p><strong>代码调优的概念</strong></p>
<ul>
<li>代码调优：代码调优不是为了修复bug，而是对正确的代码进行修改以提高其性能，其常常是小规模的变化<ul>
<li>调优不会减少代码行数</li>
<li>不要猜原因，而应有明确的优化目标</li>
<li>不要边写程序边调优</li>
<li>不是性能优化的第一选择</li>
<li>代码行数与性能之间无必然的联系</li>
<li>代码调优建立在对程序性能的精确度量基础之上（profiling）</li>
<li>当程序做过某些调整之后，要重新profiling并重新了解需要优化的性能瓶颈，微小的变化能导致优化方向大不相同</li>
</ul>
</li>
<li>性能从不是追求的第一目标，正确性比性能更重要</li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1338.html">单例模式</a>（Singleton Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1371.html">享元模式</a>（Flyweight Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1343.html">原型模式</a>（Prototype Pattern）</strong></p>
<p><strong>对象池模式（Object Pool Pattern）</strong></p>
<h3 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I&#x2F;O"></a><em>Java I&#x2F;O</em></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E7%AC%AC%E5%9B%9B%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E7%AC%AC%E5%9B%9B%E6%9C%9F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-06-24 14:29:51" itemprop="dateModified" datetime="2019-06-24T14:29:51+08:00">2019-06-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h2 id="软件构造知识点总结第四期"><a href="#软件构造知识点总结第四期" class="headerlink" title="软件构造知识点总结第四期"></a>软件构造知识点总结第四期</h2><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="第一节-健壮性和正确性的区别"><a href="#第一节-健壮性和正确性的区别" class="headerlink" title="第一节  健壮性和正确性的区别"></a>第一节  健壮性和正确性的区别</h2><h3 id="健壮性-Robustness-和正确性-correctness"><a href="#健壮性-Robustness-和正确性-correctness" class="headerlink" title="健壮性(Robustness)和正确性(correctness)"></a><em>健壮性(Robustness)和正确性(correctness)</em></h3><p><strong>健壮性</strong></p>
<ul>
<li>定义：系统在不 正常输入或不正常外部环境下仍能够表现正常的程度</li>
<li>面向健壮性编程：<ul>
<li>处理未期望的行为和错误终止</li>
<li>即使终止执行，也要准确&#x2F;无歧义的向用户展示全面的错误信息</li>
<li>错误信息有助于进行debug</li>
</ul>
</li>
<li>健壮性原则：<ul>
<li>Paranoia (偏执狂)：总是假定用户恶意、假定自己的代码可能失败</li>
<li>把用户想象成白痴，可能输入任何东西（返回给用户的错误提示信息要详细、准确、无歧义）</li>
<li>对别人宽容点，对自己狠一点（对自己的代码要保守，对用户的行为要开放）</li>
</ul>
</li>
<li>面向健壮性编程的原则：<ul>
<li>封闭实现细节，限定用户的恶意行为</li>
<li>考虑极端情况，没有“不可能”</li>
</ul>
</li>
</ul>
<p><strong>正确性</strong></p>
<ul>
<li>含义：程序按照spec加以执行的能力，是最重要的质量指标。</li>
<li>对比健壮性和正确性：<ul>
<li>正确性：永不给用户错误的结果； 让开发者变得更容易：用户输入错误，直接结束（不满足precondition调用）。</li>
<li>健壮性：尽可能保持软件运行而不是总是退出； 让用户变得更容易：出错也可以容忍，程序内部已有容错机制。</li>
<li>正确性倾向于直接报错(error)，健壮性则倾向于容错(fault-tolerance)；</li>
<li>对外的接口，倾向于健壮性；对内的实现，倾向于正确性。</li>
<li>Reliability（可靠性） &#x3D; Robustness + correctness</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Problem</th>
<th align="center">健壮性</th>
<th align="center">正确性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">浏览器发出包含空格的URL</td>
<td align="center">剥离空白，正常处理请求。</td>
<td align="center">将HTTP 400错误请求错误状态返回给客户端。</td>
</tr>
<tr>
<td align="center">视频文件有坏帧</td>
<td align="center">跳过腐败区域到下一个可播放部分。</td>
<td align="center">停止播放，引发“损坏的视频文件”错误</td>
</tr>
<tr>
<td align="center">配置文件使用了非法字符</td>
<td align="center">在内部识别最常见的评论前缀，忽略它们。</td>
<td align="center">终止启动时出现“配置错误”错误</td>
</tr>
<tr>
<td align="center">奇怪格式的日期输入</td>
<td align="center">尝试针对多种不同的日期格式解析字符串。将正确的格式呈现给用户。</td>
<td align="center">日期错误无效</td>
</tr>
</tbody></table>
<h3 id="如何测量健壮性和正确性"><a href="#如何测量健壮性和正确性" class="headerlink" title="如何测量健壮性和正确性"></a><em>如何测量健壮性和正确性</em></h3><ul>
<li>外部观察角度：<ul>
<li>Mean time between failures (MTBF，平均失效间隔时间)：描述了可修复系统的两次故障之间的预期时间，而平均故障时间（MTTF）表示不可修复系统的预期故障时间。</li>
</ul>
</li>
<li>内部观察角度：<ul>
<li>残余缺陷率：每千行代码中遗留的bug的数量</li>
</ul>
</li>
</ul>
<h2 id="第二节-错误与异常处理"><a href="#第二节-错误与异常处理" class="headerlink" title="第二节 错误与异常处理"></a>第二节 错误与异常处理</h2><h3 id="Java中的错误和异常"><a href="#Java中的错误和异常" class="headerlink" title="Java中的错误和异常"></a><em>Java中的错误和异常</em></h3><p><strong>Throwable</strong></p>
<ul>
<li>Java.lang.throwable <ul>
<li>Throwable 类是 Java 语言中所有错误或异常的超类。</li>
<li>继承的类：extends Object。</li>
<li>实现的接口：implements Serializable。</li>
<li>直接已知子类：Error, Exception（直接已知子类：IOException、RuntimeException）。</li>
</ul>
</li>
</ul>
<p><strong>Error</strong></p>
<ul>
<li>Error类描述很少发生的Java运行时系统内部的系统错误和资源耗尽情况（例如，VirtualMachineError，LinkageError）。</li>
<li>对于内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结束</li>
<li>Error的类型：<ul>
<li>用户输入错误<ul>
<li>例如：用户要求连接到语法错误的URL，网络层会投诉。</li>
</ul>
</li>
<li>设备错误<ul>
<li>硬件并不总是做你想做的。</li>
<li>输出器被关闭</li>
</ul>
</li>
<li>物理限制<ul>
<li>磁盘可以填满</li>
<li>可能耗尽了可用内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常（Exception）"><a href="#异常（Exception）" class="headerlink" title="异常（Exception）"></a><em>异常（Exception）</em></h3><ul>
<li>异常：程序执行中的非正常事件，程序无法再按预想的流程执行。</li>
<li>异常处理：<ul>
<li>将错误信息传递给上层调用者，并报告“案发现场”的信息。</li>
<li><code>return</code>之外的第二种退出途径：若找不到异常处理程序，整个系统完全退出</li>
</ul>
</li>
</ul>
<p><strong>【异常按结构层次的分类】</strong></p>
<ul>
<li>运行时异常：由程序员处理不当造成，如空指针、数组越界、类型转换</li>
<li>其他异常：程序员无法完全控制的外在问题所导致的，通常为IOE异常，即找不到文件路径等</li>
</ul>
<p><strong>【异常按处理机制角度的分类】</strong></p>
<ul>
<li><p>为什么区分checked 和 unchecked：原因其实很简单，编译器将检查你是否为所有的已检查异常提供了异常处理机制，比如说我们使用<code>Class.forName()</code>来查找给定的字符串的<code>class</code>对象的时候，如果没有为这个方法提供异常处理，编译是无法通过的。 </p>
</li>
<li><p>Checked exception：</p>
<ul>
<li>编译器可帮助检查你的程序是否已抛出或处理了可能的异常</li>
<li>异常的向上抛出机制进行处理，如果子类可能产生A异常，那么在父类中也必须<code>throws A</code>异常。可能导致的问题：代码效率低，耦合度过高。</li>
<li>checked exception是需要强制catch的异常，你在调用这个方法的时候，你如果不catch这个异常，那么编译器就会报错，比如说我们读写文件的时候会<code>catch IOException</code>，执行数据库操作会有<code>SQLException</code>等。</li>
<li>对checked Exception处理机制　　　　<ul>
<li>抛出：声明是<code>throws</code>，抛出时<code>throw</code>　　　</li>
<li>捕获（<code>try</code>&#x2F;<code>catch</code>）：<code>try</code>出现异常，忽略后面代码直接进入<code>catch</code>；无异常不进入<code>catch</code>；若<code>catch</code>中没有匹配的异常处理，程序退出；若子类重写了父类方法，父类方法没有抛出异常，子类应自己处理全部异常而不再传播；子类从父类继承的方法不能增加或更改异常</li>
<li>处理：不能代替简单的测试，尽量苛刻、不过分细化、将正常处理与异常处理分开、利用好层次结构、早抛出晚捕获、避免不必要的检查</li>
<li>清理现场、释放资源（<code>finally</code>）：<code>finally</code>中语句不论有无异常都执行</li>
</ul>
</li>
</ul>
</li>
<li><p>unchecked exception：</p>
<ul>
<li>程序猿对此不做任何事情，不得不重写你的代码（不需要在编译时使用<code>try-catch</code>等机制处理）</li>
<li>这类异常都是<code>RuntimeException</code>的子类，它们不能通过client code来试图解决</li>
<li>这种异常不是必须需要<code>catch</code>的，你是无法预料的，比如说在调用一个<code>list.size()</code>时，如果<code>list</code>为<code>null</code>，那么就会报<code>NullPointerException</code>，而这个异常就是 <code>RuntimeException</code>，也就是<code>UncheckedException</code></li>
<li>常见的unchecked exception：JVM抛出，如空指针、数组越界、数据格式、不合法的参数、不合法的状态、找不到类等</li>
</ul>
</li>
</ul>
<p><strong>checked和unchecked总结</strong></p>
<ul>
<li>当要决定是采用checked exception还是Unchecked exception的时候，问一个问题： “如果这种异常一旦抛出，client会做怎样的补救？”<ul>
<li>如果客户端可以通过其他的方法恢复异常，那么采用checked exception；</li>
<li>如果客户端对出现的这种异常无能为力，那么采用unchecked exception；</li>
<li>异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。</li>
</ul>
</li>
<li>尽量使用unchecked exception来处理编程错误：因为uncheckedexception不用使客户端代码显式的处理它们，它们自己会在出现的地方挂起程序并打印出异常信息。</li>
<li>如果client端对某种异常无能为力，可以把它转变为一个unchecked exception，程序被挂起并返回客户端异常信息</li>
</ul>
<p> <strong>Checked exception应该让客户端从中得到丰富的信息。</strong> </p>
<p><strong>要想让代码更加易读，倾向于用unchecked exception来处理程序中的错误</strong></p>
<h3 id="checked异常的处理机制"><a href="#checked异常的处理机制" class="headerlink" title="checked异常的处理机制"></a><em>checked异常的处理机制</em></h3><p> <strong>异常中的LSP原则</strong></p>
<ul>
<li>如果子类型中<code>override</code>了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更广泛</li>
<li>子类型方法可以抛出更具体的异常，也可以不抛出任何异常</li>
<li>如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。</li>
<li>其他的参考第五章第二节的LSP</li>
</ul>
<p><strong>利用<code>throws</code>进行声明</strong></p>
<ul>
<li>使用<code>throws</code>声明异常：此时需要告知你的client需要处理这些异常，如果client没有handler来处理被抛出的checked exception，程序就终止执行。</li>
<li>程序员必须在方法的spec中明确写清本方法会抛出的所有checked exception，以便于调用该方法的client加以处理</li>
<li>在使用throws时，方法要在定义和spec中明确声明所抛出的全部checked exception，没有抛出checked异常，编译出错，Unchecked异常和Error可以不用处理。</li>
</ul>
<p><strong>利用<code>throw</code>抛出一个异常</strong></p>
<ul>
<li>步骤：<ul>
<li>找到一个能表达错误的<code>Exception</code>类&#x2F;或者构造一个新的<code>Exception</code>类</li>
<li>构造<code>Exception</code>类的实例，将错误信息写入</li>
<li>抛出它</li>
</ul>
</li>
<li>一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码</li>
</ul>
<p> <strong><code>try-catch</code>语句</strong></p>
<ul>
<li>使用<code>try</code>和<code>catch</code>关键字可以捕获异常。<code>try</code>&#x2F;<code>catch</code>代码块放在异常可能发生的地方。</li>
<li><code>try</code>&#x2F;<code>catch</code>代码块中的代码称为保护代码，</li>
<li><code>catch</code>语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，<code>try</code>后面的<code>catch</code>块就会被检查。</li>
<li>如果发生的异常包含在<code>catch</code>块中，异常会被传递到该<code>catch</code>块，这和传递一个参数到方法是一样。</li>
</ul>
<p><strong><code>finally</code>语句</strong></p>
<ul>
<li>场景：当异常抛出时，方法中正常执行的代码被终止；但如果异常发生前曾申请过某些资源，那么异常发生后这些资源要被恰当的清理，所以需要用<code>finally</code>语句。</li>
<li><code>finally</code> 关键字用来创建在 try 代码块后面执行的代码块。</li>
<li>无论是否发生异常，<code>finally</code> 代码块中的代码总会被执行。</li>
<li>在 <code>finally</code> 代码块中，可以运行清理类型等收尾善后性质的语句。</li>
<li><code>finally</code> 代码块出现在<code>catch</code>代码块最后：</li>
<li>注意下面事项：<ul>
<li><code>catch</code>不能独立于<code>try</code>存在。</li>
<li>在<code>try</code>&#x2F;<code>catch</code>后面添加 <code>finally</code> 块并非强制性要求的。</li>
<li><code>try</code>代码后不能既没<code>catch</code>块也没 <code>finally</code>块。</li>
<li><code>try, catch, finally</code>块之间不能添加任何代码。</li>
</ul>
</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a><em>自定义异常</em></h3><ul>
<li>如果JDK提供的exception类无法充分描述你的程序发生的错误，可以创建自己的异常类。<ul>
<li>如果希望写一个检查性异常类，则需要继承<code>Exception</code>类。</li>
<li>如果你想写一个运行时异常类，那么需要继承<code>RuntimeException</code>类。</li>
</ul>
</li>
</ul>
<h2 id="第三节-断言和防御性编程"><a href="#第三节-断言和防御性编程" class="headerlink" title="第三节 断言和防御性编程"></a>第三节 断言和防御性编程</h2><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a><em>断言</em></h3><p><strong>什么是断言</strong></p>
<ul>
<li><strong>作用：</strong>允许程序在运行时检查自己，测试有关程序逻辑的假设，如前置条件、后置条件、内部不变量、表示不变量、控制流不变量等</li>
<li><strong>目的</strong>： 为了在开发阶段调试程序、尽快避免错误</li>
<li>使用阶段：<ul>
<li>断言主要用于开发阶段，避免引入和帮助发现bug</li>
<li>实际运行阶段， 不再使用断言</li>
<li>软件发布阶段，禁用断言避免影响性能。</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>输入参数或输出参数的取值处于预期范围</li>
<li>子程序开始执行（结束）时，文件或流处于打开（关闭）状态</li>
<li>子程序开始执行（结束）时，文件或流的读写位置处于开头（结尾）</li>
<li>文件或流已打开</li>
<li>输入变量的值没有被子程序修改</li>
<li>指针非空</li>
<li>传入子程序的数组至少能容纳X个元素</li>
<li>表已初始化，存储着真实的数据</li>
<li>子程序开始（结束）时，容器空（满）</li>
<li>一个高度优化过的子程序与一个缓慢的子程序，结果一致</li>
<li>断言只在开发阶段被编译到目标代码中，而在生成代码时不编译进去。使用断言的指导建议：</li>
<li>用错误处理代码来处理预期会发生的状况，断言不行</li>
<li>避免把需要执行的代码放入断言中（如果未编译断言呢？）</li>
<li>用断言来注解并验证前条件和后条件</li>
<li>对于高健壮性的代码，应该先用断言，再处理错误</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>编译时加入-ea(enable assertion)选项运行断言，-da(disable assertion)关闭断言</li>
<li>条件语句或开关没有涵盖所有可能的情况，最好使用断言来阻止非法事件</li>
<li>可以在预计正常情况下程序不会到达的地方放置断言：<code>assert false</code></li>
<li>断言有代价，需慎用，一般用于验证正确性，处理绝不应该发生的情况</li>
<li>不能作为公共方法的检查，也不能有边界效应</li>
</ul>
<p> <strong>断言和异常的对比</strong></p>
<ul>
<li>用异常处理技术来处理你“希望发生”的不正常情况</li>
<li>用断言来处理“不希望发生”的情况；断言的方式处理一定是发生了错误</li>
<li>不要把业务逻辑（执行代码）放到断言里面去处理</li>
<li>参数检查通常是方法发布的规范（或契约）的一部分，无论断言是启用还是禁用，都必须遵守这些规范。<ul>
<li>如果参数来自于外部（不受自己控制），使用异常处理</li>
<li>如果来自于自己所写的其他代码，可以使用断言来帮助发现错误（例如postcondition就需要）</li>
</ul>
</li>
</ul>
<h2 id="第四节-调试"><a href="#第四节-调试" class="headerlink" title="第四节 调试"></a>第四节 调试</h2><h3 id="什么是bug"><a href="#什么是bug" class="headerlink" title="什么是bug"></a><em>什么是bug</em></h3><ul>
<li>bug即程序中的错误，导致程序以非预期或未预料到的方式执行。</li>
<li>一个包含大量bug和&#x2F;或严重干扰其功能的bug的程序被称为buggy。</li>
<li>报告程序中的bug通常被称为bug报告、故障报告、问题报告、故障报告、缺陷报告等</li>
</ul>
<p><strong>bug产生的原因</strong></p>
<ul>
<li>代码错误</li>
<li>未完成的要求或不够详细</li>
<li>误解用户需求</li>
<li>设计文档中的逻辑错误</li>
<li>缺乏文件</li>
<li>没有足够的测试</li>
</ul>
<p><strong>bug的常见类型</strong></p>
<ul>
<li>数学bug：例如 零除法，算术溢出</li>
<li>逻辑bug：例如 无线循环和无限递归</li>
<li>源头bug：例如 使用了为被定义的变量、资源泄漏，其中有限的系统资源如内存或文件句柄通过重复分配耗尽而不释放。缓冲区溢出，其中程序试图将数据存储在分配存储的末尾。</li>
<li>团队工程bug：例如 评论过时或者评论错误、文件与实际产品的区别</li>
</ul>
<h3 id="调试的基本过程"><a href="#调试的基本过程" class="headerlink" title="调试的基本过程"></a><em>调试的基本过程</em></h3><ul>
<li>Debug是测试的后续步骤：测试发现问题，debug消除问题；当防御式编程和测试都无法挡住bug时，我们就必须进行debug了；</li>
<li>Debug的目的：寻求错误的根源并消除它；（Debug占用了大量的时间）</li>
</ul>
<p><strong>调试的过程</strong></p>
<ul>
<li><strong>常用方法：假设-检验</strong></li>
<li>重现（Reproduce）$\to$诊断（Diagnose&#x2F;Locating）$\to$修复（Fix）$\to$反思（Reflect）</li>
<li>重现（Reproduce）：寻找一个可靠、方便得在线需求问题的方法。<ul>
<li>从最小的测试用例开始复现错误（保持复现bug的前提下降低输入规模）</li>
<li>消除因版本、环境、配置等不同引起的差异（通过构建软件实现），确定bug出现的环境（通过程序模拟硬件平台的细节，实现不同的操作系统环境）</li>
<li>利用逆向设计推断导致错误的输入</li>
<li>若无法重现，则无法观察以证明分析和修补的正确性</li>
</ul>
</li>
<li>诊断（Diagnose&#x2F;Locating）：构建假设，并通过执行实验来测试它们，直到您确信已识别错误的根本原因。<ul>
<li>从假设开始，构造实验，证明它是对的或者错的</li>
<li>从不符合理论的观察结果开始，修正理论</li>
<li>查看导致错误的测试输入，以及错误的结果，失败的断言以及由此导致的堆栈跟踪</li>
<li>提出一个与所有数据一致的假设，说明错误发生的位置或错误发生的位置，设计实验测试假设</li>
<li>收集实验数据，减少错误可能出现的范围，做出新的假设</li>
<li>设计不同的实验：检查内部状态、修改运行方式、改变本身逻辑 </li>
<li>每次只做一个修改、做好记录、不忽略细节、运行不同的测试用例、设置断点、用可实现相同功能并且被证实无问题的组件替代当前组件</li>
</ul>
</li>
<li>修复（Fix）：设计和实施解决问题的变化，避免引入回归，并保持或提高软件的整体质量。<ul>
<li>确保从干净的源代码树开始</li>
<li>运行现有的测试，并证明它们通过</li>
<li>添加一个或多个新测试，或修复现有测试，以演示错误</li>
<li>修复错误、发现可改进之处</li>
<li>证明你的修复工作正常且没有引入回归（以前通过的测试现在失败）</li>
<li>如果引入回归，通过回顾以前的版本来找出确切的变化</li>
</ul>
</li>
<li>反思（Reflect）：思考需求、设计、测试、结构（库、编译器等）</li>
</ul>
<h3 id="调试的技术和工具"><a href="#调试的技术和工具" class="headerlink" title="调试的技术和工具"></a><em>调试的技术和工具</em></h3><p><strong>调试技术</strong></p>
<ul>
<li>暴力调试（Brute Force Attack）<ul>
<li>蛮力方法可以分为至少三类：<ul>
<li>看内存导出文件</li>
<li>根据“在整个程序中分散打印语句”的常见建议进行调试。</li>
<li>自动化调试工具</li>
</ul>
</li>
</ul>
</li>
<li>递归调试（Induction）</li>
<li>演绎调试（Decution）</li>
<li>回溯调试（Backtracking）</li>
<li>测试调试（Testing）</li>
</ul>
<p><strong>调试工具</strong></p>
<ul>
<li>语法和逻辑检查（本课程未涵盖）</li>
<li>源代码比较器(Source-code comparator)</li>
<li>内存堆转储（Memory heap dump）</li>
<li>打印调试&#x2F;日志记录(Print debugging &#x2F; logging)</li>
<li>堆栈跟踪(Stack trace)</li>
<li>编译器警告消息(Compiler Warning Messages)</li>
<li>调试器(Debugger)</li>
<li>执行分析器(Execution Profiler)</li>
<li>测试框架(Test Framework）</li>
</ul>
<h2 id="第五节-测试与测试优先编程"><a href="#第五节-测试与测试优先编程" class="headerlink" title="第五节 测试与测试优先编程"></a>第五节 测试与测试优先编程</h2><h3 id="测试和测试优先编程"><a href="#测试和测试优先编程" class="headerlink" title="测试和测试优先编程"></a><em>测试和测试优先编程</em></h3><p><strong>测试的定义</strong></p>
<ul>
<li>测试：发现程序中的错误 提高程序正确性的信心</li>
<li>程序正确确认的基本方法:<ul>
<li>形式化推理</li>
<li>代码评审</li>
<li>测试</li>
</ul>
</li>
<li>测试是提高软件质量的重要手段<ul>
<li>确认是否可达到可用的级别</li>
<li>关注系统某一侧面的质量特性</li>
<li>是否满足需求</li>
<li>是否正确响应所有需求</li>
<li>性能是否可接受</li>
<li>是否可用</li>
<li>可否正确部署安装</li>
<li>是否达到期望</li>
</ul>
</li>
</ul>
<p> <strong>测试的分类</strong></p>
<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>系统测试</li>
<li>回归测试</li>
<li>验收测试</li>
</ul>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a><em>黑盒测试</em></h3><ul>
<li><p>白盒测试:对程序内部代码结构的测试 只关注代码内部的问题</p>
</li>
<li><p>黑盒测试:对程序外部表现出来的行为的测试 采用两个方法</p>
<ul>
<li><p>等价划分</p>
<p>  将程序可能的输入进行分类 划分为不同集合 包括不合法数据</p>
<ul>
<li>等价类划分可有两种不同的情况：有效等价类和无效等价类。</li>
<li>若一组对象自反、对称、传递，则为等价类</li>
<li>可产生相似结果的输入集合中的一个可代替整个集合</li>
<li>同理，对输出也可以划分等价类</li>
<li>极端：每个分区只有一个测试用例，覆盖所有分区</li>
</ul>
</li>
<li><p>边界值分析方法</p>
<p>  边界值分析法是对输入输出的边界值进行测试一种黑盒测试方法，是对等价类分析法的补充。</p>
<ul>
<li>错误通常隐藏在边界中，如一位偏移、边界值需单独处理等</li>
<li>找到有效数据和无效数据的分界点（最大值、最小值），对该分界点以及两边的值分别单独进行测试。</li>
<li>等价类划分法可以挑选等价类范围内任意一个数据作为代表，而边界值分析法要求每个边界值都要作为测试条件。</li>
</ul>
</li>
</ul>
</li>
<li><p>测试困难</p>
<ul>
<li>软件行为在离散输入空间中差异巨大 <ul>
<li>大多数正确，少数错误</li>
<li>bug出现不遵循特定概率分布</li>
</ul>
</li>
<li>无统计规律可循</li>
</ul>
</li>
</ul>
<h3 id="代码覆盖度"><a href="#代码覆盖度" class="headerlink" title="代码覆盖度"></a><em>代码覆盖度</em></h3><ul>
<li>定义：已有的测试用例有多大程度覆盖了被测程序；</li>
<li>代码覆盖度越低，测试越不充分；但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高；</li>
<li>代码覆盖率高的程序在测试期间执行了更多的源代码，与低代码覆盖率的程序相比，包含未检测到的软件错误的可能性较低</li>
<li>基本覆盖标准：函数覆盖；语句覆盖、分支覆盖、条件覆盖、路径覆盖</li>
<li>测试效果：路径 &gt; 分支 &gt; 语句</li>
<li>测试难度：路径 &gt; 分支 &gt; 语句</li>
</ul>
<h3 id="以注释的形式撰写测试策略"><a href="#以注释的形式撰写测试策略" class="headerlink" title="以注释的形式撰写测试策略"></a><em>以注释的形式撰写测试策略</em></h3><ul>
<li>“测试策略”通俗来讲就是6个字：“测什么”和“怎么测”。测试策略非常重要，需要在程序中显性记录下来。</li>
<li>目的：在代码评审过程中，其他人能够理解你的测试，并评判测试是否充分</li>
<li>在测试类的顶端写策略</li>
<li><img src="https://i.imgur.com/5tn5eZi.png"></li>
<li>在每个测试方法前说明测试用例是如何选择的</li>
<li><img src="https://i.imgur.com/iq0sHgU.png"></li>
</ul>
<h3 id="JUnit-测试用例写法"><a href="#JUnit-测试用例写法" class="headerlink" title="JUnit 测试用例写法"></a><em>JUnit 测试用例写法</em></h3><ul>
<li>JUnit单元测试是依据 注释中<code>@Test</code>之前的方法编写的</li>
<li>JUnit测试经常调用多次方法，使用<code>assertEqual || assertTrue || assertFalse</code>来检查结果</li>
<li><code>@Before</code>：准备测试、完成初始化，每个测试方法前执行一次</li>
<li><code>@After</code>：清理现场，每个测试方法后执行一次</li>
<li><code>@Test</code>：表明测试方法，内含assert语句<ul>
<li>第一个参数是预期结果、第二个参数实施及结果；</li>
<li>如果断言失败，该测试方法直接返回，JUnit记录该测试的失败；</li>
<li>一个测试方法失败，其他测试方法仍运行</li>
<li><code>@Test(expected = *.class)</code>：对错误的测试，expected的属性值是一个异常</li>
<li><code>@Test(timeout = xxx)</code>：测试方法在制定的时间之内没有运行完则失败</li>
</ul>
</li>
<li><code>@ignore</code>：忽略测试方法</li>
<li><em><strong>examples</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evaluate</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String summand: expression.split(<span class="string">&quot;\\+&quot;</span>))</span><br><span class="line">            sum += Integer.valueOf(summand);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evaluatesExpression</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> calculator.evaluate(<span class="string">&quot;1+2+3&quot;</span>);</span><br><span class="line">        assertEquals(<span class="number">6</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180619224136881-874452125.png" alt="img"></p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E7%AC%AC%E5%85%AD%E6%9C%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%E7%AC%AC%E5%85%AD%E6%9C%9F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-06-24 18:11:30" itemprop="dateModified" datetime="2019-06-24T18:11:30+08:00">2019-06-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h2 id="软件构造知识点总结第六期"><a href="#软件构造知识点总结第六期" class="headerlink" title="软件构造知识点总结第六期"></a>软件构造知识点总结第六期</h2><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><hr>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p><strong>并发（concurrency）</strong></p>
<ul>
<li>定义：指的是多线程场景下对共享资源的争夺运行</li>
<li>并发的应用背景：<ul>
<li>网络上的多台计算机</li>
<li>一台计算机上的多个应用</li>
<li>一个CPU上的多核处理器</li>
</ul>
</li>
<li>为什么要有并发：<ul>
<li>摩尔定律失效、“核”变得越来越多</li>
<li>为了充分利用多核和多处理器需要将程序转化为并行执行</li>
</ul>
</li>
<li>并发编程的两种模式：<ul>
<li>共享内存：在内存中读写共享数据</li>
<li>信息传递（Message Passing）：通过channel交换消息</li>
</ul>
</li>
</ul>
<p><strong>共享内存</strong></p>
<ul>
<li>共享内存这种方式比较常见，我们经常会设置一个共享变量，然后多个线程去操作同一个共享变量。从而达到线程通讯的目的。</li>
<li>例子：<ul>
<li>两个处理器，共享内存</li>
<li>同一台机器上的两个程序，共享文件系统</li>
<li>同一个Java程序内的两个线程，共享Java对象</li>
</ul>
</li>
</ul>
<p><strong>信息传递</strong></p>
<ul>
<li>消息传递方式采取的是线程之间的直接通信，不同的线程之间通过显式的发送消息来达到交互目的</li>
<li>接收方将收到的消息形成队列逐一处理，消息发送者继续发送（异步方式）</li>
<li>消息传递机制也无法解决竞争条件问题</li>
<li>仍然存在消息传递时间上的交错</li>
<li>例子：<ul>
<li>网络上的两台计算机，通过网络连接通讯</li>
<li>浏览器和Web服务器，A请求页面，B发送页面数据给A</li>
<li>即时通讯软件的客户端和服务器</li>
<li>同一台计算机上的两个程序，通过管道连接进行通讯</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">并发模型</th>
<th align="center">通信机制</th>
<th align="center">同步机制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">共享内存</td>
<td align="center">线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。</td>
<td align="center">同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</td>
</tr>
<tr>
<td align="center">消息传递</td>
<td align="center">线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</td>
<td align="center">由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</td>
</tr>
</tbody></table>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><em>进程和线程</em></h3><ul>
<li>进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。<ul>
<li>程序运行时在内存中分配自己独立的运行空间</li>
<li>进程拥有整台计算机的资源</li>
<li>多进程之间不共享内存</li>
<li>进程之间通过消息传递进行协作</li>
<li>一般来说，进程<code>==</code>程序<code>==</code>应用（但一个应用中可能包含多个进程）</li>
<li>OS支持的IPC机制(pipe&#x2F;socket)支持进程间通信（IPC不仅是本机的多个进程之间， 也可以是不同机器的多个进程之间）</li>
<li>JVM通常运行单一进程，但也可以创建新的进程。</li>
</ul>
</li>
<li>线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。<ul>
<li>线程有自己的堆栈和局部变量，但是多个线程共享内存空间</li>
<li>进程&#x3D;虚拟机；线程&#x3D;虚拟CPU</li>
<li>程序共享、资源共享，都隶属于进程</li>
<li>很难获得线程私有的内存空间</li>
<li>线程需要同步：在改变对象时要保持lock状态</li>
<li>清理线程是不安全的</li>
</ul>
</li>
<li>进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。</li>
<li>一个进程中至少应该有一个线程。</li>
<li>主线程可以创建其他的线程。</li>
</ul>
<h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a><em>线程的创建和启动</em></h3><p><strong>方式1：继承<code>Thread</code>类</strong></p>
<ul>
<li>方法：用<code>Thread</code>类实现了<code>Runnable</code>接口，但它其中的<code>run</code>方法什么都没做，所以用一个类做<code>Thread</code>的子类，提供它自己实现的<code>run</code>方法。用<code>Thread.start()</code>来开始一个新的线程。</li>
<li>创建：<code>A a = new A()</code>;</li>
<li>启动：<code>a.start()</code>;</li>
<li>步骤:<ul>
<li>定义一个类A继承于<code>java.lang.Thread</code>类.</li>
<li>在<code>A</code>类中覆盖<code>Thread</code>类中的<code>run</code>方法.</li>
<li>我们在<code>run</code>方法中编写需要执行的操作：<code>run</code>方法里的代码,线程执行体.</li>
<li>在<code>main</code>方法(线程)中,创建线程对象,并启动线程.</li>
</ul>
</li>
<li><em><strong>examples</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1):定义一个类A继承于java.lang.Thread类.  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;  </span><br><span class="line">     <span class="comment">//2):在A类中覆盖Thread类中的run方法.  </span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">          <span class="comment">//3):在run方法中编写需要执行的操作  </span></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i ++)&#123;  </span><br><span class="line">              System.out.println(<span class="string">&quot;播放音乐&quot;</span>+i);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsThreadDemo</span> &#123;  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;             </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">50</span>; j ++)&#123;  </span><br><span class="line">             System.out.println(<span class="string">&quot;运行游戏&quot;</span>+j);  </span><br><span class="line">             <span class="keyword">if</span>(j == <span class="number">10</span>)&#123;  </span><br><span class="line">                 <span class="comment">//4):在main方法(线程)中,创建线程对象,并启动线程.  </span></span><br><span class="line">                 <span class="type">MusicThread</span> <span class="variable">music</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicThread</span>();  </span><br><span class="line">                 music.start();  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>方式2：实现Runable接口</strong></p>
<ul>
<li><strong>创建</strong>：<code>Thread  t = new Thread(new  A())</code>;</li>
<li><strong>调用</strong>：<code>t.start()</code>;</li>
<li>步骤<ul>
<li>定义一个类A实现于<code>java.lang.Runnable</code>接口,注意A类不是线程类.</li>
<li>在A类中覆盖<code>Runnable</code>接口中的<code>run</code>方法.</li>
<li>我们在<code>run</code>方法中编写需要执行的操作：<code>run</code>方法里的,线程执行体.</li>
<li>在<code>main</code>方法(线程)中,创建线程对象,并启动线程.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1):定义一个类A实现于java.lang.Runnable接口,注意A类不是线程类.  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicImplements</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="comment">//2):在A类中覆盖Runnable接口中的run方法.  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">//3):在run方法中编写需要执行的操作  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i ++)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;播放音乐&quot;</span>+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementsRunnableDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">50</span>; j ++)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;运行游戏&quot;</span>+j);  </span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">10</span>)&#123;  </span><br><span class="line">                <span class="comment">//4):在main方法(线程)中,创建线程对象,并启动线程  </span></span><br><span class="line">                <span class="type">MusicImplements</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicImplements</span>();  </span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mi);  </span><br><span class="line">                t.start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>实现<code>Runnable</code>接口相比继承<code>Thread</code>类有如下好处：</p>
<ul>
<li>避免点继承的局限，一个类可以继承多个接口。</li>
<li>适合于资源的共享</li>
</ul>
</li>
<li><p>创建并运行一个线程所犯的常见错误是调用线程的<code>run()</code>方法而非<code>start()</code>方法，如下所示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">newThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(MyRunnable());</span><br><span class="line">newThread.run();  <span class="comment">//should be start();</span></span><br></pre></td></tr></table></figure>

<p>　　起初并不会感觉到有什么不妥，因为<code>run()</code>方法的确如你所愿的被调用了。但是，事实上，<code>run()</code>方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行<code>run()</code>方法，必须调用新线程的<code>start()</code>方法。</p>
<h3 id="时间分片、交错执行、竞争条件"><a href="#时间分片、交错执行、竞争条件" class="headerlink" title="时间分片、交错执行、竞争条件"></a><em>时间分片、交错执行、竞争条件</em></h3><p> <strong>时间分片</strong></p>
<ul>
<li>虽然有多线程，但只有一个核，每个时刻只能执行一个线程。<ul>
<li>通过时间分片，再多个线程&#x2F;进程之间共享处理器</li>
</ul>
</li>
<li>即使是多核CPU，进程&#x2F;线程的数目也往往大于核的数目</li>
<li>通过时间分片，在多个进程&#x2F;线程之间共享处理器。（时间分片是由OS自动调度的）</li>
<li>当线程数多于处理器数量时，并发性通过时间片来模拟，处理器切换处理不同的线程</li>
</ul>
<p> <strong>交错执行</strong></p>
<p>　　顾名思义，就是说在线程运行的过程中，多个线程同时运行相互交错。而且，由于线程运行一般不是连续的，那么就会导致线程间的交错。可以说，所有线程安全问题的本质都是线程交错的问题。</p>
<p> <strong>竞争条件</strong></p>
<p>　　竞争是发生在线程交错的基础上的。当多个线程对同一对象进行读写访问时，就可能会导致竞争的问题。程序中可能出现的一种问题就是，读写数据发生了不同步。例如，我要用一个数据，在该数据修改还没写回内存中时就读取出来了，那么就会导致程序出现问题。</p>
<p>　　程序运行时有一种情况，就是程序如果要正确运行，必须保证A线程在B线程之前完成（正确性意味着程序运行满足其规约）。当发生这种情况时，就可以说A与B发生竞争关系。</p>
<ul>
<li>计算机运行过程中，并发、无序、大量的进程在使用有限、独占、不可抢占的资源，由于进程无限，资源有限，产生矛盾，这种矛盾称为竞争（Race）。</li>
<li>由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题，这叫做竞争条件（Race Condition）。</li>
<li>竞争条件分为两类:<br>-Mutex（互斥）：两个或多个进程彼此之间没有内在的制约关系，但是由于要抢占使用某个临界资源（不能被多个进程同时使用的资源，如打印机，变量）而产生制约关系。<br>-Synchronization（同步）：两个或多个进程彼此之间存在内在的制约关系（前一个进程执行完，其他的进程才能执行），如严格轮转法。</li>
<li>解决互斥方法：<br>Busy Waiting(忙等待)：等着但是不停的检查测试，不睡觉，知道能进行为止<br>Sleep and Wakeup(睡眠与唤醒)：引入Semapgore(信号量，包含整数和等待队列,为进程睡觉而设置)，唤醒由其他进程引发。</li>
<li>临界区（Critical Region）：<ul>
<li>一段访问临界资源的代码。</li>
<li>为了避免出现竞争条件，进入临界区要遵循四条原则： <ul>
<li>任何两个进程不能同时进入访问同一临界资源的临界区</li>
<li>进程的个数，CPU个数性能等都是无序的，随机的</li>
<li>临界区之外的进程不得阻塞其他进程进入临界区</li>
<li>任何进程都不应被长期阻塞在临界区之外</li>
</ul>
</li>
</ul>
</li>
<li>解决互斥的方法:<br>• 禁用中断 Disabling interrupts<br>• 锁变量 Lock variables （no）<br>• 严格轮转 Strict alternation (no)<br>• Peterson’s solution (yes)<br>• The TSL instruction (yes)</li>
</ul>
<h3 id="线程的休眠、中断"><a href="#线程的休眠、中断" class="headerlink" title="线程的休眠、中断"></a><em>线程的休眠、中断</em></h3><p> <strong><code>Thread.sleep</code></strong></p>
<ul>
<li>在线程中允许一个线程进行暂时的休眠，直接使用<code>Thread.sleep()</code>方法即可。 <ul>
<li>将某个线程休眠，意味着其他线程得到更多的执行机会</li>
<li>进入休眠的线程不会失去对现有monitor或锁的所有权</li>
</ul>
</li>
<li>sleep定义格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> milis,<span class="type">int</span> nanos)</span></span><br><span class="line">       <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<p>　　首先，**<code>static</code>，说明可以由<code>Thread</code>类名称调用<strong>，其次</strong><code>throws</code>表示如果有异常要在调用此方法处处理异常**。</p>
<p><strong>所以<code>sleep()</code>方法要有<code>InterruptedException</code>异常处理，而且<code>sleep()</code>调用方法通常为<code>Thread.sleep(500);</code>形式。</strong></p>
<p><strong><code>Thread.interrupt</code></strong> </p>
<ul>
<li><p>一个线程可以被另一个线程中断其操作的状态，使用<code>interrupt()</code>方法完成。</p>
<ul>
<li>通过线程的实例来调用<code>interrupt()</code>函数，向线程发出中断信号</li>
<li><code>t.interrupt()</code>：在其他线程里向<code>t</code>发出中断信号</li>
<li><code>t.isInterrupted()</code>：检查<code>t</code>是否已在中断状态中</li>
</ul>
</li>
<li><p>当某个线程被中断后，一般来说应停止其<code>run()</code>中的执行，取决于程序员在<code>run()</code>中处理</p>
<ul>
<li>一般来说，线程在收到中断信号时应该中断，直接终止</li>
<li>但是，线程收到其他线程发出来的中断信号，并不意味着一定要“停止”</li>
</ul>
</li>
<li><p>实例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Thread1;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;    <span class="comment">// 实现Runnable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;    <span class="comment">// 覆写run()方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1、进入run()方法&quot;</span>) ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>) ;    <span class="comment">// 线程休眠10秒</span></span><br><span class="line">                System.out.println(<span class="string">&quot;2、已经完成了休眠&quot;</span>) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3、休眠被终止&quot;</span>) ;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">// 返回调用处</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;4、run()方法正常结束&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;    <span class="comment">// 实例化Runnable子类对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mt,<span class="string">&quot;线程&quot;</span>);        <span class="comment">// 实例化Thread对象</span></span><br><span class="line">        t.start() ;    <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>) ;    <span class="comment">// 线程休眠2秒</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3、休眠被终止&quot;</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt() ;    <span class="comment">// 中断线程执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、进入run()方法</span><br><span class="line">3、休眠被终止</span><br></pre></td></tr></table></figure>

<h3 id="线程安全的四个策略"><a href="#线程安全的四个策略" class="headerlink" title="线程安全的四个策略"></a><em>线程安全的四个策略</em></h3><ul>
<li>线程安全的定义：ADT或方法在多线程中要执行正确，即无论如何执行，不许调度者做额外的协作，都能满足正确性</li>
<li>四种线程安全的策略：<ul>
<li>Confinement 限制数据共享</li>
<li>Immutability 共享不可变数据</li>
<li>Threadsafe data type 共享线程安全的可变数据</li>
<li>Synchronization 同步机制共享共享线程不安全的可变数据，对外即为线程安全的ADT.</li>
</ul>
</li>
</ul>
<p><strong>Confinement限制数据共享</strong></p>
<ul>
<li>核心思想：线程之间不共享mutable数据类型<ul>
<li>将可变数据限制在单一线程内部，避免竞争</li>
<li>不允许任何县城直接读写该数据</li>
</ul>
</li>
<li>在多线程环境中，取消全局变量，尽量避免使用不安全的静态变量。<ul>
<li>限制数据共享主要是在线程内部使用局部变量，因为局部变量在每个函数的栈内，每个函数都有自己的栈结构，互不影响，这样局部变量之间也互不影响。</li>
<li>如果局部变量是一个指向对象的引用，那么就需要检查该对象是否被限制住，如果没有被限制住（即可以被其他线程所访问），那么就没有限制住数据，因此也就不能用这种方法来保证线程安全</li>
</ul>
</li>
<li><em><strong>examples</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes n! and prints it on standard output.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n must be &gt;= 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">computeFact</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;working on fact &quot;</span> + n);</span><br><span class="line">            result = result.multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;fact(&quot;</span> + n + <span class="string">&quot;) = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">// create a thread using an</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;     <span class="comment">// anonymous Runnable</span></span><br><span class="line">                computeFact(<span class="number">99</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        computeFact(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 解释：主函数开启了两个线程，调用的是相同函数。因为线程共享局部变量的类型，但每个函数调用有不同的栈，因此有不同的<code>i, n, result</code>。由于每个函数都有自己的局部变量，那么每个函数就可以独立运行，更新它们自己的函数值，线程之间不影响结果。</p>
<p><strong>Immutability共享不可变数据</strong> </p>
<p>不可变数据类型，指那些在整个程序运行过程中，指向内存的引用是一直不变的，通常使用<code>final</code>来修饰。不可变数据类型通常来讲是线程安全的，但也可能发生意外。</p>
<p>但是，程序在运行过程中，有时为了优化程序结构，默默地将这个引用更改了。此时，客户端程序员是不知道它被更改了，对于客户端而言，这个引用还是不可变的，但其实已经被悄悄更改了。这时就会发生一些线程安全问题。</p>
<p>解决方案就是给这些不可变数据类型再增加一些限制：</p>
<ul>
<li>所有的方法和属性都是私有的。</li>
<li>不提供可变的方法，即不对外开放可以更改内部属性的方法。</li>
<li>没有数据的泄露，即返回值而不是引用。</li>
<li>不在其中存储可变数据对象。</li>
</ul>
<p>这样就可以保证线程的安全了。</p>
<p><strong>Threadsafe data type（共享线程安全的可变数据）</strong></p>
<ul>
<li>方法：如果必须要用mutable的数据类型在多线程之间共享数据，要使用线程安全的数据类型。（在JDK中的类，文档中明确指明了是否threadsafe）</li>
<li>一般来说，JDK同时提供两个相同功能的类，一个是threadsafe，另一个不是。原因：threadsafe的类一般性能上受影响。</li>
<li><code>List、Set、Map</code>这些集合类都是线程不安全的，Java API为这些集合类提供了进一步的decorator</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Boolean&gt; cache = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; SortedSet&lt;T&gt; <span class="title function_">synchronizedSortedSet</span><span class="params">(SortedSet&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; SortedMap&lt;K,V&gt; <span class="title function_">synchronizedSortedMap</span><span class="params">(SortedMap&lt;K,V&gt; m)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用<code>synchronizedMap(hashMap)</code>之后，不要再把参数<code>hashMap</code>共享给其他线程，不要保留别名，一定要彻底销毁.（可以用<code>private static Map cache = Collections.synchronizedMap(new HashMap&lt;&gt;())</code>;的方式实例化集合类）</li>
<li>即使在线程安全的集合类上，使用<code>iterator</code>也是不安全的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Type&gt; c = Collections.synchronizedList(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">ArrayList</span>&lt;Type&gt;());</span><br><span class="line"><span class="keyword">synchronized</span>(c) &#123; <span class="comment">// to be introduced later (the 4-th threadsafe way)</span></span><br><span class="line">    <span class="keyword">for</span> (Type e : c)</span><br><span class="line">        foo(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意用java提供的包装类包装集合后，只是将集合的每个操作都看成了原子操作，也就保证了每个操作内部的正确性，但是在两个操作之间不能保证集合类不被修改，因此需要用lock机制，例如</li>
</ul>
<p>　　如果在<code>isEmpty</code>和<code>get</code>中间，将元素移除，也就产生了竞争。</p>
<p><strong>前三种策略的核心思想：避免共享$\to$即使共享，也只能读&#x2F;不可写(immutable)$\to$即使可写(mutable)，共享的可写数据应自己具备在多线程之间协调的能力，即“使用线程安全的mutable ADT”</strong></p>
<p> <strong>Synchronization同步与锁</strong></p>
<ul>
<li><p>为什么要同步</p>
<ul>
<li>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）</li>
<li>将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用</li>
<li>保证了该变量的唯一性和准确性</li>
</ul>
</li>
<li><p>同步方法</p>
<ul>
<li><p>即有<code>synchronized</code>关键字修饰的方法。</p>
</li>
<li><p>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。</p>
</li>
<li><p>在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><pre><code>注：`synchronized`关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类
</code></pre>
</li>
</ul>
</li>
<li><p>同步代码块</p>
</li>
</ul>
<pre><code>-   在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

-   被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。

-   代码如：

    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123;...&#125;</span><br></pre></td></tr></table></figure>

-   注：同步是一种高开销的操作，因此应该尽量减少同步的内容。
</code></pre>
<ul>
<li><p>使用锁机制，获得对数据的独家mutation权，其他线程被阻塞，不得访问</p>
</li>
<li><p>Lock是Java语言提供的内嵌机制，每个object都有相关联的lock</p>
</li>
<li><p>任何共享的mutable变量&#x2F;对象必须被lock所保护</p>
</li>
<li><p>涉及到多个mutable变量的时候，它们必须被同一个lock所保护</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><em>死锁</em></h3><ul>
<li><p><strong>定义</strong>：两个或多个线程相互等待对方释放锁，则会出现死锁现象。</p>
</li>
<li><p>java虚拟机没有检测，也没有采用措施来处理死锁情况，所以多线程编程是应该采取措施避免死锁的出现。一旦出现死锁，整个程序即不会发生任何异常，也不会给出任何提示，只是所有线程都处于堵塞状态。</p>
</li>
<li><p><strong>形成死锁的条件：</strong></p>
<ul>
<li>互斥条件：线程使用的资源必须至少有一个是不能共享的（至少有锁）；</li>
<li>请求与保持条件：至少有一个线程必须持有一个资源并且正在等待获取一个当前被其它线程持有的资源（至少两个线程持有不同锁，又在等待对方持有锁）；</li>
<li>非剥夺条件：分配资源不能从相应的线程中被强制剥夺（不能强行获取被其他线程持有锁）；</li>
<li>循环等待条件：第一个线程等待其它线程，后者又在等待第一个线程（线程$A$等线程$B$；线程$B$等线程$C$; $\cdots$ ;线程$N$等线程$A$。如此形成环路）。</li>
</ul>
</li>
<li><p>防止死锁的方法：</p>
<ul>
<li><strong>加锁顺序：</strong>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。这种方式是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的</li>
</ul>
</li>
<li><ul>
<li><p>使用粗粒度的锁，用单个锁来监控多个对象</p>
<ul>
<li>对整个社交网 络设置 一个锁 ，并且对其任何组成部分的所有操作都在该锁上进行同步。</li>
<li>例如：所有的Wizards都属于一个Castle,  可使用 castle 实例的锁</li>
</ul>
<p>　　缺点：性能损失大；</p>
<ul>
<li>如果用一个锁保护大量的可变数据，那么久放弃了同时访问这些数据的能力；</li>
<li>在最糟糕的情况下，程序可能基本上是顺序执行的，丧失了并发性</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>加锁时限</strong>：在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁。</li>
<li>用 jstack 等工具进行死锁检测</li>
</ul>
</li>
</ul>
<h3 id="以注释的形式撰写线程安全策略"><a href="#以注释的形式撰写线程安全策略" class="headerlink" title="以注释的形式撰写线程安全策略"></a><em>以注释的形式撰写线程安全策略</em></h3><ul>
<li><p>在代码中以注释的形式添加说明：该ADT采取了什么设计决策来保证线程安全</p>
</li>
<li><p>阐述如何使rep线程安全；</p>
</li>
<li><p>写入表示不变性的说明中，以便代码维护者知道你是如何为类设计线程安全性的。</p>
</li>
<li><p>需要对安全性进行这种仔细的论证，阐述使用了哪种技术，使用threadsafe data types, or synchronization时，需要论证所有对数据的访问都是具有原子性的</p>
</li>
<li><p>字符串是不可变的并且是线程安全的; 但是指向该字符串的rep，特别是文本变量，并不是不可变的；</p>
</li>
<li><p>文本不是最终变量，因为我们需要数据类型来支持插入和删除操作；</p>
</li>
<li><p>因此读取和写入文本变量本身不是线程安全的。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%883/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%883/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-06-24 11:51:04" itemprop="dateModified" datetime="2019-06-24T11:51:04+08:00">2019-06-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><hr>
<h2 id="第一节-可复用性的度量、形态和外部观察"><a href="#第一节-可复用性的度量、形态和外部观察" class="headerlink" title="第一节  可复用性的度量、形态和外部观察"></a>第一节  可复用性的度量、形态和外部观察</h2><h3 id="什么是软件复用"><a href="#什么是软件复用" class="headerlink" title="什么是软件复用"></a><em>什么是软件复用</em></h3><ul>
<li>软件复用是使用现有软件组件实施或更新软件系统的过程。 </li>
<li>软件复用的两个观点：<ul>
<li>面向复用编程(programming for reuse)：开发出可复用的软件<ul>
<li>开发成本高于一般软件的成本：要有足够高的适应性</li>
<li>性能差些： 针对更普适场景，缺少足够的针对性</li>
</ul>
</li>
<li>基于复用编程(programming with reuse)：利用已有的可复用软件搭建应用系统<ul>
<li>可复用软件库，对其进行有效的管理</li>
<li>往往无法拿来就用，需要适配</li>
</ul>
</li>
</ul>
</li>
<li>为什么需要复用：</li>
</ul>
<pre><code>-   复用降低成本和开发时间
-   复用的代码经过充分测试，可靠、稳定
-   产出标准化，在不同应用中保持一致
</code></pre>
<ul>
<li><p>软件复用的代价：</p>
<ul>
<li>软件可复用的部分需要设计在如下的标准上：明确的定义、开放的方法、简洁的交互规范、可理解的文档，并着眼于未来。</li>
<li>不仅program for reuse代价高，program with reuse代价也高</li>
</ul>
</li>
<li><p>代码复用的类型：</p>
<ul>
<li>白盒复用：源代码可见，可修改和扩展<ul>
<li>含义：复制已有代码到正在开发的系统，进行修改</li>
<li>优点：可订制化程度高</li>
<li>缺点：对其修改增加了软件的复杂度，且需要对其内部充分的了解</li>
</ul>
</li>
<li>黑盒服用：源代码不可见，不能修改<ul>
<li>含义：只能通过过API接口来使用，无法修改代码</li>
<li>优点：清晰、简单</li>
<li>缺点：适用性差</li>
</ul>
</li>
</ul>
</li>
<li><p>高复用性的软件应具有如下特性：</p>
<ul>
<li>小、简单</li>
<li>与标准兼容</li>
<li>灵活可变</li>
<li>可扩展</li>
<li>泛型、参数化</li>
<li>模块化</li>
<li>变化的局部性</li>
<li>稳定</li>
<li>丰富的文档和帮助</li>
</ul>
</li>
</ul>
<h2 id="可复用实现的级别"><a href="#可复用实现的级别" class="headerlink" title="可复用实现的级别"></a>可复用实现的级别</h2><p><strong>源代码级别的复用</strong></p>
<p><strong>模块级别的复用：类、抽象类、接口</strong></p>
<ul>
<li>复用类：<ul>
<li>源码并非是必要的，可能只需要类文件或jar</li>
<li>只需要将这个类加入到类路径</li>
<li>可以使用工具javap获得一个类的<code>public</code>方法</li>
</ul>
</li>
<li>使用复用类的注意事项：<ul>
<li>文档十分重要</li>
<li>压缩会有助于复用</li>
<li>管理更少的代码</li>
<li>版本兼容性</li>
<li>需要和类相关的包</li>
</ul>
</li>
<li>复用类的方法：继承和委派<ul>
<li>继承（Inheritance）：<ul>
<li>类扩展了现有类的属性&#x2F;行为；</li>
<li>另外，他们可能会<code>Override</code>现有的行为；</li>
<li>通常需要在实施之前设计继承层次结构；</li>
</ul>
</li>
<li>委派（Delegation）：<ul>
<li>根本没有父子关系的类中使用继承是不合理的，可以用委派的方式来代替。</li>
<li>委托是简单的将一个对象连接到另一个对象上，使另一个对象获得这个对象方法的子集（一个实体将某个事物传递给另一个实体）。</li>
<li>明确的委托：明确将需要传的对象传到目标对象上</li>
<li>含蓄的委托：委托可以被描述为一种共享代码数据的低级别机制</li>
<li>委派的类型：<ul>
<li>Use（A uses B）</li>
<li>Composition&#x2F;aggregation (A owns B)</li>
<li>Association (A has B)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>库级别的复用：API&#x2F;包</strong></p>
<ul>
<li>方法：Libaray、framework<ul>
<li>library：<ul>
<li>库定义：一组提供可重用功能的类和方法（API）</li>
<li>开发者构造可运行软件实体，其中涉及到对可复用库的调用</li>
<li>Java中有很多的库可以复用，例如Guava：Google的Java核心库；Apache Commons等</li>
</ul>
</li>
<li>framework：<ul>
<li>框架定义：一组具体类、抽象类、及其之间的连接关系 </li>
<li>作为主程序加以执行，执行过程中调用开发者所写的程序</li>
<li>开发者根据 framework的规约，填充自己的代码进去，形成完整系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>系统级别的复用：框架</strong></p>
<p>　　将framework看作是更大规模的API复用，除了提供可复用的API，还将这 些模块之间的关系都确定下来，形成了整体应用的领域复用。开发者的任务就是增加新代码、对抽象类进行具体化。展开来说就是以下几点：</p>
<ul>
<li>通常通过选择性覆盖来扩展框架; 或者程序员可以添加专门的用户代码来提供特定的功能—定义继承了抽象类祖先操作的具体类</li>
<li>设计模式(Hook方法)，它被应用程序覆盖以扩展框架。 Hook方法系统地将应用程序域的接口和行为与应用程序在特定上下文中所需的变体解耦。</li>
<li>控制反转，由第三方的容器来控制对象之间的依赖关系，而非传统实现中由代码直接操控。由第三方的容器来控制对象之间的依赖关系，而非传统实现中由代码直接操控。</li>
<li>不可修改的框架代码：在接受用户实现的扩展时，框架代码不应该被修改。 换句话说，用户可以扩展框架，但不应修改其代码。</li>
</ul>
<h3 id="对可复用性的外部观察"><a href="#对可复用性的外部观察" class="headerlink" title="对可复用性的外部观察"></a><em>对可复用性的外部观察</em></h3><ul>
<li><p>Type Variation  类型可变</p>
<ul>
<li>能够复用的部分应该类型参数化，以适应不同的数据类型</li>
<li>复用的部分应该一般化</li>
<li>适应不同的类型，且满足LSP</li>
</ul>
</li>
<li><p>Implementation Variation 实现可变</p>
</li>
</ul>
<pre><code>-   ADT 有多种不同的实现，提供不同的representations 和abstract function ，但具有同样的specification (pre-condition, post-condition, invariants) ，从而可以适应不同的应用场景
</code></pre>
<ul>
<li>Routine Grouping 功能分组</li>
</ul>
<pre><code>-   提供完备的细粒度操作，保证功能的完整性，不同场景下复用不同的操作( 及其组合)
</code></pre>
<ul>
<li><p>Representation Independence 表示独立</p>
<ul>
<li>内部实现可能会经常变化，但客户端不应受到影响。</li>
</ul>
</li>
<li><p>Factoring Out Common Behaviors 共性抽取</p>
<ul>
<li>将共同的行为（共性）抽象出来，形成可复用实体</li>
</ul>
</li>
</ul>
<h3 id="白盒框架和黑盒框架"><a href="#白盒框架和黑盒框架" class="headerlink" title="白盒框架和黑盒框架"></a><em>白盒框架和黑盒框架</em></h3><p>框架也可分为白盒框架和黑盒框架两类。 </p>
<ul>
<li>白盒框架：<ul>
<li>通过继承和动态绑定实现可扩展性。</li>
<li>通过继承框架基类并重写预定义的hook方法来扩展现有功能。</li>
<li>通常使用模板方法模式等设计模式来覆盖hook方法。</li>
</ul>
</li>
<li>黑盒框架：<ul>
<li>通过为可插入框架的组件定义接口来实现可扩展性。</li>
<li>通过定义符合特定接口的组件来复用现有功能。</li>
<li>这些组件通过委派（Delegation）与框架集成。</li>
</ul>
</li>
</ul>
<h2 id="第二节-设计可复用的软件"><a href="#第二节-设计可复用的软件" class="headerlink" title="第二节  设计可复用的软件"></a>第二节  设计可复用的软件</h2><h3 id="设计可复用的类——LSP"><a href="#设计可复用的类——LSP" class="headerlink" title="设计可复用的类——LSP"></a><em>设计可复用的类——LSP</em></h3><ul>
<li>在OOP之中设计可复用的类<ul>
<li>封装和信息隐藏</li>
<li>继承和重写</li>
<li>多态、子类和重载</li>
<li>泛型编程</li>
<li><strong>LSP原则</strong></li>
<li><strong>委派和组合（Composition）</strong></li>
</ul>
</li>
</ul>
<p><strong>行为子结构</strong></p>
<ul>
<li><p>子类型多态（ Subtype polymorphism）：客户端可用统一的方式处理不同类型的对象 。</p>
</li>
<li><p><em><strong>examples</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>(); </span><br><span class="line"><span class="type">Animal</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(); </span><br><span class="line"><span class="type">Cat</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure>

<p> 在可以使用<code>a</code>的场景，都可以用<code>c1</code>和<code>c2</code>代替而不会有任何问题。</p>
</li>
<li><p>在java的静态类型检查之中，编译器强调了几条规则：</p>
<ul>
<li>子类型可以增加方法，但不可删</li>
<li>子类型需要实现抽象类型中的所有未实现方法</li>
<li>子类型中重写的方法必须有相同或子类型的返回值</li>
<li>子类型中重写的方法必须使用同样类型的参数</li>
<li>子类型中重写的方法不能抛出额外的异常</li>
</ul>
</li>
<li><p>行为子结构也适用于指定的方法：</p>
<ul>
<li>更强的不变量</li>
<li>更弱的前置条件</li>
<li>更强的后置条件</li>
</ul>
</li>
</ul>
<p><strong>逆变与协变</strong></p>
<ul>
<li><p>逆变与协变综述：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承关系（比如，$A≤B$表示A是由B派生出来的子类）：</p>
<ul>
<li>f(⋅)是逆变（contravariant）的，当$A \le B$时有$f(B) \le f(A)$成立；</li>
<li>f(⋅)是协变（covariant）的，当$A \le B$时有$f(A) \le f(B)$成立；</li>
<li>f(⋅)是不变（invariant）的，当$A \le B$时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。</li>
</ul>
</li>
<li><p>协变（Co-variance）：</p>
<ul>
<li>父类型$\to$子类型：越来越具体(specific)。</li>
<li>在LSP中，返回值和异常的类型：不变或变得更具体 。</li>
<li><em><strong>examples</strong></em></li>
</ul>
</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180613214134458-1132318774.png" alt="img"></p>
<ul>
<li>逆变(Contra-variance)：<ul>
<li>父类型$\to$子类型：越来越抽象。</li>
<li>参数类型：要相反的变化，不变或越来越抽象。 </li>
<li><em><strong>examples</strong></em></li>
</ul>
</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180613214453893-254989486.png" alt="img"></p>
<p>这在Java中是不允许的，因为它会使重载规则复杂化。</p>
<p><strong>Liskov替换原则(LSP)</strong></p>
<ul>
<li>里氏替换原则的主要作用就是规范继承时子类的一些书写规则。其主要目的就是保持父类方法不被覆盖。</li>
<li>含义：<ul>
<li>子类必须完全实现父类的方法</li>
<li>子类可以有自己的个性</li>
<li>覆盖或实现父类的方法时输入参数可以被放大</li>
<li>覆盖或实现父类的方法时输出结果可以被缩小</li>
</ul>
</li>
<li>LSP是子类型关系的一个特殊定义，称为（强）行为子类型化。在编程语言中，LSP依赖于以下限制：<ul>
<li>前置条件不能强化</li>
<li>后置条件不能弱化</li>
<li>不变量要保持或增强</li>
<li>子类型方法参数：逆变</li>
<li>子类型方法的返回值：协变</li>
<li>异常类型：协变</li>
</ul>
</li>
</ul>
<h2 id="各种应用中的LSP"><a href="#各种应用中的LSP" class="headerlink" title="各种应用中的LSP"></a>各种应用中的LSP</h2><p><strong>数组是协变的</strong></p>
<ul>
<li>数组是协变的：一个数组<code>T[]</code> ，可能包含了T类型的实例或者T的任何子类型的实例</li>
<li>即子类型的数组可以赋予父类型的数组进行使用，但数组的类型实际为子类型。</li>
</ul>
<p><strong>泛型中的LSP</strong></p>
<ul>
<li>Java中泛型是不变的,但可以通过通配符”?”实现协变和逆变：<ul>
<li><code>&lt;? extends&gt;</code>实现了泛型的协变：<code>List&lt;? extends Number&gt; list = new ArrayList&lt;Integer&gt;()</code>;</li>
<li><code>&lt;? super&gt;</code>实现了泛型的逆变：<code>List&lt;? super Number&gt; list = new ArrayList&lt;Object&gt;()</code>;</li>
</ul>
</li>
<li>由于泛型的协变只能规定类的上界，逆变只能规定下界，使用时需要遵循PECS（producer–extends, consumer-super）：<ul>
<li>要从泛型类取数据时，用extends；</li>
<li>要往泛型类写数据时，用super；</li>
<li>既要取又要写，就不用通配符（即extends与super都不用）。</li>
</ul>
</li>
<li>泛型是类型不变的（泛型不是协变的）。举例来说 <ul>
<li><code>ArrayList&lt;String&gt;</code> 是<code>List&lt;String&gt;</code>的子类型 </li>
<li><code>List&lt;String&gt;</code>不是<code>List&lt;Object&gt;</code>的子类型</li>
</ul>
</li>
<li>在代码的编译完成之后，泛型的类型信息就会被编译器擦除。因此，这些类型信息并不能在运行阶段时被获得。这一过程称之为类型擦除（type erasure）。</li>
<li>类型擦除的详细定义：如果类型参数没有限制，则用它们的边界或Object来替换泛型类型中的所有类型参数。因此，产生的字节码只包含普通的类、接口和方法。</li>
<li>类型擦除的结果：<code>&lt;T&gt;</code>被擦除<code>T</code>变成了<code>Object</code></li>
</ul>
<p><strong>Wildcards（通配符）</strong></p>
<ul>
<li>无界通配符类型使用通配符（<code>?</code>）指定，例如<code>List&lt;?&gt;</code>，这被称为未知类型的列表。 </li>
<li>在两种情况下，无界通配符是一种有用的方法：<ul>
<li>如果您正在编写可使用Object类中提供的功能实现的方法。</li>
<li>当代码使用泛型类中不依赖于类型参数的方法时。 例如<code>List.size</code>或<code>List.clear</code>。 事实上，<code>Class&lt;?&gt;</code>经常被使用，因为<code>Class&lt;T&gt;</code>中的大多数方法不依赖于<code>T</code>。</li>
</ul>
</li>
</ul>
<p> <em><strong>examples</strong></em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;Object&gt; list)</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (Object elem : list) </span><br><span class="line">        System.out.println(elem + <span class="string">&quot; &quot;</span>); </span><br><span class="line">    System.out.println(); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><code>　　printList</code>的目标是打印任何类型的列表，但它无法实现该目标 ，它仅打印<code>Object</code>实例列表; 它不能打印<code>List &lt;Integer&gt;</code>，<code>List &lt;String&gt;</code>，<code>List &lt;Double&gt;</code>等，因为它们不是<code>List &lt;Object&gt;</code>的子类型。 </p>
<ul>
<li>要编写通用的<code>printList</code>方法，请使用<code>List&lt;?&gt;</code></li>
<li>低边界通配符<code>&lt;? super A&gt; e.g. List&lt;? super Integer&gt;  List&lt;Number&gt;</code></li>
<li>上边界通配符<code>&lt;? extends A&gt; e.g. List&lt;? extends Number&gt;  List&lt;Integer&gt;</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(List&lt;?&gt; list)</span> &#123; </span><br><span class="line">    <span class="keyword">for</span> (Object elem: list) </span><br><span class="line">		System.out.println(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">	List&lt;Integer&gt; li = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); </span><br><span class="line">	List&lt;String&gt;  ls = Arrays.asList(<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>); </span><br><span class="line">	printList(li); </span><br><span class="line">	printList(ls);</span><br></pre></td></tr></table></figure>

<h3 id="委派与组合"><a href="#委派与组合" class="headerlink" title="委派与组合"></a><em>委派与组合</em></h3><p><strong>委派（Delegation）</strong></p>
<ul>
<li><p>委派&#x2F;委托：一个对象请求另一个对象的功能 。</p>
</li>
<li><p>委派是复用的一种常见形式。</p>
</li>
<li><p>分为显性委派：将发送对象传递给接收对象；</p>
</li>
<li><p>以及隐性委派：由语言的成员查找规则。</p>
</li>
<li><p>委派设计模式：是一种用来实现委派的软件设计模式；</p>
</li>
<li><p>委派依赖于动态绑定，因为它要求给定的方法调用可以在运行时调用不同的代码段；</p>
</li>
<li><p>委派的过程如下：</p>
</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616010823670-1888403800.png" alt="img"></p>
<pre><code>Receiver对象将操作委托给Delegate对象，同时Receiver对象确保客户端不会滥用委托对象；
</code></pre>
<p><strong>委派与继承</strong></p>
<ul>
<li>继承：通过新操作扩展基类或覆盖操作。 </li>
<li>委托：捕获操作并将其发送给另一个对象。 </li>
<li>许多设计模式使用继承和委派的组合。 </li>
<li>Problem：如果子类只需要复用父类中的一小部分方法，</li>
<li>Solution：可以不需要使用继承，而是通过委派机制来实现。</li>
<li>本质上，一个类不需要继承另一个类的全部方法，通过委托机制调用部分方法。</li>
</ul>
<p><strong>复合继承原则（CRP）</strong></p>
<ul>
<li><p>复合复用原则(CRP)：类应当通过它们之间的组合（通过包含其它类的实例来实现期望的功能）达到多态表现和代码复用，而不仅仅是从基础类或父类继承。 </p>
</li>
<li><p>我们可以将组合（Composition）理解为（has a）而继承理解为(is a)；</p>
</li>
<li><p>委派可以看做Object层面的复用机制，而继承可以看做是类的层面；</p>
</li>
<li><p>只需针对不同子类的对象，委派能够计算该子类的奖金的方法的BonusCalculator。这样一来就不需要在子类继承的时候进行重写。</p>
</li>
<li><p><strong>总结</strong>：组合来代替继承的更普遍实现：</p>
<ul>
<li>用接口来实现系统的最基础行为</li>
<li>接口之间用extends来实现系统功能的扩展（接口组合）</li>
<li>类implements 组合接口</li>
</ul>
</li>
</ul>
<p><strong>委派的类型</strong></p>
<ul>
<li><p>临时性委派（Dependency）：最简单的方法，调用类里的方法（use a），其中一个类使用另一个类而不实际地将其作为属性。</p>
</li>
<li><p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616013924654-1586422474.png" alt="img"></p>
</li>
<li><p>永久性委派（Association）：类之中有其它类的具体实例来作为一个变量（has a）</p>
</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616013942858-522907537.png" alt="img"></p>
<ul>
<li>更强的委派，组合（Composition）：更强的委派。将一些简单的对象组合成一个更为复杂的对象。（is part of）!</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616014036320-1708798381.png">img</a></p>
<ul>
<li>聚合（Aggregation）:对象是在类的外部生成的，然后作为一个参数传入到类的内部构造器。(has a)</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616014114448-820873723.png" alt="img"></p>
<p><strong>组合与聚合</strong><br>　　在组合中，当拥有的对象被破坏时，被包含的对象也被破坏。在聚合中，这不一定是真的。以生活中的事物为例：大学拥有多个部门，每个部门都有一批教授。 如果大学关闭，部门将不复存在，但这些部门的教授将继续存在。 一位教授可以在一个以上的部门工作，但一个部门不能成为多个大学的一部分。大学与部门之间的关系即为组合，而部分与教授之间的关系为聚合。</p>
<h3 id="设计可复用库与框架"><a href="#设计可复用库与框架" class="headerlink" title="设计可复用库与框架"></a><em>设计可复用库与框架</em></h3><p>之所以library和framework被称为系统层面的复用，是因为它们不仅定义了1个可复用的接口&#x2F;类，而是将某个完整系统中的所有可复用的接口&#x2F;类都实现出来，并且定义了这些类之间的交互关系、调用关系，从而形成了系统整体 的“架构”。</p>
<ul>
<li>相应术语：<ul>
<li>API（Application Programming Interface）：库或框架的接口</li>
<li>Client（客户端）：使用API的代码</li>
<li>Plugin（插件）：客户端定制框架的代码</li>
<li>Extension Point：框架内预留的“空白”，开发者开发出符合接口要求的代码( 即plugin) ， 框架可调用，从而相当于开发者扩展了框架的功能</li>
<li>Protocol（协议）：API与客户端之间预期的交互序列。</li>
<li>Callback（反馈）：框架将调用的插件方法来访问定制的功能。</li>
<li>Lifecycle method：根据协议和插件的状态，按顺序调用的回调方法。</li>
</ul>
</li>
</ul>
<p><strong>API和库</strong></p>
<ul>
<li>建议：始终以开发API的标准面对任何开发任务；面向“复用”编程而不是面向“应用”编程。 </li>
<li>难度：要有足够良好的设计，一旦发布就无法再自由改变。 </li>
<li>编写一个API需要考虑以下方面：<ul>
<li>API应该做一件事，且做得很好</li>
<li>API应该尽可能小，但不能太小</li>
<li>Implementation不应该影响API</li>
<li>记录文档很重要</li>
<li>考虑性能后果</li>
<li>API必须与平台和平共存</li>
<li>类的设计：尽量减少可变性，遵循LSP原则</li>
<li>方法的设计：不要让客户做任何模块可以做的事情，及时报错</li>
</ul>
</li>
</ul>
<p><strong>框架</strong></p>
<ul>
<li><p>框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法；另一种定义认为，框架是可被应用开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。</p>
</li>
<li><p>为了增加代码的复用性，可以使用委派和继承机制。同时，在使用这两种机制增加代码复用的过程中，我们也相应地在不同的类之间增加了关系（委派或继承关系）。而对于一个项目而言，各个不同类之间的依赖关系就可以看做为一个框架。一个大规模的项目可能由许多不同的框架组合而成。</p>
</li>
<li><p>框架与设计模式：</p>
<ul>
<li>框架、设计模式这两个概念总容易被混淆，其实它们之间还是有区别的。构件通常是代码重用，而设计模式是设计重用，框架则介于两者之间，部分代码重用，部分设计重用，有时分析也可重用。在软件生产中有三种级别的重用：内部重用，即在同一应用中能公共使用的抽象块;代码重用，即将通用模块组合成库或工具集，以便在多个应用和领域都能使用；应用框架的重用，即为专用领域提供通用的或现成的基础结构，以获得最高级别的重用性。  </li>
<li>框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。</li>
</ul>
</li>
<li><p>框架分为白盒框架和黑盒框架。 </p>
<ul>
<li><p>白盒框架： </p>
<ul>
<li><p>白盒框架是基于面向对象的继承机制。之所以说是白盒框架，是因为在这种框架中，父类的方法对子类而言是可见的。子类可以通过继承或重写父类的方法来实现更具体的方法。</p>
</li>
<li><p>虽然层次结构比较清晰，但是这种方式也有其局限性，父类中的方法子类一定拥有，要么继承，要么重写，不可能存在子类中不存在的方法而在父类中存在。</p>
</li>
<li><p>通过子类化和重写方法进行扩展（使用继承）； </p>
</li>
<li><p>通用设计模式：模板方法； </p>
</li>
<li><p>子类具有主要方法但对框架进行控制。</p>
</li>
<li><p>允许扩展每一个非私有方法</p>
</li>
<li><p>需要理解父类的实现</p>
</li>
<li><p>一次只进行一次扩展</p>
</li>
<li><p>通常被认为是开发者框架</p>
</li>
<li><p><em><strong>examples</strong></em></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">PrintOnScreen</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(); </span><br><span class="line">        JOptionPane.showMessageDialog(frame, textToShow());</span><br><span class="line">        frame.dispose();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title function_">textToShow</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplication</span> <span class="keyword">extends</span> <span class="title class_">PrintOnScreen</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">protected</span> String <span class="title function_">textToShow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;printing this text on &quot;</span> + <span class="string">&quot;screen using PrintOnScreen &quot;</span> + <span class="string">&quot;white Box Framework&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>黑盒框架： </p>
<ul>
<li>黑盒框架时基于委派的组合方式，是不同对象之间的组合。之所以是黑盒，是因为不用去管对象中的方法是如何实现的，只需关心对象上拥有的方法。</li>
<li>这种方式较白盒框架更为灵活，因为可以在运行时动态地传入不同对象，实现不同对象间的动态组合；而继承机制在静态编译时就已经确定好。</li>
<li>通过实现插件接口进行扩展（使用组合&#x2F;委派）； </li>
<li>常用设计模式：Strategy, Observer ； </li>
<li>插件加载机制加载插件并对框架进行控制。</li>
<li>允许在接口中对public方法扩展</li>
<li>只需要理解接口</li>
<li>通常提供更多的模块</li>
<li>通常被认为是终端用户框架，平台</li>
<li>黑盒框架与白盒框架之间可以相互转换，具体例子可以看一下，软件构造课程中有关黑盒框架的例子，更改上面的白盒框架为黑盒框架：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TextToShow</span> &#123; </span><br><span class="line">    String <span class="title function_">text</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTextToShow</span> <span class="keyword">implements</span> <span class="title class_">TextToShow</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">text</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Printing&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">PrintOnScreen</span> &#123;</span><br><span class="line">    TextToShow textToShow;   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PrintOnScreen</span><span class="params">(TextToShow tx)</span> &#123; </span><br><span class="line">        <span class="built_in">this</span>.textToShow = tx; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(); </span><br><span class="line">        JOptionPane.showMessageDialog(frame, textToShow.text());</span><br><span class="line">        frame.dispose(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="第三节-可复用的设计模式"><a href="#第三节-可复用的设计模式" class="headerlink" title="第三节 可复用的设计模式"></a>第三节 可复用的设计模式</h2><h3 id="结构型模式：Structural-patterns"><a href="#结构型模式：Structural-patterns" class="headerlink" title="结构型模式：Structural patterns"></a><em>结构型模式：Structural patterns</em></h3><p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1361.html">适配器模式</a>（Adapter）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1366.html">装饰器模式</a>（Decorator）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1369.html">外观模式</a>（Facade Pattern）</strong></p>
<h3 id="行为类模式：Behavioral-patterns"><a href="#行为类模式：Behavioral-patterns" class="headerlink" title="行为类模式：Behavioral patterns"></a><em>行为类模式：Behavioral patterns</em></h3><p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1378.html">策略模式</a>（Strategy）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1376.html">模板模式</a>（Template method）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1395.html">迭代器模式</a>（Iterator）</strong></p>
<hr>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="第一节-可维护性的度量与构造原则"><a href="#第一节-可维护性的度量与构造原则" class="headerlink" title="第一节 可维护性的度量与构造原则"></a>第一节 可维护性的度量与构造原则</h2><h3 id="软件的维护和演化"><a href="#软件的维护和演化" class="headerlink" title="软件的维护和演化"></a><em>软件的维护和演化</em></h3><ul>
<li><strong>定义</strong>：软件可维护性是指软件产品被修改的能力，修改包括纠正、改进或软件对环境、需求和功能规格说明变化的适应。简而言之，软件维护：修复错误、改善性能。</li>
<li><strong>类型</strong>：纠错性（25%）、适应性（25%）、完善性（50%）、预防性（4%）</li>
<li><strong>演化</strong>：软件演化是一个程序不断调节以满足新的软件需求过程。</li>
<li><strong>演化的规律</strong>：软件质量下降，延续软件生命</li>
<li><strong>软件维护和演化的目标：</strong>提高软件的适应性，延续软件生命 。</li>
<li><strong>意义</strong>：软件维护不仅仅是运维工程师的工作，而是从设计和开发阶段就开始了 。在设计与开发阶段就要考虑将来的可维护性 ，设计方案需要“easy to change”</li>
<li>基于可维护性建设的例子：<ul>
<li>模块化</li>
<li>OO设计原则</li>
<li>OO设计模式</li>
<li>基于状态的构造技术</li>
<li>表驱动的构造技术</li>
<li>基于语法的构造技术</li>
</ul>
</li>
</ul>
<h3 id="可维护性的常见度量指标"><a href="#可维护性的常见度量指标" class="headerlink" title="可维护性的常见度量指标"></a><em>可维护性的常见度量指标</em></h3><ul>
<li>可维护性：可轻松修改软件系统或组件，以纠正故障，提高性能或其他属性，或适应变化的环境。</li>
<li>除此之外，可维护性还有其他许多别名：可扩展性（Extensibility）、灵活性（Flexibility）、可适应性（Adaptability）、可管理性（Manageability）、支持性（Supportability）。总之，有好的可维护性就意味着容易改变，容易扩展。</li>
<li>软件可维护性的五个子特性：<ul>
<li>易分析性。软件产品诊断软件中的缺陷或失效原因或识别待修改部分的能力。</li>
<li>易改变性。软件产品使指定的修改可以被实现的能力，实现包括编码、设计和文档的更改。如果软件由最终用户修改，那么易改变性可能会影响易操作性。</li>
<li>稳定性。软件产品避免由于软件修改而造成意外结果的能力。</li>
<li>易测试性。软件产品使已修改软件能被确认的能力。</li>
<li>维护性的依从性。软件产品遵循与维护性相关的标准或约定的能力。</li>
</ul>
</li>
<li>一些常用的可维护性度量标准：<ul>
<li>圈复杂度（CyclomaticComplexity）：度量代码的结构复杂度。</li>
<li>代码行数（Lines of Code）：指示代码中的大致行数。</li>
<li>Halstead Volume：基于源代码中（不同）运算符和操作数的数量的合成度量。</li>
<li>可维护性指数（MI）：计算介于0和100之间的索引值，表示维护代码的相对容易性。 高价值意味着更好的可维护性。</li>
<li>继承的层次数：表示扩展到类层次结构的根的类定义的数量。 等级越深，就越难理解特定方法和字段在何处被定义或重新定义。</li>
<li>类之间的耦合度：通过参数，局部变量，返回类型，方法调用，泛型或模板实例化，基类，接口实现，在外部类型上定义的字段和属性修饰来测量耦合到唯一类。</li>
<li>单元测试覆盖率：指示代码库的哪些部分被自动化单元测试覆盖。</li>
</ul>
</li>
</ul>
<h3 id="模块化设计规范：聚合度与耦合度"><a href="#模块化设计规范：聚合度与耦合度" class="headerlink" title="模块化设计规范：聚合度与耦合度"></a><em>模块化设计规范：聚合度与耦合度</em></h3><ul>
<li>模块化编程的含义：模块化编程是一种设计技术，它强调将程序的功能分解为独立的可互换模块，以便每个模块都包含执行所需功能的一个方面。</li>
<li>设计规范：高内聚低耦合</li>
<li>评估模块化的五个标准：<ul>
<li>可分解性：将问题分解为各个可独立解决的子问题</li>
<li>可组合性：可容易的将模块组合起来形成新的系统</li>
<li>可理解性：每个子模块都可被系统设计者容易的理解</li>
<li>可持续性：小的变化将只影响一小部分模块，而不会影响整个体系结构</li>
<li>出现异常之后的保护：运行时的不正常将局限于小范围模块内</li>
</ul>
</li>
<li>模块化设计的五条原则：<ul>
<li>直接映射：模块的结构与现实世界中问题领域的结构保持一致</li>
<li>尽可能少的接口：模块应尽可能少的与其他模块通讯</li>
<li>尽可能小的接口：如果两个模块通讯，那么它们应交换尽可能少的信息</li>
<li>显式接口：当A与B通讯时，应明显的发生在A与B的接口之间</li>
<li>信息隐藏：经常可能发生变化的设计决策应尽可能隐藏在抽象接口后面</li>
</ul>
</li>
</ul>
<p><strong>内聚性</strong></p>
<ul>
<li>又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高。</li>
<li>所谓高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则。</li>
</ul>
<p><strong>耦合性</strong></p>
<ul>
<li>也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂性、调用的方式及传递的信息。</li>
<li>对于低耦合，粗浅的理解是：一个完整的系统，模块与模块之间，尽可能的使其独立存在。也就是说，让每个模块，尽可能的独立完成某个特定的子功能。模块与模块之间的接口，尽量的少而简单。如果某两个模块间的关系比较复杂的话，最好首先考虑进一步的模块划分。这样有利于修改和组合。</li>
</ul>
<h3 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a><em>SOLID原则</em></h3><p>单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲（实现效果），它告诉我们要对扩展开放，对修改关闭。</p>
<table>
<thead>
<tr>
<th align="center"><strong>SRP</strong></th>
<th align="center"><a target="_blank" rel="noopener" href="http://www.objectmentor.com/resources/articles/srp.pdf">The Single Responsibility Principle</a></th>
<th align="center">单一责任原则</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>OCP</strong></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.objectmentor.com/resources/articles/ocp.pdf">The Open Closed Principle</a></td>
<td align="center">开放封闭原则</td>
</tr>
<tr>
<td align="center"><strong>LSP</strong></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.objectmentor.com/resources/articles/lsp.pdf">The Liskov Substitution Principle</a></td>
<td align="center">里氏替换原则</td>
</tr>
<tr>
<td align="center"><strong>ISP</strong></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.objectmentor.com/resources/articles/isp.pdf">The Interface Segregation Principle</a></td>
<td align="center">接口分离原则</td>
</tr>
<tr>
<td align="center"><strong>DIP</strong></td>
<td align="center"><a target="_blank" rel="noopener" href="http://www.objectmentor.com/resources/articles/dip.pdf">The Dependency Inversion Principle</a></td>
<td align="center">依赖倒置原则</td>
</tr>
</tbody></table>
<p><strong>SRP 单一责任原则</strong></p>
<ul>
<li>含义：需要修改某个类的时候原因有且只有一个。换句话说就是让一个类只做一种类型责任，当这个类需要承当其他类型的责任的时候，就需要分解这个类。</li>
<li>如果一个类包含了多个责任，那么将引起不良后果：引入额外的包，占据资源；导致频繁的重新配置、部署等。</li>
<li>SRP是最简单的原则，却是最难做好的原则。</li>
<li>SRP的一个反例：</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616152042182-554585047.png" alt="img"></p>
<p> <strong>OCP 开放封闭原则</strong></p>
<ul>
<li>软件实体应该是可扩展，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。这个原则是诸多面向对象编程原则中最抽象、最难理解的一个。<ul>
<li>模块的行为应是可扩展的，从而该模块可表现出新的行为以满足需求的变化。</li>
<li>模块自身的代码是不应被修改的</li>
<li>扩展模块行为的一般途径是修改模块的内部实现</li>
<li>如果一个模块不能被修改，那么它通常被认为是具有固定的行为。</li>
</ul>
</li>
<li>关键解决方案：抽象技术。 使用继承和组合来改变类的行为。</li>
<li>OCP的一个反例：</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616152951843-865388217.png" alt="img"></p>
<ul>
<li>OCP的一个例子：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open-Close Principle - Bad ***example***   </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;  </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;   </span><br><span class="line">   		<span class="keyword">if</span> (s.m_type==<span class="number">1</span>)   </span><br><span class="line">   			drawRectangle(s);   </span><br><span class="line">     	<span class="keyword">else</span> <span class="keyword">if</span> (s.m_type==<span class="number">2</span>)   </span><br><span class="line">         	drawCircle(s);   </span><br><span class="line">     &#125;   </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawCircle</span><span class="params">(Circle r)</span>   </span><br><span class="line">     	&#123;....&#125;   </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawRectangle</span><span class="params">(Rectangle r)</span>   </span><br><span class="line">        &#123;....&#125;   </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123; <span class="type">int</span> m_type; &#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123; Rectangle() &#123; <span class="built_in">super</span>.m_type=<span class="number">1</span>; &#125; &#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123; Circle() &#123; <span class="built_in">super</span>.m_type=<span class="number">2</span>; &#125; &#125; </span><br></pre></td></tr></table></figure>

<p>​    上面代码存在的问题：</p>
<ul>
<li>不可能在不修改GraphEditor的情况下添加新的Shape</li>
<li>GraphEditor和Shape之间的紧密耦合</li>
<li>不调用GraphEditor就很难测试特定的Shape</li>
</ul>
<p>​    改进之后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Open-Close Principle - Good ***example***  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicEditor</span> &#123;   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawShape</span><span class="params">(Shape s)</span> &#123;   </span><br><span class="line">    s.draw();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123; <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>; &#125;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">// draw the rectangle &#125; </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p> <strong>LSP 里氏替换原则</strong></p>
<ul>
<li>Liskov’s 替换原则意思是：”子类型必须能够替换它们的基类型。”或者换个说法：”使用基类引用的地方必须能使用继承类的对象而不必知道它。” 这个原则正是保证继承能够被正确使用的前提。通常我们都说，“优先使用组合（委托）而不是继承”或者说“只有在确定是 is-a 的关系时才能使用继承”，因为继承经常导致”紧耦合“的设计。</li>
</ul>
<p> <strong>ISP 接口分离原则</strong></p>
<ul>
<li>含义：客户端不应依赖于它们不需要的方法。换句话说，使用多个专门的接口比使用单一的总接口总要好。</li>
<li>客户模块不应该依赖大的接口，应该裁减为小的接口给客户模块使用，以减少依赖性。如Java中一个类实现多个接口，不同的接口给不用的客户模块使用，而不是提供给客户模块一个大的接口。</li>
<li>“胖”接口具有很多缺点。<ul>
<li>胖接口可分解为多个小的接口；</li>
<li>不同的接口向不同的客户端提供服务；</li>
<li>客户端只访问自己所需要的端口。</li>
</ul>
</li>
<li>下图展示出了这种思想：</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616154856198-1879077574.png" alt="img"></p>
<ul>
<li>ISP的一个反例</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616154935237-744032046.png" alt="img"></p>
<p><strong>DIP 依赖转置原则</strong></p>
<ul>
<li>定义：<ul>
<li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象 </li>
<li>抽象不应该依赖于细节，细节应该依赖于抽象</li>
</ul>
</li>
<li>这个设计原则的亮点在于任何被DI框架注入的类很容易用mock对象进行测试和维护，因为对象创建代码集中在框架中，客户端代码也不混乱。有很多方式可以实现依赖倒置，比如像AspectJ等的AOP（Aspect Oriented programming）框架使用的字节码技术，或Spring框架使用的代理等。<ul>
<li>高层模块不要依赖低层模块；</li>
<li>高层和低层模块都要依赖于抽象；</li>
<li>抽象不要依赖于具体实现； </li>
<li>具体实现要依赖于抽象；</li>
<li>抽象和接口使模块之间的依赖分离。</li>
</ul>
</li>
<li>一个具体的例子：</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616155346632-1952811759.png" alt="img"></p>
<p>进行抽象改进后：</p>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616155435214-568838317.png" alt="img"></p>
<p><strong>SOLID 总结</strong></p>
<ol>
<li>一个对象只承担一种责任，所有服务接口只通过它来执行这种任务。</li>
<li>程序实体，比如类和对象，向扩展行为开放，向修改行为关闭。</li>
<li>子类应该可以用来替代它所继承的类。</li>
<li>一个类对另一个类的依赖应该限制在最小化的接口上。</li>
<li>依赖抽象层(接口)，而不是具体类。</li>
</ol>
<h2 id="第二节-可维护的设计模式"><a href="#第二节-可维护的设计模式" class="headerlink" title="第二节 可维护的设计模式"></a>第二节 可维护的设计模式</h2><h3 id="创造性模式：Creational-patterns"><a href="#创造性模式：Creational-patterns" class="headerlink" title="创造性模式：Creational patterns"></a><em>创造性模式：Creational patterns</em></h3><p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1348.html">工厂模式</a>（Factory Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1351.html">抽象工厂模式</a>（Abstract Factory Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1354.html">建造者模式</a>（Builder Pattern）</strong></p>
<h3 id="结构化模式：Structural-patterns"><a href="#结构化模式：Structural-patterns" class="headerlink" title="结构化模式：Structural patterns"></a><em>结构化模式：Structural patterns</em></h3><p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1364.html">桥接模式</a>（Bridge Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1359.html">代理模式</a>（Proxy Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1373.html">组合模式</a>（Composite Pattern）</strong></p>
<h3 id="行为化模式：Behavioral-patterns"><a href="#行为化模式：Behavioral-patterns" class="headerlink" title="行为化模式：Behavioral patterns"></a><em>行为化模式：Behavioral patterns</em></h3><p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1393.html">中介者模式</a>（Mediator Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1390.html">观察者模式</a>（Observer Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1397.html">访问者模式</a>（Visitor Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1383.html">责任链模式</a>（Chain of Responsibility Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1380.html">命令模式</a>（Command Pattern）</strong></p>
<h2 id="第三节-面向可维护的构造技术"><a href="#第三节-面向可维护的构造技术" class="headerlink" title="第三节 面向可维护的构造技术"></a>第三节 面向可维护的构造技术</h2><h2 id="基于状态的构造技术"><a href="#基于状态的构造技术" class="headerlink" title="基于状态的构造技术"></a>基于状态的构造技术</h2><p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1388.html">状态模式</a>（State Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1400.html">备忘录模式</a>（Memento Pattern）</strong></p>
<h3 id="基于语法的构造技术"><a href="#基于语法的构造技术" class="headerlink" title="基于语法的构造技术"></a><em>基于语法的构造技术</em></h3><p><strong>运用场景</strong></p>
<ul>
<li>有一类应用，从外部读取文本数据， 在应用中做进一步处理。 具体来说，读取的一个字节或字符序列可能是：</li>
<li>输入文件有特定格式，程序需读取文件并从中抽取正确的内容。</li>
<li>从网络上传输过来的消息，遵循特定的协议。</li>
<li>用户在命令行输入的指令，遵顼特定的格式。</li>
<li>内存中存储的字符串，也有格式需要。</li>
</ul>
<p>对于这些类型的序列，语法的概念是设计的一个好选择：</p>
<ul>
<li>使用grammar判断字符串是否合法，并解析成程序里使用的数据结构 。</li>
<li>正则表达式</li>
<li>通常是递归的数据结构 。</li>
</ul>
<p><strong>语法成分</strong></p>
<p>terminals 终止节点、叶节点</p>
<p>nonterminal 非终止节点（遵循特定规则，利用操作符、终止节点和其他非终止节点，构造新的字符串）</p>
<h3 id="语法中的操作符"><a href="#语法中的操作符" class="headerlink" title="语法中的操作符"></a><em>语法中的操作符</em></h3><ul>
<li>三个基本语法的操作符：<ul>
<li>连接，不是通过一个符号，而是一个空间：<ul>
<li><code>x ::= y z //x等价于y后跟一个z</code></li>
</ul>
</li>
<li>重复，以*表示：　　                                 <ul>
<li><code>x ::= y* // x等价于0个或更多个y</code></li>
</ul>
</li>
<li>联合，也称为交替，如图所示 | ：　　       <ul>
<li><code>x ::= y | z //x等价于一个y或者一个z</code></li>
</ul>
</li>
</ul>
</li>
<li>三个基本操作符的组合：<ul>
<li>可选（0或1次出现），由<code>?</code>表示：<ul>
<li><code>x ::= y? //x等价于一个y或者一个空串</code></li>
</ul>
</li>
<li>出现1次或多次：以<code>+</code>表示：          <ul>
<li><code>x ::= y+ //x等价于一个或者更多个y， 等价于 x ::= y y*</code></li>
</ul>
</li>
<li>字符类<code>[…]</code>，表示长度的字符类，包含方括号中列出的任何字符的1个字符串：<ul>
<li><code>x ::= [abc] //等价于 x ::= &#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code></li>
</ul>
</li>
<li>否定的字符类<code>[^…]</code>，表示长度，包含未在括号中列出的任何字符的1个字符串：<ul>
<li><code>x ::= [^abc] //等价于 x ::= &#39;d&#39; | &#39;e&#39; | &#39;f&#39; | ... (all other characters in Unicode)</code></li>
</ul>
</li>
</ul>
</li>
<li>例子：<ul>
<li><code>x ::= (y z | a b)* //an x is zero or more y z or a b pairs</code></li>
<li><code>m ::= a (b|c) d //an m is a, followed by either b or c, followed by d</code></li>
</ul>
</li>
</ul>
<p><strong>Markdown 和 HTML的语法</strong></p>
<p> <img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616210554679-1772816897.png" alt="img"></p>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180616210511151-582940878.png" alt="img"></p>
<h3 id="正则语法与正则表达式"><a href="#正则语法与正则表达式" class="headerlink" title="正则语法与正则表达式"></a><em>正则语法与正则表达式</em></h3><ul>
<li>正则语法：简化之后可以表达为一个产生式而不包含任何非终止节点。 </li>
<li>正则语法示例：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Rugular!</span><br><span class="line">url ::= &#x27;http://&#x27; ([a-z]+ &#x27;.&#x27;)+ [a-z]+ (&#x27;:&#x27; [0-9]+)? &#x27;/&#x27;</span><br><span class="line"></span><br><span class="line">//Regular!</span><br><span class="line">markdown ::= ([^_]* | &#x27;_&#x27; [^_]* &#x27;_&#x27; )* </span><br><span class="line"></span><br><span class="line">//Not Regular!</span><br><span class="line">html ::= ( [^&lt;&gt;]* | &#x27;&lt;i&gt;&#x27; html &#x27;&lt;i&gt;&#x27; )*</span><br></pre></td></tr></table></figure>

<ul>
<li>在Java中使用正则表达式<ul>
<li>适用场合：我们用正则表达式匹配字符串（例如 String.split , String.matches , java.util.regex.Pattern）</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%882/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%882/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-06-24 11:35:52" itemprop="dateModified" datetime="2019-06-24T11:35:52+08:00">2019-06-24</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h2 id="title-软件构造知识点总结（2-date-（总结日期）2019-05-20"><a href="#title-软件构造知识点总结（2-date-（总结日期）2019-05-20" class="headerlink" title="title: 软件构造知识点总结（2)date: （总结日期）2019-05-20 "></a>title: 软件构造知识点总结（2)<br>date: （总结日期）2019-05-20 </h2><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><hr>
<h2 id="第一节-数据类型与类型检查"><a href="#第一节-数据类型与类型检查" class="headerlink" title="第一节 数据类型与类型检查"></a>第一节 数据类型与类型检查</h2><h3 id="数据类型及其表达"><a href="#数据类型及其表达" class="headerlink" title="数据类型及其表达"></a>数据类型及其表达</h3><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><em>基本数据类型</em></h3><p><strong>对象数据结构</strong></p>
<ul>
<li>对象：对象是类的一个实例，有状态和行为</li>
<li>类：类是一个模板，它描述一类对象的行为和状态</li>
<li>Java作为一种面向对象语言，支持多态、继承、封装、抽象、重载等概念</li>
</ul>
<p><strong>包装类</strong></p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a><em>类型检查</em></h3><p><strong>动态检查：关于“值”的检查</strong></p>
<ul>
<li>bug在运行中被发现</li>
<li>倾向于检查特定值才出发的错误</li>
<li>动态分析检查的类型：<ul>
<li>非法的变量值。例如整型变量x、y，表达式x&#x2F;y 只有在运行后y为0才会报错，否则就是正确的。</li>
<li>非法的返回值。例如最后得到的返回值无法用声明的类型来表明。</li>
<li>越界访问。例如在一个字符串中使用一个负数索引。</li>
<li>空指针，使用一个null 对象解引用。</li>
</ul>
</li>
</ul>
<p><strong>静态检查：关于“类型”的检查</strong></p>
<ul>
<li>静态检查&gt;&gt;动态检查&gt;&gt;无检查</li>
<li>在编译阶段发现错误，避免将错误带入到运行阶段，提高程序的正确性\健壮性</li>
<li>静态分析检查的类型<ul>
<li>语法错误，例如多余的标点符号或者错误的关键词。即使在动态类型的语言例如Python中也会做这种检查：如果你有一个多余的缩进，在运行之前就能发现它</li>
<li>类名\函数名错误，例如<code>Math.sine(2)</code> . (应该是 sin )</li>
<li>参数数目错误，例如<code>Math.sin(30, 20)</code> </li>
<li>参数的型错误<code>Math.sin(&quot;30&quot;)</code> </li>
<li>返回值类型错误 ，例如⼀个声明返回<code>int</code>类型函数<code>return 30</code></li>
</ul>
</li>
</ul>
<h3 id="可变性和不可变性"><a href="#可变性和不可变性" class="headerlink" title="可变性和不可变性"></a><em>可变性和不可变性</em></h3><ul>
<li>改变一个变量：是将该变量指向另一个值得存储空间</li>
<li>改变一个变量的值：是将该变量当前指向的值的存储空间中写入一个新的值</li>
</ul>
<p><strong>不变性（immutability）</strong></p>
<ul>
<li><code>final</code>变量能被显式地初始化并且只能初始化一次。不变数据类型，一旦被创建，值不可修改</li>
<li>基本类型及其封装对象类型都是不可变的</li>
<li>不可变的引用是指一旦指定引用位置后，不可再次指定</li>
<li>如果编译器不能确定<code>final</code>变量不会改变，就提示错误，这也是静态类型检查的一部分</li>
<li>注意：<ul>
<li>final类无法派生子类</li>
<li>final变量无法改变值&#x2F;引用</li>
<li>final方法无法被子类重写</li>
</ul>
</li>
</ul>
<p><strong>可变性（mutability）</strong></p>
<ul>
<li><p>不变对象：一旦被创建，始终指向同个值&#x2F;引用 </p>
</li>
<li><p>可变对象：拥有方法以修改自己的值&#x2F;引用</p>
</li>
<li><p><code>String</code>与<code>StringBuilder</code></p>
<ul>
<li><p><code>String</code>：不可变数据类型，在修改时必须创建一个新的<code>String</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">a = s + <span class="string">&quot;b&quot;</span>;<span class="comment">//s = s.concat(&quot;b&quot;);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>StringBuilder</code>：可改变的数据类型，可以直接修改对象的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>可变性与不可变性的优缺点</strong></p>
<ul>
<li>可变数据类型最小化的拷贝以提高效率；使用不可变类型，对其频繁修改会产生大量的临时拷贝 （需要垃圾回收）</li>
<li>可变数据类型，可获得更好的效能</li>
<li>可变数据类型也适合在多个模块之间共享数据</li>
<li>不可变数据类型更安全，更易于理解，也更方便改变</li>
</ul>
<p><strong>防御性拷贝</strong></p>
<ul>
<li><p>如果一个方法或构造函数允许可变对象进&#x2F;出，那么就要考虑一下使用者是否有可能改变它。如果是的话，那你必须对该对象进行保护性拷贝，使进入方法内部的对象是外部时的拷贝而不它本身（因为外部的对象有可能还会被改变）。</p>
</li>
<li><pre><code class="java">public Date getEnd() &#123;  
     return new Date(end.getTime());  
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 第二节 设计规约</span><br><span class="line"></span><br><span class="line">### *什么是设计规约*</span><br><span class="line"></span><br><span class="line">-   为什么要有设计规约</span><br><span class="line">    -   很多bug来自于双方之间的误解；没有规约，那么不同开发者的理解就可能不同</span><br><span class="line">    -   代码惯例增加了软件包的可读性，使工程师们更快、更完整的理解软件</span><br><span class="line">    -   可以帮助程序员养成良好的编程习惯，提高代码质量</span><br><span class="line">    -   没有规约，难以定位错误</span><br><span class="line">-   使用设计规约的好处</span><br><span class="line">    -   规约起到了契约的作用。代表着程序与客户端之间达成的一致；客户端无需阅读调用函数的代码，只需理解spec即可</span><br><span class="line">    -   精确的规约，有助于区分责任，给“供需双方”确定了责任，在调用的时候双方都要遵守</span><br><span class="line">    -   规约可以隔离“变化”，无需通知客户端</span><br><span class="line">    -   规约也可以提高代码效率</span><br><span class="line"></span><br><span class="line">### 行为等价性</span><br><span class="line"></span><br><span class="line">行为等价性就是站在客户端的角度考量两个方法是否可以互换。</span><br><span class="line"></span><br><span class="line">-   另外，我们也可以根据规约判断是否行为等价注：规约与实现无关，规范无需讨论方法类的局部变量或方法类的私有字段。</span><br><span class="line"></span><br><span class="line">-   两个函数附和同一个规约，故二者等价</span><br><span class="line"></span><br><span class="line">### *规约的结构：前置条件与后置条件*</span><br><span class="line"></span><br><span class="line">**规约的结构**</span><br><span class="line"></span><br><span class="line">-    一个方法的规约常由以下几个短句组成契约：如果前置条件满足了，后置条件必须满足。如果没有满足，将产生不确定的异常行为</span><br><span class="line">    -   前置条件(precondition)：对客户端的约束，在使用方法时必须满足的条件。由关键字 **requires**表示；</span><br><span class="line">    -   后置条件(postcondition)：对开发者的约束，方法结束时必须满足的条件。由关键字 **effects**表示</span><br><span class="line">    -   异常行为(Exceptional behavior)：如果前置条件被违背，会发生什么</span><br><span class="line"></span><br><span class="line">-   静态类型声明是一种规约，可据此进行静态类型检查。 </span><br><span class="line">-   方法前的注释也是一种规约，但需人工判定其是否满足。</span><br><span class="line">    -   参数由@param 描述</span><br><span class="line">    -   子句和结果用 @return 和 @ throws子句 描述</span><br><span class="line">    -   尽可能的将前置条件放在 @param 中</span><br><span class="line">    -   尽可能的将后置条件放在 @return 和 @throws 中</span><br><span class="line"></span><br><span class="line">**mutating methods（可变方法）的规约**</span><br><span class="line"></span><br><span class="line">-   除非在后置条件里声明过，否则方法内部不应该改变输入参数</span><br><span class="line">-   应尽量遵循此规则，尽量不设计mutating的spec，否则就容易引发bugs </span><br><span class="line">-   程序员之间应达成的默契：除非spec必须如此，否则不应修改输入参数</span><br><span class="line">-   尽量避免使用可变(mutable)的对象</span><br><span class="line">    -   对可变对象的多引用，需要程序维护一致性，此时合同不再是单纯的在用户和实现者之间维持，需要每一个引用者都有良好的习惯，这就使得简单的程序变得复杂</span><br><span class="line">    -   可变对象使得程序难以理解，也难以保证正确性</span><br><span class="line">    -   可变数据类型还会导致程序修改变得异常困难 </span><br><span class="line"></span><br><span class="line">### *规约的评价*</span><br><span class="line"></span><br><span class="line">**规约评价的三个标准**</span><br><span class="line"></span><br><span class="line">-   规约的确定性</span><br><span class="line">-   规约的陈述性</span><br><span class="line">-   规约的强度</span><br><span class="line"></span><br><span class="line">**规约的确定性**</span><br><span class="line"></span><br><span class="line">　　确定的规约：给定一个满足前置条件的输入，其输出是唯一的、明确的。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static int findExactlyOne(int[] arr, int val)</span><br><span class="line">    \\ requires: val occurs exactly once in arr</span><br><span class="line">    \\ effects:  returns index i such that arr[i] = val</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>　　欠定的规约：同一个输入可以有多个输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findOneOrMoreAnyIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> val)</span></span><br><span class="line">    \\ <span class="keyword">requires</span>: val occurs in arr</span><br><span class="line">    \\ effects:  returns index i such that arr[i] = val</span><br></pre></td></tr></table></figure>

<p>　　未确定的规约：同一个输入，多次执行时得到的输出可能不同；但为了避免分歧，我们通常将不是确定的spec统一定义为欠定的规约。</p>
<p><strong>规约的陈述性</strong></p>
<ul>
<li>操作式规约（Operational specs）：伪代码 。 </li>
<li>声明式规约（Declarative specs）：没有内部实现的描述，只有 “初&#x2F;终”状态 。 </li>
<li>声明式规约更有价值；内部实现的细节不在规约里呈现，而放在代码实现体内部注释里呈现。</li>
</ul>
<p><strong>规约的强度</strong></p>
<ul>
<li>通过比较规约的强度来判断是否可以用一个规约替换另一个；</li>
<li>如果规约的强度$S2 \ge S1$，就可以用$S2$代替$S1$，体现有二：一个更强的规约包括更轻松的前置条件和更严格的后置条件；越强的规约，意味着实现者(implementor)的自由度和责任越重，而客户(client)的责任越轻。<ul>
<li>$S2$的前置条件更弱</li>
<li>$S2$的后置条件更强</li>
</ul>
</li>
</ul>
<p><em><strong>examples</strong></em></p>
<ul>
<li>Original spec：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findExactlyOne</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> val)</span></span><br><span class="line"><span class="number">2</span>   \\ <span class="keyword">requires</span>: val occurs exactly once in a</span><br><span class="line"><span class="number">3</span>   \\ effects:  returns index i such that a[i] = val</span><br></pre></td></tr></table></figure>

<ul>
<li>A stronger spec:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findOneOrMoreAnyIndex</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> val)</span></span><br><span class="line"><span class="number">2</span>   \\ <span class="keyword">requires</span>: val occurs at least once in a</span><br><span class="line"><span class="number">3</span>   \\ effects:  returns index i such that a[i] = val</span><br></pre></td></tr></table></figure>

<ul>
<li>A much stronger spec:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findOneOrMoreFirstIndex</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> val)</span></span><br><span class="line"><span class="number">2</span>   \\ <span class="keyword">requires</span>: val occurs at least once in a</span><br><span class="line"><span class="number">3</span>   \\ effects:  returns lowest index i such that a[i] = val</span><br></pre></td></tr></table></figure>

<p><strong>如何设计一个好的规约</strong></p>
<ul>
<li>规约应该是简洁的：整洁，具有良好的结构，易于理解。</li>
<li>规约应该是内聚的：spec描述的功能应单一、简单、易理解。</li>
<li>规约应该是信息丰富的：不能让客户端产生理解的歧义。</li>
<li>规约应该是强度足够的：需要满足客户端基本需求，也必须考虑特殊情况。</li>
<li>规约的强度也不能太强：太强的spec，在很多特殊情况下难以达到。</li>
<li>规约应该使用抽象类型：在规约里使用抽象类型，可以给方法的实现体与客户端更大的自由度。</li>
</ul>
<p><strong>是否使用前置条件</strong></p>
<ul>
<li>是否使用前置条件取决于如果只在类的内部使用该方法(<code>private</code>)，那么可以不使用前置条件，在使用该方法的各个位置进行check——责任交给内部client。<ul>
<li>check的代价</li>
<li>方法的使用范围</li>
</ul>
</li>
<li>如果在其他地方使用该方法(<code>public</code>)，那么必须要使用前置条件，若client端不满足则方法抛出异常。</li>
</ul>
<h2 id="第三节-抽象数据型（ADT）"><a href="#第三节-抽象数据型（ADT）" class="headerlink" title="第三节 抽象数据型（ADT）"></a>第三节 抽象数据型（ADT）</h2><h3 id="ADT及其四种类型"><a href="#ADT及其四种类型" class="headerlink" title="ADT及其四种类型"></a><em>ADT及其四种类型</em></h3><p><strong>ADT的基本概念</strong></p>
<ul>
<li>抽象数据类型（Abstract Data Type，ADT）是是指一个数学模型以及定义在该模型上的一组操作；即包括数据数据元素，数据关系以及相关的操作。</li>
<li>ADT具有以下几个能表达抽象思想的词：<ul>
<li>抽象化：用更简单、更高级的思想省略或隐藏低级细节。</li>
<li>模块化： 将系统划分为组件或模块，每个组件可以设计，实施，测试，推理和重用，与系统其余部分分开使用。</li>
<li>封装：围绕模块构建墙，以便模块负责自身的内部行为，并且系统其他部分的错误不会损坏其完整性。</li>
<li>信息隐藏： 从系统其余部分隐藏模块实现的细节，以便稍后可以更改这些细节，而无需更改系统的其他部分。</li>
<li>关注点分离： 一个功能只是单个模块的责任，而不跨越多个模块。</li>
</ul>
</li>
<li>与传统类型定义的差别：<ul>
<li>传统的类型定义：关注数据的具体表示。</li>
<li>抽象类型：强调“作用于数据上的操作”，程序员和client无需关心数据如何具体存储的，只需设计&#x2F;使用操作即可。</li>
</ul>
</li>
<li>ADT是由操作定义的，与其内部如何实现无关。</li>
</ul>
<p><strong>ADT的四种类型</strong></p>
<p>前置定义：mutable and immutable types</p>
<p>可变类型的对象：提供了可改变其内部数据的值的操作。例如：<code>Date</code></p>
<p>不变数据类型： 其操作不改变内部值，而是构造新的对象。例如：<code>String</code></p>
<ul>
<li>Creators（构造器）：<ul>
<li>创建某个类型的新对象，⼀个创建者可能会接受⼀个对象作为参数，但是这个对象的类型不能是它创建对象对应的类型。可能实现为构造函数或静态函数。（通常称为工厂方法）</li>
<li>$t^* \to T$</li>
<li><em><strong>example</strong></em>：<code>Integer.valueOf()</code></li>
</ul>
</li>
<li>Producers（生产器）：<ul>
<li>通过接受同类型的对象创建新的对象。</li>
<li>$T^+,t^* \to T$</li>
<li><em><strong>example</strong></em>：<code>String.concat()</code></li>
</ul>
</li>
<li>Observers（观察器）：<ul>
<li>获取抽象类型的对象然后返回一个不同类型的对象&#x2F;值。</li>
<li>$T^+ , t^* \to t$</li>
<li><em><strong>example</strong></em>：<code>List.size()</code></li>
</ul>
</li>
<li>Mutators（变值器）：<ul>
<li>改变对象属性的方法 ，</li>
<li>变值器通常返回void，若为void，则必然意味着它改变了对象的某些内部状态；当然，也可能返回非空类型 </li>
<li>$T^+ , t^* \to t||T|| void$</li>
<li><em><strong>example</strong></em>：<code>List.add()</code></li>
</ul>
</li>
<li>解释：$T$是ADT本身；$t$是其他类型；$^+$表示这个类型可能出现一次或多次；$^*$表示可能出现0次或多次。</li>
</ul>
<p><strong>设计一个好的ADT</strong></p>
<p>设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约 spec。</p>
<ul>
<li>原则 1：设计简洁、一致的操作。<ul>
<li>最好有一些简单的操作，它们可以以强大的方式组合，而不是很多复杂的操作。</li>
<li>每个操作应该有明确的目的，并且应该有一致的行为而不是一连串的特殊情况。</li>
</ul>
</li>
<li>原则 2：要足以支持用户对数据所做的所有操作需要，且用操作满足用户需要的难度要低。<ul>
<li>提供<code>get()</code>操作以获得<code>list</code>内部数据</li>
<li>提供<code>size()</code>操作获取<code>list</code>的长度</li>
</ul>
</li>
<li>原则 3：要么抽象、要么具体，不要混合 —— 要么针对抽象设计，要么针对具体应用的设计。</li>
</ul>
<p><strong>测试ADT</strong></p>
<ul>
<li>测试creators, producers, and mutators：调用observers来观察这些 operations的结果是否满足spec。</li>
<li>测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。</li>
</ul>
<h3 id="表示独立性"><a href="#表示独立性" class="headerlink" title="表示独立性"></a><em>表示独立性</em></h3><ul>
<li>表示独立性：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。</li>
<li>除非ADT的操作指明了具体的前置条件&#x2F;后置条件，否则不能改变ADT的内部表示——spec规定了 client和implementer之间的契约。</li>
</ul>
<h3 id="不变量（Invariants）与表示泄露"><a href="#不变量（Invariants）与表示泄露" class="headerlink" title="不变量（Invariants）与表示泄露"></a><em>不变量（Invariants）与表示泄露</em></h3><p>一个好的抽象数据类型的最重要的属性是它保持不变量。一旦一个不变类型的对象被创建，它总是代表一个不变的值。当一个ADT能够确保它内部的不变量恒定不变（不受使用者&#x2F;外部影响），我们就说这个ADT保护&#x2F;保留自己的不变量。</p>
<h3 id="抽象函数AF与表示不变量RI"><a href="#抽象函数AF与表示不变量RI" class="headerlink" title="抽象函数AF与表示不变量RI"></a><em>抽象函数AF与表示不变量RI</em></h3><p><strong>AF与RI</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604205243278-1512350415.png" alt="img"></p>
<ul>
<li><p>在研究抽象类型的时候，先思考一下两个值域之间的关系：</p>
<ul>
<li>表示域（rep values）里面<strong>包含的是值具体的实现实体</strong>。一般情况下ADT的表示比较简单，有些时候需要复杂表示。 </li>
<li>抽象域（A）里面包含的则是类型设计时支持使用的值。<strong>这些值是由表示域“抽象&#x2F;想象”出来的，也是使用者关注的。</strong></li>
</ul>
</li>
<li><p>ADT实现者关注表示空间R，用户关注抽象空间A 。</p>
</li>
<li><p>$R \to A$的映射特点：</p>
<ul>
<li><strong>每一个抽象值都是由表示值映射而来</strong> ，即满射：每个抽象值被映射到一些rep值</li>
<li><strong>一些抽象值是被多个表示值映射而来的</strong>，即未必单射：一些抽象值被映射到多个rep值</li>
<li><strong>不是所有的表示值都能映射到抽象域中</strong>，即未必双射：并非所有的rep值都被映射。</li>
</ul>
</li>
<li><p>抽象函数（AF）：R和A之间映射关系的函数</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AF : R → A</span><br></pre></td></tr></table></figure>

<ul>
<li>表示不变量（RI）：将rep值映射到布尔值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RI : R → boolean</span><br></pre></td></tr></table></figure>

<ul>
<li>对于表示值r，当且仅当$r$被$AF$映射到了A，$RI(r)$为真</li>
<li>表示不变性RI：某个具体的“表示”是否是“合法的”</li>
<li>也可将RI看作：所有表示值的一个子集，包含了所有合法的表示值</li>
<li>也可将RI看作：一个条件，描述了什么是“合法”的表示值</li>
<li>在下图中，绿色表示的就是$RI(r)$为真的部分，$AF$只在这个子集上有定义。</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604210551887-1733274652.png" alt="img"></p>
<ul>
<li>表示不变量和抽象函数都应该记录在代码中，就在代表本身的声明旁边，以下图为例</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604212242139-1846422204.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="comment">// Rep invariant:</span></span><br><span class="line">    <span class="comment">//   s contains no repeated characters</span></span><br><span class="line">    <span class="comment">// Abstraction function:</span></span><br><span class="line">    <span class="comment">//   AF(s) = &#123;s[i] | 0 &lt;= i &lt; s.length()&#125;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604212302571-1426216850.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="comment">// Rep invariant:</span></span><br><span class="line">    <span class="comment">//   s[0] &lt;= s[1] &lt;= ... &lt;= s[s.length()-1]</span></span><br><span class="line">    <span class="comment">// Abstraction function:</span></span><br><span class="line">    <span class="comment">//   AF(s) = &#123;s[i] | 0 &lt;= i &lt; s.length()&#125;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604212327839-789247230.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="comment">// Rep invariant:</span></span><br><span class="line">    <span class="comment">//   s.length() is even</span></span><br><span class="line">    <span class="comment">//   s[0] &lt;= s[1] &lt;= ... &lt;= s[s.length()-1]</span></span><br><span class="line">    <span class="comment">// Abstraction function:</span></span><br><span class="line">    <span class="comment">//   AF(s) = union of &#123;s[2i],...,s[2i+1]&#125; for 0 &lt;= i &lt; s.length()/2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用注释写AF和RI</strong></p>
<ul>
<li>在抽象类型（私有的）表示声明后写上对于抽象函数和表示不变量的注解，这是一个好的实践要求。我们在上面的例子中也是这么做的。</li>
<li>在描述抽象函数和表示不变量的时候，注意要清晰明确：<ul>
<li>对于RI（表示不变量），仅仅宽泛的说什么区域是合法的并不够，你还应该说明是什么使得它合法&#x2F;不合法。</li>
<li>对于AF（抽象函数）来说，仅仅宽泛的说抽象域表示了什么并不够。抽象函数的作用是规定合法的表示值会如何被解释到抽象域。作为一个函数，我们应该清晰的知道从一个输入到一个输入是怎么对应的。</li>
</ul>
</li>
<li>本门课程还要求你将<strong>表示暴露的安全性</strong>注释出来。这种注释应该说明表示的每一部分，它们为什么不会发生表示暴露，特别是处理的表示的参数输入和返回部分（这也是表示暴露发生的位置）。</li>
<li>下面是一个<code>Tweet</code>类的例子，它将表示不变量和抽象函数以及表示暴露的安全性注释了出来：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Immutable type representing a tweet.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String text;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rep invariant:</span></span><br><span class="line">    <span class="comment">//   author is a Twitter username (a nonempty string of letters, digits, underscores)</span></span><br><span class="line">    <span class="comment">//   text.length &lt;= 140</span></span><br><span class="line">    <span class="comment">// Abstraction function:</span></span><br><span class="line">    <span class="comment">//   AF(author, text, timestamp) = a tweet posted by author, with content text, </span></span><br><span class="line">    <span class="comment">//                                 at time timestamp </span></span><br><span class="line">    <span class="comment">// Safety from rep exposure:</span></span><br><span class="line">    <span class="comment">//   All fields are private;</span></span><br><span class="line">    <span class="comment">//   author and text are Strings, so are guaranteed immutable;</span></span><br><span class="line">    <span class="comment">//   timestamp is a mutable Date, so Tweet() constructor and getTimestamp() </span></span><br><span class="line">    <span class="comment">//        make defensive copies to avoid sharing the rep&#x27;s Date object with clients.</span></span><br><span class="line">    <span class="comment">// Operations (specs and method bodies omitted to save space)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getTimestamp</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四节-面向对象编程OOP"><a href="#第四节-面向对象编程OOP" class="headerlink" title="第四节 面向对象编程OOP"></a>第四节 面向对象编程OOP</h2><h3 id="OOP的基本概念"><a href="#OOP的基本概念" class="headerlink" title="OOP的基本概念"></a><em>OOP的基本概念</em></h3><p><strong>对象</strong></p>
<ul>
<li>对象是类的一个实例，有状态和行为。</li>
<li>例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li>概念：一个对象是一堆状态和行为的集合。<ul>
<li>状态是包含在对象中的数据，在Java中，它们是对象的fields。</li>
<li>行为是对象支持的操作，在Java中，它们称为methods。</li>
</ul>
</li>
</ul>
<p><strong>类</strong></p>
<ul>
<li>类是一个模板，它描述一类对象的行为和状态。</li>
<li>每个对象都有一个类</li>
<li>类定义了属性类型（type）和行为实现（implementation）</li>
<li>简单地说，类的方法是它的应用程序编程接口（API）。</li>
<li>类成员变量（class variable）又叫静态变量；类方法（class method）又叫静态方法：</li>
<li>实例变量（instance variable）和实例方法（instance method）是不用<code>static</code>形容的实例和方法；</li>
<li>二者有以下的区别：<ul>
<li>类方法是属于整个类，而不属于某个对象。 </li>
<li>类方法只能访问类成员变量（方法），不能访问实例变量（方法），而实例方法可以访问类成员变量（方法）和实例变量（方法）。 </li>
<li>类方法的调用可以通过类名.类方法和对象.类方法，而实例方法只能通过对象.实例方法访问。 </li>
<li>类方法不能被覆盖，实例方法可以被覆盖。</li>
<li>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址 当该类创建对象后，类中的实例方法才分配入口地址， 从而实例方法可以被类创建的任何对象调用执行。</li>
<li>类方法在该类被加载到内存时，就分配了相应的入口地址。 从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。 类方法的入口地址直到程序退出时才被取消。</li>
</ul>
</li>
<li>注意：<ul>
<li>当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址。</li>
<li>也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。</li>
</ul>
</li>
<li>总结：<ul>
<li>类变量和类方法与类相关联，并且每个类都会出现一次。 使用它们不需要创建对象。</li>
<li>实例方法和变量会在每个类的实例中出现一次。</li>
</ul>
</li>
</ul>
<p><strong>接口</strong></p>
<ul>
<li>概念：接口在JAVA编程语言中是一个抽象类型，<strong>用于设计和表达ADT的语言机制</strong>，其是抽象方法的集合，接口通常以interface来声明。</li>
<li>一个类通过继承接口的方式，从而来继承接口的抽象方法。</li>
<li>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</li>
<li>一个接口可以扩展其他接口，一个类可以实现多个接口；一个接口也可以有多重实现</li>
<li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</li>
<li>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</li>
</ul>
<p><strong>接口的好处</strong></p>
<ul>
<li>Safe from bugs<br>ADT是由其操作定义的，接口就是这样做的。<br>当客户端使用接口类型时，静态检查确保他们只使用由接口定义的方法。<br>如果实现类公开其他方法，或者更糟糕的是，具有可见的表示，客户端不会意外地看到或依赖它们。<br>当我们有一个数据类型的多个实现时，接口提供方法签名的静态检查。</li>
<li>Easy to understand<br>客户和维护人员确切知道在哪里查找ADT的规约。<br>由于接口不包含实例字段或实例方法的实现，因此更容易将实现的细节保留在规范之外。</li>
<li>Ready for change<br>通过添加实现接口的类，我们可以轻松地添加新类型的实现。<br>如果我们避免使用静态工厂方法的构造函数，客户端将只能看到该接口。<br>这意味着我们可以切换客户端正在使用的实现类，而无需更改其代码。</li>
</ul>
<p><strong>抽象类</strong></p>
<ul>
<li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li>
<li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</li>
<li>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</li>
<li>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
<li>构造方法，类方法（用<code>static</code>修饰的方法）不能声明为抽象方法。</li>
</ul>
<h3 id="OOP的不同特征"><a href="#OOP的不同特征" class="headerlink" title="OOP的不同特征"></a><em>OOP的不同特征</em></h3><p><strong>封装</strong></p>
<ul>
<li><p>封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>
</li>
<li><p>设计良好的代码隐藏了所有的实现细节</p>
<ul>
<li>干净地将API与实施分开</li>
<li>模块只能通过API进行通信</li>
<li>对彼此的内在运作不了解</li>
</ul>
</li>
<li><p>信息封装的好处</p>
<ul>
<li>将构成系统的类分开，减少耦合</li>
<li>加快系统开发速度</li>
<li>减轻了维护的负担</li>
<li>启用有效的性能调整</li>
<li>增加软件复用</li>
</ul>
</li>
<li><p>信息隐藏接口</p>
<ul>
<li>使用接口类型声明变量</li>
<li>客户端仅使用接口中定义的方法</li>
<li>客户端代码无法直接访问属性</li>
</ul>
</li>
<li><p>实现封装的方法</p>
</li>
</ul>
<ol>
<li><p>修改属性的可见性来限制对属性的访问（一般限制为<code>private</code>），例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用**<code>this</code>**关键字是为了解决实例变量（<code>private String name</code>）和局部变量（<code>setName(String name)</code>中的<code>name</code>变量）之间发生的同名的冲突。</p>
</li>
</ol>
<p><strong>继承与重写</strong></p>
<ul>
<li><p>继承概念：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 </p>
</li>
<li><p>重写概念：重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p>
</li>
<li><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>
</li>
<li><p>实际执行时调用那种方法，在运行时决定</p>
</li>
<li><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。</p>
</li>
<li><p>子类只能添加新方法，无法重写超类中的方法。</p>
</li>
<li><p>当子类包含一个覆盖超类方法的方法时，它也可以使用关键字<code>super</code></p>
<p>调用超类方法。例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物可以移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.move(); <span class="comment">// 应用super类的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;狗可以跑和走&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// Dog 对象</span></span><br><span class="line">        b.move(); <span class="comment">//执行 Dog类的方法 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法重写的规则</p>
<ul>
<li>参数列表必须完全与被重写方法的相同；</li>
<li>返回类型必须完全与被重写方法的返回类型相同；</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为<code>public</code>，那么在子类中重写该方法就不能声明为<code>protected</code>。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为<code>final</code>的方法不能被重写。</li>
<li>声明为<code>static</code>的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ul>
</li>
</ul>
<p><strong>多态与重载</strong></p>
<ul>
<li>多态是同一行为具有多种不同表现形式或形态的能力</li>
<li>三种类型的多态<ul>
<li>Ad hoc polymorphism (特殊多态)：功能重载，一个函数可以有多个同名的实现。</li>
<li>Parametric polymorphism (参数多态)：泛型或泛型编程，一个类型名字可以代表多个类型</li>
<li>Subtyping (also called subtype polymorphism or inclusion polymorphism，子类型多态、包含多态):当一个名称表示许多不同的类与一些常见的超类相关的实例。</li>
</ul>
</li>
<li>重载(overloading) 是<strong>在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同。</strong></li>
<li>每个重载的方法（或构造函数）都必须有一个独一无二的参数类型列表。</li>
<li>价值：方便client调用，client可用不同的参数列表，调用同样的函数。</li>
<li>重载是静态多态，根据参数列表进行最佳匹配。在编译阶段时决定要具体执行哪个方法 (static type checking) ，与之相反，重构方法则是在run-time进行dynamic checking！</li>
<li>重载规则<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载；</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
</li>
</ul>
<p><strong>重写与重载的区别</strong></p>
<table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">重载方法</th>
<th align="center">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数列表</td>
<td align="center">必须修改</td>
<td align="center">一定不能修改</td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">可以修改</td>
<td align="center">一定不能修改</td>
</tr>
<tr>
<td align="center">异常</td>
<td align="center">可以修改</td>
<td align="center">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="center">访问</td>
<td align="center">可以修改</td>
<td align="center">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td align="center">调用情况</td>
<td align="center">引用类型决定选择哪个重载版本（基于声明的参数类型，<strong>在编译时发生</strong></td>
<td align="center">对象类型（换句话说，堆上实际实例的类型）决定选择哪种方法在运行时发生。</td>
</tr>
</tbody></table>
<p>　　方法的重写(Overriding)和重载(Overloading)是Java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ul>
<li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li>
<li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li>
<li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ul>
<p><strong>泛型（参数多态）</strong></p>
<ul>
<li>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</li>
<li>可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</li>
<li>下面是定义泛型方法的规则：<ul>
<li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。</li>
<li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li>
<li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li>
<li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像<code>int</code>, <code>double</code>, <code>char</code>等）。</li>
</ul>
</li>
</ul>
<h2 id="第五节-ADT和OOP中的等价性"><a href="#第五节-ADT和OOP中的等价性" class="headerlink" title="第五节 ADT和OOP中的等价性"></a>第五节 ADT和OOP中的等价性</h2><h3 id="等价性equals-和"><a href="#等价性equals-和" class="headerlink" title="等价性equals()和=="></a><em>等价性<code>equals()</code>和<code>==</code></em></h3><ul>
<li><p>和很多其他语言一样，Java有两种判断相等的操作——<code>==</code>和<code>equals()</code>。</p>
</li>
<li><pre><code>==
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是引用等价性 ；而</span><br><span class="line"></span><br></pre></td></tr></table></figure>
equals()
</code></pre>
<p>是对象等价性。 </p>
<ul>
<li><code>== </code>比较的是索引。更准确的说，它测试的是指向相等（referential equality）。如果两个索引指向同一块存储区域，那它们就是<code>==</code>的。对于我们之前提到过的快照图来说，<code>==</code>就意味着它们的箭头指向同一个对象。</li>
<li><code>equals()</code>操作比较的是对象的内容，换句话说，它测试的是对象值相等（object equality）。在每一个ADT中，<code>equals</code>操作必须合理定义。</li>
</ul>
</li>
</ul>
<p>Java中的数据类型，可分为两类： </p>
<ul>
<li>基本数据类型，也称原始数据类型。<code>byte, short, char, int, long, float, double, boolean</code> <ul>
<li>他们之间的比较，应用双等号（<code>==</code>）,比较的是他们的值。</li>
</ul>
</li>
<li>复合数据类型(类) <ul>
<li>当他们用（<code>==</code>）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 </li>
<li>Java当中所有的类都是继承于<code>Object</code>这个基类的，在<code>Object</code>中的基类中定义了一个<code>equals</code>的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如<code>String, Integer, Date</code>在这些类当中<code>equals</code>有其自身的实现，而不再是比较类在堆内存中的存放地址了。  </li>
<li>对于复合数据类型之间进行<code>equals</code>比较，在没有覆写<code>equals</code>方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为<code>Object</code>的<code>equals</code>方法也是用双等号（<code>==</code>）进行比较的，所以比较后的结果跟双等号（<code>==</code>）的结果相同。</li>
</ul>
</li>
</ul>
<h3 id="equals-的判断方法"><a href="#equals-的判断方法" class="headerlink" title="equals()的判断方法"></a><em><code>equals()</code>的判断方法</em></h3><p>严格来说，我们可以从三个角度定义相等：</p>
<ul>
<li><p><strong>抽象函数：</strong>回忆一下抽象函数（$AF: R \to A$ ），它将具体的表示数据映射到了抽象的值。如果$AF(a)&#x3D;AF(b)$，我们就说a和b相等。</p>
</li>
<li><p>等价关系：</p>
<p>等价是指对于关系$E \subseteq T \times T$ ，它满足：</p>
<ul>
<li>自反性: <code>x.equals(x)</code>必须返回<code>true</code></li>
<li>对称性: <code>x.equals(y)</code>与<code>y.equals(x)</code>的返回值必须相等。</li>
<li>传递性: <code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>必须为<code>true</code>。</li>
</ul>
</li>
</ul>
<p>以上两种角度&#x2F;定义实际上是一样的，通过等价关系我们可以构建一个抽象函数（译者注：就是一个封闭的二元关系运算）；而抽象函数也能推出一个等价关系。</p>
<h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a><code>hashCode()</code>方法</h4><ul>
<li>对于不可变类型：<ul>
<li><code>equals()</code>应该比较抽象值是否相等。这和 <code>equals()</code>比较行为相等性是一样的。</li>
<li><code>hashCode()</code>应该将抽象值映射为整数。</li>
<li>所以不可变类型应该同时覆盖<code>equals()</code>和<code>hashCode()</code></li>
</ul>
</li>
<li>对于可变类型：<ul>
<li><code>equals()</code>应该比较索引，就像<code>==</code>一样。同样的，这也是比较行为相等性。</li>
<li><code>hashCode()</code>应该将索引映射为整数。</li>
<li>所以可变类型不应该将<code>equals()</code>和<code>hashCode()</code>覆盖，而是直接继承 <code>Object</code>中的方法。Java没有为大多数聚合类遵守这一规定，这也许会导致上面看到的隐秘bug。</li>
</ul>
</li>
<li><code>equals()</code>与<code>hashCode()</code>两个方法均属于<code>Object</code>对象，<code>equals()</code>根据我们的需要重写， 用来判断是否是同一个内容或同一个对象，具体是判断什么，怎么判断得看怎么重写，默认的<code>equals()</code>是比较地址。</li>
<li><code>hashCode()</code>方法返回一个<code>int</code>的哈希码， 同样可以重写来自定义获取哈希码的方法。</li>
<li><code>equals()</code>判定为相同，<code>hashCode</code>一定相同。<code>equals()</code>判定为不同，<code>hashCode</code>不一定不同。</li>
<li><code>hashCode</code>必须为两个被该<code>equals</code>方法视为相等的对象产生相同的结果。</li>
<li>与<code>equals()</code>方法类似，<code>hashCode()</code>方法可以被重写。JDK中对<code>hashCode()</code>方法的作用，以及实现时的注意事项做了说明：<ul>
<li><code>hashCode()</code>在哈希表中起作用，如<code>java.util.HashMap</code>。</li>
<li>如果对象在<code>equals()</code>中使用的信息都没有改变，那么<code>hashCode()</code>值始终不变。</li>
<li>如果两个对象使用<code>equals()</code>方法判断为相等，则<code>hashCode()</code>方法也应该相等。</li>
<li>如果两个对象使用<code>equals()</code>方法判断为不相等，则不要求<code>hashCode()</code>也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的<code>hashCode</code>可以提高哈希表的性能。</li>
</ul>
</li>
</ul>
<h3 id="可变类型的等价性"><a href="#可变类型的等价性" class="headerlink" title="可变类型的等价性"></a><em>可变类型的等价性</em></h3><p>　　回忆之前我们对于相等的定义，即它们不能被使用者观察出来不同。而对于可变对象来说，它们多了一种新的可能：通过在观察前调用改造者，我们可以改变其内部的状态，从而观察出不同的结果。</p>
<ul>
<li><p>所以我们重新定义两种相等：</p>
<ul>
<li><strong>观察等价性</strong>：两个索引在不改变各自对象状态的前提下不能被区分。即通过只调用observer，producer和creator的方法，它测试的是这两个索引在当前程序状态下“看起来”相等。</li>
<li><strong>行为等价性</strong>：两个索引在任何代码的情况下都不能被区分，即使有一个对象调用了改造者。它测试的是两个对象是否会在未来所有的状态下“行为”相等。</li>
</ul>
</li>
<li><p>对于不可变对象，观察相等和行为相等是完全等价的，因为它们没有改造者改变对象内部的状态。</p>
</li>
<li><p><strong>对于可变对象，Java通常实现的是观察相等</strong>。例如两个不同的<code>List</code>对象包含相同的序列元素，那么<code>equals()</code> 操作就会返回真。</p>
</li>
</ul>
<br>
------    

<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="第一节-面向可理解性的构造"><a href="#第一节-面向可理解性的构造" class="headerlink" title="第一节 面向可理解性的构造"></a>第一节 面向可理解性的构造</h2><h3 id="代码的可理解性"><a href="#代码的可理解性" class="headerlink" title="代码的可理解性"></a><em>代码的可理解性</em></h3><br>
**如何编写易于理解的代码**

<ul>
<li>遵循命名规范</li>
<li>限制代码行的最大长度、文件的最大LoC</li>
<li>足够的注释</li>
<li>代码有好的布局：缩进、空行、对其、分块、等。</li>
<li>避免多层嵌套—增加复杂度</li>
<li>文件和包的组织</li>
</ul>
<p>代码的可读性&#x2F;可理解性很多时候比效率&#x2F;性能更重要，不可读、不可理解代码可能蕴含更多的错误。 因此先写出可读易懂的代码，再去逐渐调优。</p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93%EF%BC%881)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93%EF%BC%881)/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-06-21 22:23:41" itemprop="dateModified" datetime="2019-06-21T22:23:41+08:00">2019-06-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<p><font size = 7> 软件构造知识点总结(1) </font>　　</p>
<h2 id="date-2019-04-21-03-23-29"><a href="#date-2019-04-21-03-23-29" class="headerlink" title="date: 2019-04-21 03:23:29"></a>date: 2019-04-21 03:23:29</h2><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><hr>
<h3 id="第一节-软件构造的多维视图"><a href="#第一节-软件构造的多维视图" class="headerlink" title="第一节 软件构造的多维视图"></a><em>第一节 软件构造的多维视图</em></h3><p>　　<strong>BulidTime概述</strong>  　　</p>
<p>　　　　三种相互关联的形式　　</p>
<p>　　　　　　　　　面向词法　半结构化源代码　  </p>
<p>　　　　　　　　　面向语法　（AST抽象语法树）半结构化的源代码变成语法树　　</p>
<p>　　　　　　　　　面向语义UML</p>
<p>　　<strong>Runtime概述</strong></p>
<p>　　　　运行时软件的高级概念</p>
<p>　　　　　　　　　可执行程序：CPU能直接理解执行的指令序列（二进制文件）</p>
<p>　　　　　　　　　库文件：可复用的代码，库文件本身不能执行</p>
<p>　　　　可执行程序的四种形式</p>
<p>　　　　　　　　　本地机器码，自解码，静态链接，动态链接</p>
<h3 id="第二节-软件开发的质量属性"><a href="#第二节-软件开发的质量属性" class="headerlink" title="第二节　软件开发的质量属性"></a><em>第二节　软件开发的质量属性</em></h3><h4 id="外部质量属性"><a href="#外部质量属性" class="headerlink" title="外部质量属性"></a><em>外部质量属性</em></h4><p>1.正确性： 在规格说明书描述范围之内满足正确性； 保证正确性的技术: １．有限制的正确（只保证自己层面的正确，假设调用的都是正确的<br>2.测试与调试　３.防御性编程　４.形式化编程（采用很多数学技术）　　　　</p>
<p>　　　　健壮性: 碰到异常情况进行适当的响应；出现规格说明书之外的情况由健壮性处理（响应异常情况、给出错误提示、正常退出或降级）　　<br>　　<br>　　　　可扩展性： 软件模块能否被其他程序很方便的使用（开发备注、封装）  </p>
<p>　　　　兼容性： 能够与其他人进行交互；跨平台、跨软件，实现方法： 一致性和标准化（一致的方法和标准）： 标准文件格式，标准数据结构，标准用户接口，标准协议。  </p>
<p>　　　　效率： 程序运行中对CPU、硬盘的占用带宽（好的算法、I&#x2F;O技术、内存管理)  </p>
<p>　　　　可移植性： 是否容易由一个环境转移到另一个环境。  </p>
<p>　　　　应用性： 用户是否容易使用，不影响专业人员的使用情况下，方便初学者（结构清晰的设置、UI设计要理解用户需求）  </p>
<p>　　　　功能性： 蠕变特征，原则是在保证整体质量不降低的情况下进行更新，策略：增量式模型  </p>
<p>　　　　及时性： 在规定时间内完成： 时间效率高　　</p>
<p>　　　　其他质量特性： 可验证性（如管理系统的效果难以验证）、完整性（不会被非法访问干扰修改，防止数据不一致）、可修改性、资金  </p>
<h4 id="内部质量属性"><a href="#内部质量属性" class="headerlink" title="内部质量属性"></a><em>内部质量属性</em></h4><p>　　</p>
<p>　　<strong>五个关键的质量属性</strong>　    </p>
<p>　　　　　easy to understand　　<br>　　　　　ready fot change<br>　　　　　cheap for develop<br>　　　　　safe from bugs<br>　　　　　efficient to run</p>
<p>　　　　　可理解性： 1.在构建时： 代码层要注意（函数规约）： 变量&#x2F;子程序&#x2F;语句的命名与构造标准；代码布局与风格；注释；复杂度  组件层要注意构建和项目的可理解性： 包的组织；文件的组织；命名空间 在时段中，代码层注意重构 2.在运行时，代码层注意跟踪日志<br>　　　　　<br>　　　　　可复用性：　１.构建时　代码层应注意：ADT&#x2F;OOP;接口与实现分离；继承&#x2F;重载&#x2F;重写；<br>组合&#x2F;代理；多态；自类型与泛型编程；OO设计模式 组件层注意：API接口设计；类库；框架</p>
<p>　　　　　可维护性与适用性： １．构建时（面对需求的改变，能否做出及时的调整）　代码层可采用：模块化设计；高内聚，低耦合；SOLID原则；OO设计模式；面向图表的编程；面向状态编程；面向语法编程 组件层除注意SOLID原则外，还应考虑GRASP原则 在时段内使用SCM进行版本控制</p>
<p>　　　　　健壮性：　１．Code level-build time-Moment:错误处理；异常处理；断言；防御性编程；测试优先编程  　2.Component level-build time-period:单元测试；集成测试　3.Build time-period:回归测试  　4.run time-moment:测试转储　5.run time-period：跟踪日志  </p>
<h2 id="性能：-1-构建时，使用指定的设计模式-2-运行时-在代码层次：-通过内存管理考虑空间复杂度；通过算法性能计算时间复杂度；利用代码调优生成更高效的目标代码；在时段内进行性能分析和调整-在组件层次：采用分布式系统；编写多线程的并行程序"><a href="#性能：-1-构建时，使用指定的设计模式-2-运行时-在代码层次：-通过内存管理考虑空间复杂度；通过算法性能计算时间复杂度；利用代码调优生成更高效的目标代码；在时段内进行性能分析和调整-在组件层次：采用分布式系统；编写多线程的并行程序" class="headerlink" title="　　　　　性能： 1.构建时，使用指定的设计模式 2.运行时 在代码层次： 通过内存管理考虑空间复杂度；通过算法性能计算时间复杂度；利用代码调优生成更高效的目标代码；在时段内进行性能分析和调整  在组件层次：采用分布式系统；编写多线程的并行程序"></a>　　　　　性能： 1.构建时，使用指定的设计模式 2.运行时 在代码层次： 通过内存管理考虑空间复杂度；通过算法性能计算时间复杂度；利用代码调优生成更高效的目标代码；在时段内进行性能分析和调整  在组件层次：采用分布式系统；编写多线程的并行程序<br><br><br></h2><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><hr>
<h3 id="第一节-软件声明周期和版本控制（配置管理）"><a href="#第一节-软件声明周期和版本控制（配置管理）" class="headerlink" title="第一节 软件声明周期和版本控制（配置管理）"></a><em>第一节 软件声明周期和版本控制（配置管理）</em></h3><h4 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h4><h2 id="声明周期：两种形态-1-从0到1：SDLC-2-从1到n：运用版本控制技术实现迭代更新-瀑布模型：Requirements-Design-Implementation-Verification-Maintenance-增量模型：运用分治的思想，将需求分段，成为一系列增量产品，每个增量颞部仍使用瀑布模型-V模型：对瀑布模型的改变，强调测试与继承，对代码、分析文档进行质量保证-螺旋模型：采用一种周期性的方法来进行系统开发。优点：设计上的灵活性，可以在项目的各个阶段进行变更，以小的分段来构建大型系统，使成本计算变得简单容易。-版本控制工具—Git-Git的整体架构——四个仓库（本地由三个）：工作目录；暂存区域（在menmory中，对用户不可见）（隐藏的-git文件夹中的stage）；本地库：源代码；云端软件服务器（远程仓库）-利用对象图结构：每个节点保存：父节点、如提交时间的信息；VCS还原差异、Git保存完整文件；Git对于重复文件，不复制文件，只修改指针；减少冗余；访问速度快-分支代码：git-创建）-branc（切换）-b（branch）-iss53；git-merge-hitfix（合并）；是用git把文件添加进去，实际上就是把文件修改添加到暂存区；用git-commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。-本地库和远程库：clone：将整个库完整的复制；fetch：将某一分支复制下来；push：将粉直推送到服务器上；pull：将某一分支复制下来合并在当前分支上"><a href="#声明周期：两种形态-1-从0到1：SDLC-2-从1到n：运用版本控制技术实现迭代更新-瀑布模型：Requirements-Design-Implementation-Verification-Maintenance-增量模型：运用分治的思想，将需求分段，成为一系列增量产品，每个增量颞部仍使用瀑布模型-V模型：对瀑布模型的改变，强调测试与继承，对代码、分析文档进行质量保证-螺旋模型：采用一种周期性的方法来进行系统开发。优点：设计上的灵活性，可以在项目的各个阶段进行变更，以小的分段来构建大型系统，使成本计算变得简单容易。-版本控制工具—Git-Git的整体架构——四个仓库（本地由三个）：工作目录；暂存区域（在menmory中，对用户不可见）（隐藏的-git文件夹中的stage）；本地库：源代码；云端软件服务器（远程仓库）-利用对象图结构：每个节点保存：父节点、如提交时间的信息；VCS还原差异、Git保存完整文件；Git对于重复文件，不复制文件，只修改指针；减少冗余；访问速度快-分支代码：git-创建）-branc（切换）-b（branch）-iss53；git-merge-hitfix（合并）；是用git把文件添加进去，实际上就是把文件修改添加到暂存区；用git-commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。-本地库和远程库：clone：将整个库完整的复制；fetch：将某一分支复制下来；push：将粉直推送到服务器上；pull：将某一分支复制下来合并在当前分支上" class="headerlink" title="　　　声明周期：两种形态 1.从0到1：SDLC  2.从1到n：运用版本控制技术实现迭代更新　　　瀑布模型：Requirements-&gt;Design-&gt;Implementation-&gt;Verification-&gt;Maintenance　　　　　增量模型：运用分治的思想，将需求分段，成为一系列增量产品，每个增量颞部仍使用瀑布模型　　　　　V模型：对瀑布模型的改变，强调测试与继承，对代码、分析文档进行质量保证　　　螺旋模型：采用一种周期性的方法来进行系统开发。优点：设计上的灵活性，可以在项目的各个阶段进行变更，以小的分段来构建大型系统，使成本计算变得简单容易。#### 版本控制工具—Git　　　Git的整体架构——四个仓库（本地由三个）：工作目录；暂存区域（在menmory中，对用户不可见）（隐藏的.git文件夹中的stage）；本地库：源代码；云端软件服务器（远程仓库）　　　　　利用对象图结构：每个节点保存：父节点、如提交时间的信息；VCS还原差异、Git保存完整文件；Git对于重复文件，不复制文件，只修改指针；减少冗余；访问速度快　　　　分支代码：git(创建） branc（切换） -b（branch） iss53；git merge hitfix（合并）；是用git把文件添加进去，实际上就是把文件修改添加到暂存区；用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。　　　　　本地库和远程库：clone：将整个库完整的复制；fetch：将某一分支复制下来；push：将粉直推送到服务器上；pull：将某一分支复制下来合并在当前分支上　　"></a>　　　<strong>声明周期</strong>：两种形态 1.从0到1：SDLC  2.从1到n：运用版本控制技术实现迭代更新<br>　　　<strong>瀑布模型</strong>：Requirements-&gt;Design-&gt;Implementation-&gt;Verification-&gt;Maintenance　　<br>　　　<strong>增量模型</strong>：运用分治的思想，将需求分段，成为一系列增量产品，每个增量颞部仍使用瀑布模型　　<br>　　　<strong>V模型</strong>：对瀑布模型的改变，强调测试与继承，对代码、分析文档进行质量保证<br>　　　<strong>螺旋模型</strong>：采用一种周期性的方法来进行系统开发。优点：设计上的灵活性，可以在项目的各个阶段进行变更，以小的分段来构建大型系统，使成本计算变得简单容易。<br>#### 版本控制工具—Git<br>　　　<strong>Git的整体架构</strong>——四个仓库（本地由三个）：工作目录；暂存区域（在menmory中，对用户不可见）（隐藏的.git文件夹中的stage）；本地库：源代码；云端软件服务器（远程仓库）<br>　　<br>　　　<strong>利用对象图结构</strong>：每个节点保存：父节点、如提交时间的信息；VCS还原差异、Git保存完整文件；Git对于重复文件，不复制文件，只修改指针；减少冗余；访问速度快<br>　<br>　　　<strong>分支代码</strong>：git(创建） branc（切换） -b（branch） iss53；git merge hitfix（合并）；是用git把文件添加进去，实际上就是把文件修改添加到暂存区；用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。<br>　　<br>　　　<strong>本地库和远程库</strong>：clone：将整个库完整的复制；fetch：将某一分支复制下来；push：将粉直推送到服务器上；pull：将某一分支复制下来合并在当前分支上　　</h2><h3 id="第二节-软件构造的过程、系统和工具"><a href="#第二节-软件构造的过程、系统和工具" class="headerlink" title="第二节 软件构造的过程、系统和工具"></a><em>第二节 软件构造的过程、系统和工具</em></h3><hr>
<h4 id="广义的软件构造过程"><a href="#广义的软件构造过程" class="headerlink" title="广义的软件构造过程:"></a>广义的软件构造过程:</h4><h5 id="1-编程"><a href="#1-编程" class="headerlink" title="1.编程"></a>1.编程</h5><p>　　　<strong>开发语言</strong>：使用IDE的优势：方便编写代码和管理文件（有代码编辑器，代码重构工具、文件和库管理工具） 能够编译、构建（有编译器、解释器、自动构建工具） 结构清晰（有面向对象的类层次结构图和类浏览器） 有GUI界面 支持第三方扩展工具<br>　　　<strong>建模语言</strong>：UML(统一建模语言）：UML是用来对软件系统进行可视化建模的一种语言； UML的结构由一组一致的规则定义； 建模的目的：有助于按照需求对系统进行可视化分析 能够理解系统的结构或行为 给出了构造系统的模板 对做出的决策进行文档化<br>　　　<strong>配置语言</strong>：键值文件（.ini;.properties;.rc);XML,YAML,JSON：配置语言用于配hi程序的参数和初始化设置 目的：部署环境设置；应用程序功能的变体；组件之间连接的变体  </p>
<h5 id="2-静态代码分析："><a href="#2-静态代码分析：" class="headerlink" title="2.静态代码分析："></a>2.静态代码分析：</h5><p>　　　是指不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性（提供了对代码结构的理解、有助于确保代码符合行业标准）</p>
<h5 id="3-动态代码分析："><a href="#3-动态代码分析：" class="headerlink" title="3.动态代码分析："></a>3.动态代码分析：</h5><p>　　　是指通过运行被测试程序，检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等功能（必须执行足够的测试输入，使用诸如代码覆盖率之类的软件测试措施有助于确保已经观察到程序的一组可能i行为的足够部分）　　<br><br>　　</p>
<h4 id="狭义的软件构造过程"><a href="#狭义的软件构造过程" class="headerlink" title="狭义的软件构造过程"></a>狭义的软件构造过程</h4><h5 id="1-主要的知识结构"><a href="#1-主要的知识结构" class="headerlink" title="1.主要的知识结构"></a>1.主要的知识结构</h5><p>Build场景综述：  </p>
<p>　　　用传统编译语言如C、C++、Java编写软件（complilation）<br>　　　用解释型语言（如Perl、python）编写软件的打包和测试（packing and testing）<br>　　　用基于Web的应用程序进行编译和打包（使用静态HTML页面、使用Java或C#编写的源代码、使用JSP、ASP或PHP语法编写的混合文件以及多种类型额配置文件）<br>　　　执行单元测试代码的其余部分对软件进行隔离验证<br>　　　执行静态分析工具来识别程序源代码中的错误<br>　　　生成PDF或HTML文档</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/" class="post-title-link" itemprop="url">二叉树入门指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-03-04 21:56:13" itemprop="dateModified" datetime="2022-03-04T21:56:13+08:00">2022-03-04</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="二叉树的种类"><a href="#二叉树的种类" class="headerlink" title="二叉树的种类"></a>二叉树的种类</h1><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><p>满二叉树的定义是：如果一颗二叉树只有度为0的节点和度为2的节点，且度为0的节点在同一层上，则该二叉树是满二叉树，如下图：</p>


<p>满二叉树的深度为k，则节点共有 $ 2^{k} - 1 $个（这里使用等比数列相加即可得出）。</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</p>


<p>优先级队列其实是一个堆，堆就是一个完全二叉树，而且保证了父子节点的顺序关系。</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树是节点带有数值的一棵树，并且要满足以下关系：<br><strong>若它的左子树不为空，则左子树上所有节点的值都小于根节点的值；</strong><br><strong>若它的右子树不为空，则右子树上所有节点的值都大于根节点的值；</strong><br><strong>它的左、右子树也分别为二叉排序树。</strong></p>


<h2 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h2><p>平衡二叉搜索树又被称为<strong>AVL（Adelson-Velsky and Landis）</strong>，且具有如下性质：它是一棵空树或者它的左右两个子树的高度差的绝对值不超过1，并且左右两颗子树都是平衡二叉树。</p>
 

<p>最后一棵树不是平衡二叉搜索树，因为根节点的左右子树的高度差的绝对值超过了1（此时左边为6，右边无子树为0）。</p>
<p>C++中<strong>map、set、multimap，multiset</strong>的底层实现都是平衡二叉搜索树，所以<strong>map、set</strong>的增删操作时间时间复杂度是<strong>logn</strong>，注意我这里没有说<strong>unordered_map、unordered_set</strong>，这两者的底层实现是哈希表。</p>
<h1 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h1><p>在面试的时候，因为大部分情况是没有IDE和代码提示的，需要自己定义二叉树，下面是常用的定义二叉树的方法：</p>
<pre><code>struct TreeNode&#123;
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(): val(0), left(NULL), right(NULL) &#123;&#125;
    TreeNode(int x): val(x), left(NULL), right(NULL) &#123;&#125;
&#125;
</code></pre>
<h1 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h1><p>说到二叉树，那么常见的考察方式就是其遍历方式，大体上可以概括为两种：<br><strong>1. 深度优先遍历</strong><br>    $\qquad\bullet$<strong>前序遍历（递归，迭代）</strong><br>    $\qquad\bullet$<strong>中序遍历（递归，迭代）</strong><br>    $\qquad\bullet$<strong>后序遍历（递归，迭代）</strong><br><strong>2. 广度优先遍历</strong><br>    $\qquad\bullet$<strong>层次遍历（迭代）</strong></p>
<p>在深度优先遍历中，前、中、后指的是根节点所在的位置。</p>
<h2 id="深度优先遍历（迭代法）"><a href="#深度优先遍历（迭代法）" class="headerlink" title="深度优先遍历（迭代法）"></a>深度优先遍历（迭代法）</h2><p>下面介绍一下使用递归方法进行深度优先遍历，这里假设我们使用<strong>vector</strong>来保存遍历过程中的节点值。这里提供的是递归方法的思路，之后只需要按照这个思路稍微修改代码满足需要即可。</p>
<h3 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h3><pre><code>//中-左-右
class Solution&#123;
public:
    void traversal(TreeNode* cur， vector&lt;int&gt;&amp; vec)&#123;
        if(cur == NULL)return;
        vec.push_back(cr-&gt;val); //中
        traversal(cur-&gt;left); //左
        traversal(cur-&gt;right); //右
    &#125;

    vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123;
        vector&lt;int&gt; result;
        if(root == NULL)return result;
        traversal(root, result);
        return result;
    &#125;
&#125;
</code></pre>
<p>同理，中序遍历和后序遍历只需要修改递归代码中的顺序即可，思路都是一样的。</p>
<h3 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h3><pre><code>//左-中-右
class Solution&#123;
public:
    void traversal(TreeNode* cur， vector&lt;int&gt;&amp; vec)&#123;
        if(cur == NULL)return;
        traversal(cur-&gt;left); //左
        vec.push_back(cr-&gt;val); //中
        traversal(cur-&gt;right); //右
    &#125;

    vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123;
        vector&lt;int&gt; result;
        if(root == NULL)return result;
        traversal(root, result);
        return result;
    &#125;
&#125;
</code></pre>
<h3 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h3><pre><code>//左-右-中
class Solution&#123;
public:
    void traversal(TreeNode* cur， vector&lt;int&gt;&amp; vec)&#123;
        if(cur == NULL)return;
        traversal(cur-&gt;left); //左
        traversal(cur-&gt;right); //右
        vec.push_back(cr-&gt;val); //中
    &#125;

    vector&lt;int&gt; preorderTraversal(TreeNode* root)&#123;
        vector&lt;int&gt; result;
        if(root == NULL)return result;
        traversal(root, result);
        return result;
    &#125;
&#125;
</code></pre>
<p>下一篇博客将总结使用迭代方法实现深度优先遍历和广度优先遍历（即层次遍历）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/Windows-10-%E5%AE%89%E8%A3%85PyTorch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/Windows-10-%E5%AE%89%E8%A3%85PyTorch/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2019-09-16 21:38:57" itemprop="dateModified" datetime="2019-09-16T21:38:57+08:00">2019-09-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h1 id="Windows-10-安装PyTorch"><a href="#Windows-10-安装PyTorch" class="headerlink" title="Windows 10 安装PyTorch"></a><em>Windows 10 安装PyTorch</em></h1><h4 id="2019-09-16-20-33-06"><a href="#2019-09-16-20-33-06" class="headerlink" title="2019-09-16 20:33:06"></a>2019-09-16 20:33:06</h4><hr>
<p>今天比较有时间，正好看完了CVPR-2018年的论文&lt;**Single Image Reﬂection Separation with Perceptual Losses**&gt;，这里不多介绍这篇论文相关的东西了。因为跑这个数据的话，自己的电脑当时在Windows下装的Tensorflow，但是作者给的运行策略是Ubuntu下，所以问了一下学长，他说可以在Windows下安装PyTorch来跑。下面就记录一下自己安装PyTorch的过程。</p>
<p>1.由于之前安装了Anaconda3，所以可以采用conda安装的方式，但是之前安装Tensorflow的时候Python版本的问题就一直有点疑问，所以查了一下发现如果只是想利用Pycharm运行PyTorch的话，其实直接用pip方式安装就可以</p>
<p>2.那么需要到PyTorch官网去查看自己所需的代码 <a target="_blank" rel="noopener" href="https://pytorch.org/">PyTorch官网连接</a>，相应的选择自己电脑的配置，注意如果用pip安装的话，要选择Pip选项。然后下面就会给出你所需的命令。还要注意的一点是我的电脑由于是A卡的，所以在CUDA这个部分我选择的是None，也就是所说的CPU版本的PyTorch。本人的命令如下：</p>
<pre><code>pip3 install torch==1.2.0+cpu torchvision==0.4.0+cpu -f https://download.pytorch.org/whl/torch_stable.html
</code></pre>
<p>3.安装成功后，一定要记得看一下自己所安装的<em><strong>文件夹地址</strong></em></p>
<p>4.打开Pycharm，按ctrl+alt+s，打开Project Interpreter进行配置，点击右上角的设置符号，选择Add，在下面点选Existing environment，然后在右边的…处找到自己刚才安装的<em><strong>文件夹地址</strong></em>，拉到最下面找到python.exe文件一路点击<strong>ok</strong>。</p>
<p>5.在pycharm中新建项目，输入以下代码：</p>
<pre><code>from __future__ import print_function
import torch
x=torch.rand(5,3)
print(x)
</code></pre>
<p>查看输出，如果输出为：</p>
<pre><code>tensor([[0.9072, 0.3848, 0.9203],
        [0.1643, 0.7447, 0.1730],
        [0.4379, 0.2974, 0.1283],
        [0.4563, 0.5322, 0.9924],
        [0.4715, 0.9287, 0.7176]])

Process finished with exit code 0
</code></pre>
<p>证明PyTorch安装成功！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/24/experience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/24/experience/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-24 23:10:35" itemprop="dateCreated datePublished" datetime="2024-04-24T23:10:35+08:00">2024-04-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-12 17:00:26" itemprop="dateModified" datetime="2022-10-12T17:00:26+08:00">2022-10-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-函数中几种const构不构成重载的分析"><a href="#1-函数中几种const构不构成重载的分析" class="headerlink" title="1. 函数中几种const构不构成重载的分析"></a>1. 函数中几种const构不构成重载的分析</h2><ul>
<li><p>函数中值传递不构成重载，因为传入的只是一个值，而且会报重定义错误</p>
<pre><code>  void test(int a)&#123;
      cout &lt;&lt; a &lt;&lt; endl;
  &#125;
  //下面的代码会报重定义错误
  void test(const int a)&#123;
      cout &lt;&lt; a &lt;&lt; 2endl; 
  &#125;
</code></pre>
</li>
<li><p>函数中引用传递和指针传递增加const构成重载，因为传入的是确切的对象，<code>const</code>可以区分传入的这些对象能否被修改的性质</p>
<pre><code>  int test(int *a)&#123;
      return *a;
  &#125;
  int test(const int *a)&#123;
      return *a;
  &#125;
</code></pre>
</li>
<li><p>成员函数中函数后面加<code>const</code>构成重载，和上面的情况同理，是能决定成员变量能否被修改的</p>
<pre><code>  class test&#123;
  public:
      test()&#123;&#125;
      ~test()&#123;&#125;
      int display()&#123;
          return this.a;
      &#125;
      int display const()&#123;
          return this.a;
      &#125;
  private:
      int a;
  &#125;
</code></pre>
</li>
</ul>
<h2 id="2-如何做到在const成员函数内修改成员变量"><a href="#2-如何做到在const成员函数内修改成员变量" class="headerlink" title="2.如何做到在const成员函数内修改成员变量"></a>2.如何做到在const成员函数内修改成员变量</h2><ul>
<li><p>使用mutable关键字去修饰成员变量，这样成员变量始终是可以变化的</p>
</li>
<li><p>定义一个常量指针指向this所指的对象，然后用这个指针去修改成员变量</p>
<pre><code>  class test&#123;
  public:
      test()&#123;&#125;
      ~test()&#123;&#125;

      void display(int a) const&#123;
          test *const te = const_cast&lt;test *const&gt;(this);
          te-&gt;value = 2;
          cout &lt;&lt; te-value &lt;&lt; endl;
      &#125;
  private:
      int value;
  &#125;
</code></pre>
</li>
</ul>
<h2 id="3-内联函数和宏定义的区别"><a href="#3-内联函数和宏定义的区别" class="headerlink" title="3.内联函数和宏定义的区别"></a>3.内联函数和宏定义的区别</h2><p>1.内联函数是函数，有参数类型检查，更为安全<br>2.内联函数由编译器进行处理，而宏定义由预处理器进行处理<br>3.内联函数处理时被插入到对应代码区域，而宏定义只是简单的文本替换</p>
<h2 id="4-c-编译过程"><a href="#4-c-编译过程" class="headerlink" title="4.c++编译过程"></a>4.c++编译过程</h2><p>分为预处理+编译+汇编+链接</p>
<ul>
<li>预处理：主要处理那些源代码中以#开始的预编译指令，主要处理规则如下：<ul>
<li>将宏定义进行文本替换</li>
<li>将<code>#include</code>的文件插入到对应位置（递归进行，因为可能循环包含）</li>
<li>删除注释</li>
</ul>
</li>
<li>编译：进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件（内联函数就在这一阶段）</li>
<li>汇编：将汇编代码转变成机器语言</li>
<li>链接：将各个目标文件组装在一起，并生成可执行文件。</li>
</ul>
<h2 id="5-程序的内存分配"><a href="#5-程序的内存分配" class="headerlink" title="5.程序的内存分配"></a>5.程序的内存分配</h2><p>1.栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。<br>2.堆区：由程序员自己分配释放，分配方式类似于链表<br>3.全局静态区：全局变量和静态变量的位置，初始化的在一起，未初始化的在一起<br>4.常量区：常量存放地址，程序接受系统释放<br>5.程序代码区：存放函数的二进制代码</p>
<h2 id="6-内存中堆和栈的区别"><a href="#6-内存中堆和栈的区别" class="headerlink" title="6.内存中堆和栈的区别"></a>6.内存中堆和栈的区别</h2><p>1.栈由系统统一分配，例如局部变量声明后就自动放在栈中（先进后出）<br>2.堆需要自己申请，比如malloc函数和new</p>
<h2 id="7-实现一个在main函数运行之前运行的函数"><a href="#7-实现一个在main函数运行之前运行的函数" class="headerlink" title="7.实现一个在main函数运行之前运行的函数"></a>7.实现一个在main函数运行之前运行的函数</h2><p>1.使用attribute关键字</p>
<pre><code>__attribute((constructor))void before()&#123;
    cout &lt;&lt; &quot;before main&quot; &lt;&lt; endl;
&#125;
</code></pre>
<p>2.使用全局对象的构造函数，其会在main函数执行之前运行</p>
<pre><code>class my_test&#123;
public:
    my_test()&#123;
        cout &lt;&lt; &quot;test&quot; &lt;&lt; endl;
    &#125;
    ~my_test()&#123;&#125;
&#125;

my_test test;

void main()&#123;
    cout &lt;&lt; &quot;this is main func&quot; &lt;&lt; endl;
&#125;
</code></pre>
<h2 id="8-c-常量储存的位置"><a href="#8-c-常量储存的位置" class="headerlink" title="8.c++常量储存的位置"></a>8.c++常量储存的位置</h2><p>1.局部常量（和局部变量位置一样）：栈区<br>2.全局常量（和全局变量位置一样）：全局静态区<br>3.字面值常量：存放在常量区</p>
<h2 id="9-C-隐式转换"><a href="#9-C-隐式转换" class="headerlink" title="9.C++隐式转换"></a>9.C++隐式转换</h2><p>1.算数类型</p>
<ul>
<li>整型提升：将小整数转换成较大的整数类型</li>
<li>有符号类型转换为无符号类型，其值可能回发生变化</li>
<li>在条件判断中，非布尔类型自动转换为布尔类型（0为false，其余为true)</li>
</ul>
<p>2.类类型<br>《C++ Primer》中提到：可以用单个形参来调用的构造函数定义了从形参类型到该类类型的一个隐式转换。</p>
<pre><code>class Test&#123;
public:
    Test(int i);
&#125;;

Test t1 = 1;
</code></pre>
<p>这里由于隐式转换，1先被Test构造函数构造成Test对象，然后才被赋值为1，其操作等同于</p>
<pre><code>Test tmp(1);
Test t1 = tmp;
</code></pre>
<p>为了防止这种看起来很模棱两可的写法，可以使用关键字 explicit来防止隐式转换。其只对有一个参数的类构造函数有效，如果类构造函数的参数大于等于2是不会产生隐式转换的（有一种特殊情况，就是多个参数，但是除了其中某一个之外，其他参数都有默认值）。</p>
<h2 id="10-extern-“C”作用"><a href="#10-extern-“C”作用" class="headerlink" title="10. extern “C”作用"></a>10. extern “C”作用</h2><p>被该语句修饰的变量和函数是按照C语言方式编译和链接的。一般在C++代码调用C语言代码，在C++的头文件中使用。实现C++和C的混合编程。</p>
<p>作为一种面向对象的语言， C++ 支持函数重载，而过程式语言 C 则不支持。所以，函数被 C++ 编译后在符号库中的名字与 C 语言的有所不同。例如，假设某个函数的原型为：</p>
<pre><code>void foo( int x, int y );
</code></pre>
<p>该函数被 C 编译器编译后在符号库中的名字为 _foo ，而 C++ 编译器则会产生像 _foo_int_int 之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为 mangled name ）。 _foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息， C++ 就是靠这种机制来实现函数重载的。例如，在 C++ 中，函数 void foo( int x, int y ) 与 void foo( int x, float y ) 编译生成的符号是不相同的，后者为 _foo_int_float 。</p>
<p>假设在C++中，模块A的头文件如下：</p>
<pre><code>//模块A头文件　moduleA.h
#ifndef MODULE_A_H
#define MODULE_A_H
int foo( int x, int y );
#endif
</code></pre>
<p>在模块 B 中引用该函数：</p>
<pre><code>// 模块B实现文件　moduleB.cpp
#include &quot;moduleA.h&quot;
foo(2,3);
</code></pre>
<p>实际上，在连接阶段，连接器会从模块 A 生成的目标文件 moduleA.obj 中寻找 _foo_int_int 这样的符号！</p>
<p>对于上面例子，如果 B 模块是 C 程序，而A模块是 C++ 库头文件的话，会导致链接错误；同理，如果B模块是 C++ 程序，而A模块是C库的头文件也会导致错误。而加了extern “C”后，链接的时候寻找的就是未经修改的符号名_foo，不会产生错误。</p>
<h2 id="11-说说RTTI"><a href="#11-说说RTTI" class="headerlink" title="11.说说RTTI"></a>11.说说RTTI</h2><p>1.RTTI是运行阶段类型识别的简称，其用途为：假设有一个基类和多个派生类，则可以让基类指针指向其中任何一个类的对象，但是我们想要知道指针具体指向的是哪个类的对象，因为：</p>
<ul>
<li>有可能想要调用类方法的正确版本，因为派生类对象可能包含不是继承来的方法，即只有派生类对象可以调用该方法。</li>
<li>也有可能是出于调试的目的，想跟踪生成对象的类型。<br>2.有3个支持RTTI的元素：</li>
<li>dynamic_cast运算符使用一个指向基类的指针来生成一个指向派生类的指针，其主要用于“安全的向下转型”，即基类对象的指针或者引用来转换为同一继承层次的其他指针和引用。向下转型有两种情况，一种是基类指针指向派生类对象，这种转换是安全的；另一种是基类指针所指对象为基类对象，这种情况会失败并返回空指针（即0）。对于引用类型，失败的时候抛出一个bad_cast异常。</li>
<li>typeid运算符和type_info类：用于判断具体的类型</li>
<li>二者之间的区别：前者用于判断是否能够进行转换，并进行类型检查，而后者直接判断具体的类型。</li>
</ul>
<h2 id="new和malloc的区别"><a href="#new和malloc的区别" class="headerlink" title="new和malloc的区别"></a>new和malloc的区别</h2><p>1.new分配在自由储存区（C++中一个抽象概念，凡是通过new进行内存申请的，该内存就是自由储存区）；malloc从堆上动态分配内存。那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。<br>2.new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。<br>3.new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。<br>4.使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。<br>5.使用new操作符来分配对象内存时会经历三个步骤：</p>
<ul>
<li><p>第一步：调用operator new 函数分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</p>
</li>
<li><p>第二步：调用相应的构造函数以初始化对象，并为其传入初值。</p>
</li>
<li><p>第三部：对象构造完成后，返回一个指向该对象的指针。<br>使用delete操作符来释放对象内存时会经历两个步骤：</p>
</li>
<li><p>第一步：调用对象的析构函数。</p>
</li>
<li><p>第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。<br>而malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构函数<br>6.对数组的处理：new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[] 要与new []配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。而malloc不会进行这些操作。<br>7.operator new的实现可以基于malloc，而malloc的实现不可以去调用new，示例代码如下：</p>
<p>  void * operator new (sieze_t size)<br>  {<br>  if(void * mem &#x3D; malloc(size)<br>      return mem;<br>  else<br>      throw bad_alloc();<br>  }</p>
</li>
</ul>
<p>8.重新分配内存<br>使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。<br>new没有这样直观的配套设施来扩充内存。</p>
<h2 id="sizeof的一些特性"><a href="#sizeof的一些特性" class="headerlink" title="sizeof的一些特性"></a>sizeof的一些特性</h2><ul>
<li>sizeof是运算符，不是函数</li>
<li>sizeof不能求得void类型的长度</li>
<li>sizeof<strong>可以</strong>求得void指针的长度，在32位的机器上为4byte字节（因为是指针变量）</li>
<li>sizeof可以求得静态分配内存的数组的长度，需要注意的是，如果在一个函数内部使用sizeof对数组求长度，而且这个数组是通过函数参数的形式传递进来，则长度还是4字节，因为这里参数被自动转换为了指针（即数组第一个元素的地址），这样可以减少拷贝导致的效率低下。另外，当字符数组表示字符串时，sizeof值将会把’\0’包含进去。</li>
<li>sizeof不能求得动态分配的内存的大小，比如使用new分配的数组，还是会被当做指针求长度</li>
<li>当表达式作为sizeof的操作数时，它返回表达式的计算结果的类型大小，但是不会对表达式求值。</li>
<li>sizeof可以对函数调用求大小，并且求得的大小等于返回类型的大小，但是不执行函数体</li>
<li>sizeof求得的结构体（及其对象）的大小并不等于各个数据成员对象的大小之和。这里涉及到内存对齐的规则，具体如下：<br>结构体的大小等于结构体内最大成员大小的整数倍；结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍。</li>
</ul>
<h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p>尽管内存是以字节为单位，但是大部分处理器并不是按字节块来存取内存的.它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，我们将上述这些存取单位称为内存存取粒度。提高存取数据的速度。比如有的平台每次都是从偶地址处读取数据，对于一个int型的变量，若从偶地址单元处存放，则只需一个读取周期即可读取该变量；但是若从奇地址单元处存放，则需要2个读取周期读取该变量。某些平台只能在特定的地址处访问特定类型的数据，否则抛出硬件异常给操作系统。32位机器和64位的机器内存对齐中，内置类型只有指针不一样：32为4字节，64位为8字节。</p>
<h2 id="函数调用压栈过程"><a href="#函数调用压栈过程" class="headerlink" title="函数调用压栈过程"></a>函数调用压栈过程</h2><p>1.首先main函数中参数从右到左进行压栈，然后压入main函数的返回地址，如果发生函数调用，同样会压入该函数的地址，然后跳转到该函数内进行参数压栈等操作，函数返回时，参数出栈，最后会通过栈中保存的函数返回地址返回到main函数内，实现回溯过程。</p>
<h1 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h1><p>1.join函数：让一个线程阻塞在当前位置，如下：</p>
<pre><code>void fun()&#123;
    cout &lt;&lt; &quot;fun() &lt;&lt; endl;
&#125;

int main()&#123;
    thread t1(fun);
    t1.join();
    cout &lt;&lt; &quot;main() &lt;&lt; endl;
&#125;
</code></pre>
<p>此程序的打印顺序为：fun() -&gt; main()，因为t1.join()函数会自动的将主线程阻塞，直到t1线程完成，才会继续执行主线程。同时join函数还有另外一个作用，就是回收该线程的资源，如果删除掉t1.join()，最后程序会报错。</p>
<p>2.detach()函数<br>detach()函数的作用是将子线程和主线程分离，让子线程在后台独立运行，如果主线程运行的很快，子线程还未执行完的话，那么子线程会在后台继续执行，执行完毕时由线程库回收其资源。</p>
<p>3.mutex：互斥锁<br>想实现让多个线程互斥的访问某段代码，可以使用互斥锁，如下：</p>
<pre><code>mutex m;

void fun()&#123;
    m.lock();
    fun_other_thing();
    m.unlock();
&#125;
</code></pre>
<p>线程申请该互斥锁，如果成功获取，则一直拥有直到该线程调用unlock()解锁。如果无法申请到，则线程阻塞在该过程中。</p>
<p>4.lock_guard<br>在前面的代码中，如果fun_other_thing()函数的代码有问题，把么unlock()函数无法正常解锁，为了避免这种异常情况导致的无法解锁，可以使用lock_guard()自动加锁解锁，其原理和智能指针类似，会在构造函数里自动加锁，当lock_guard()出了局部作用域，会自动调用析构函数解锁。</p>
<pre><code>mutex m;

void fun()&#123;
    lock_guard&lt;mutex&gt; loc(m); //构造函数里自动加锁
    fun_other_thing();
    //出了这个局部作用域，自动解锁
&#125;
</code></pre>
<p>5.unique_lock<br>lock_guard只能保证在析构时执行解锁操作，其本身并没有提供加锁和解锁的接口，为了提高并发度，需要尽可能减少锁定的区域，也就是减少锁的粒度。unique_lock弥补了这一缺点，提供了lock()和unlock()的接口，如下例子：</p>
<pre><code>mutex m;

void fun()&#123;
    unique_lock&lt;mutex&gt; loc(m);
    fun_other_thing1();
    loc.unlock();

    fun_other_thing2();

    loc.lock();
    fun_other_thing3();
    loc.unlock();
&#125;
</code></pre>
<p>这个例子中，只锁住了fun_other_thing1()和fun_other_thing3()两个函数，减小了锁的粒度。</p>
<p>6.条件变量condition_variable<br>一般情况下，unique_lock和condition_variable配合使用，当条件变量的wait()函数被调用前，它使用unique_lock来锁住当前线程，进入wait函数后，首先会检查条件是否为真，如果不为真，则wait会阻塞并释放锁，允许其他线程继续执行，直到另外一个线程在相同的条件变量上调用了notification()来唤醒当前线程，此时返回while循环判断里。下面通过一个例子来实现三个线程的顺序执行：</p>
<pre><code>class Foo &#123;
private:
    mutex m;                      // 互斥锁
    condition_variable cd_v;      // 条件变量
    bool flag1;                   // 两个标志位
    bool flag2;
public:
    Foo() : flag1(false), flag2(false) &#123;&#125;   // 初始化两个标志位为false，表示second和third还不能打印

    void first() &#123;
        for (int i = 0; i &lt; 10; ++i) &#123;
            cout &lt;&lt; &quot;first&quot; &lt;&lt; endl;
        &#125;
        flag1 = true;        // first执行后，将flag1置为true，表示second可以打印了
        cd_v.notify_all();   // 唤醒等待队列里的所有线程
    &#125;

    void second() &#123;
        unique_lock&lt;mutex&gt; loc(m);	// 加锁
        // （1）先判断flag1是否为true，true则不会进入while循环，顺利向下执行；
        // （2）flag1为false则执行wait函数，释放锁，并进入对象cd_v的等待队列；
        // （3）当别的线程调用对象cd_v的notify_all()函数，会唤醒在等待队列中的这个线程，然后重新获得锁，继续步骤（1）
        while (flag1==false) &#123;
            cd_v.wait(loc);
        &#125;        
        for (int i = 0; i &lt; 10; ++i) &#123;
            cout &lt;&lt; &quot;second&quot; &lt;&lt; endl;
        &#125;
        flag2 = true;      // 修改flag2表示third已经可以打印了
        cd_v.notify_all(); // 唤醒等待队列里的所有线程
        // 当离开这个局部作用域时，unique_lock会调用析构函数，自动解锁
    &#125;    

    void third() &#123;
        unique_lock&lt;mutex&gt; loc(m);
        while (flag2==false) &#123;
            cd_v.wait(loc);
        &#125;
        for (int i = 0; i &lt; 10; ++i) &#123;
            cout &lt;&lt; &quot;third&quot; &lt;&lt; endl;
        &#125;
    &#125;
&#125;;


int main() &#123;
    Foo F;  
    thread(&amp;Foo::third, &amp;F).detach();
    thread(&amp;Foo::first, &amp;F).detach();
    thread(&amp;Foo::second, &amp;F).detach();               
    system(&quot;pause&quot;);   
&#125;
</code></pre>
<p>我们设置两个标志位，flag1为true表示允许second打印、flag2为true表示允许third打印，先初始化flag1、flag2为false。线程创建后，可能出现以下的执行顺序：</p>
<ul>
<li>如果在first()还未打印完时（或者压根还没开始执行时），执行second()，由于此时flag1被初始化为false，进入while循环，调用条件变量的wait函数，会将当前线程阻塞起来，并释放锁。此时需要等另一个子线程执行first()打印完毕后，将flag1设为true，然后调用notify_all()将阻塞的线程唤醒，second()才能接着执行，完成打印。</li>
<li>如果first()已经执行完毕，然后执行second()，那么flag1为true，执行second()的那个线程不会进入while循环，也不会被阻塞起来，能顺利执行。</li>
<li>third()的执行先后也可参考以上两种情况。</li>
</ul>
<p>7.wait函数<br>wait()会去检查这些条件(通过调用所提供的lambda函数)，当条件满足(lambda函数返回true)时返回。如果条件不满足(lambda函数返回false)，wait()函数将解锁互斥量，并且将这个线程(上段提到的处理数据的线程)置于阻塞或等待状态。当准备数据的线程调用notify_one()通知条件变量时，处理数据的线程从睡眠状态中苏醒，重新获取互斥锁，并且对条件再次检查，在条件满足的情况下，从wait()返回并继续持有锁。当条件不满足时，线程将对互斥量解锁，并且重新开始等待。</p>
<p>8.生产者和消费者模型<br>生产者向队列中插入数据，消费者则在生产者发出队列准备好了后接收消息，然后取出数据进行处理：</p>
<pre><code>#include &lt;pthread.h&gt;
struct msg &#123;
struct msg *m_next;
/* ... more stuff here ... */
&#125;;
struct msg *workq;
pthread_cond_t qready = PTHREAD_COND_INITIALIZER;
pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;

void process_msg(void)
&#123;
    struct msg *mp;
    for (;;) &#123;
        pthread_mutex_lock(&amp;qlock);
        while (workq == NULL)
            pthread_cond_wait(&amp;qready, &amp;qlock);
        mp = workq;
        workq = mp-&gt;m_next;
        pthread_mutex_unlock(&amp;qlock);
        /* now process the message mp */
    &#125;
&#125;

void enqueue_msg(struct msg *mp)
&#123;
    pthread_mutex_lock(&amp;qlock);
    mp-&gt;m_next = workq;
    workq = mp;
    pthread_mutex_unlock(&amp;qlock);
    pthread_cond_signal(&amp;qready);
&#125;
</code></pre>
<ul>
<li><p>为什么在wait函数前需要加锁<br>在wait函数前加锁是为了保护条件变量，调用wait函数进行等待条件的发生时，mutex会被自动释放，以供其他线程改变条件，其中两个步骤必须是原子性的：把调用线程放到条件等待队列上，以及释放锁。<br>如果不是原子性的，比如先释放锁，这时候生产者向队列中添加数据，然后signal，之后消费者线程才去把调用线程放到等待队列上，signal信号就会丢失；如果先把调用线程放到条件等待队列上，这时候另外一个线程发送了signal，然后调用线程立即获取到锁，两次获取mutex会产生deadlock。</p>
</li>
<li><p>生产者线程中修改条件为什么要加mutex<br>如果不这么做信号可能会丢失，如下：</p>
<p>  Thead A                             Thread B</p>
<p>  pthread_mutex_lock(&amp;qlock);<br>  while (workq &#x3D;&#x3D; NULL)<br>                                  mp-&gt;m_next &#x3D; workq;<br>                                  workq &#x3D; mp;<br>                                  pthread_cond_signal(&amp;cond);<br>  pthread_cond_wait(&amp;qready, &amp;qlock);</p>
</li>
</ul>
<p>在while判断之后向队列中插入数据，虽然已经有了数据，但是线程A还是调用了wait函数去等待下一个信号到来，究其原因是B线程没有获取到锁就进行了操作，应该等到wait函数释放锁之后再进行插入数据的操作。</p>
<ul>
<li><p>消费者线程中判断条件为什么要放在while中<br>一个生产者可能对应多个消费者，生产者向队列中插入一条数据之后发出signal，然后各个消费者线程的wait函数获取mutex后返回，这里只有一个线程可以成功，如果这里使用了if，那么就会在当前队列为空的状态下继续执行，显然是不合理的。</p>
</li>
<li><p>signal是放在unlock之前还是之后</p>
</li>
</ul>
<p>（1）：先unlock再signal</p>
<pre><code>void enqueue_msg(struct msg *mp)
&#123;
    pthread_mutex_lock(&amp;qlock);
    mp-&gt;m_next = workq;
    workq = mp;
    pthread_mutex_unlock(&amp;qlock);
    pthread_cond_signal(&amp;qready);
&#125;
</code></pre>
<p>如果unlock后恰好有一个消费者获取mutex，然后进入条件判断，发现队列不为空，就会跳过wait函数，那么下面的signal就会不起作用；另外一种情况，一个优先级更低的不需要条件判断的线程也正好获取到了锁，那么就会去执行这个优先级低的线程，违背了设计的初衷</p>
<p>（2）：先signal再unlock</p>
<pre><code>void enqueue_msg(struct msg *mp)
&#123;
    pthread_mutex_lock(&amp;qlock);
    mp-&gt;m_next = workq;
    workq = mp;
    pthread_cond_signal(&amp;qready);
    pthread_mutex_unlock(&amp;qlock);
&#125;
</code></pre>
<p> 如果把signal放在unlock之前，消费者线程会被唤醒，发现mutex获取不到，则又去sleep了，浪费了资源，但是在Linux下，就不会有这个问题。因为在Linux 线程中，有两个队列，分别是cond_wait队列和mutex_lock队列，cond_signal只是让线程从cond_wait队列移到mutex_lock队列，而不用返回到用户空间，不会有性能的损耗。所以在Linux中推荐使用这种模式。</p>
<h1 id="操作系统的IO分类"><a href="#操作系统的IO分类" class="headerlink" title="操作系统的IO分类"></a>操作系统的IO分类</h1><p> 1.缓冲与非缓冲IO（减少系统调用次数）</p>
<ul>
<li><p>缓冲 I&#x2F;O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。</p>
</li>
<li><p>非缓冲 I&#x2F;O，直接通过系统调用访问文件，不经过标准库缓存。<br>2.直接与非直接IO</p>
</li>
<li><p>直接 I&#x2F;O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。</p>
</li>
<li><p>非直接 I&#x2F;O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。<br>3.阻塞与非阻塞IO</p>
  <div align = "center">
      <img src = E:/Hexo/source/_posts/pic/阻塞与非阻塞IO.png> 
  </div></li>
</ul>
<h1 id="关于缓存命中"><a href="#关于缓存命中" class="headerlink" title="关于缓存命中"></a>关于缓存命中</h1><p>1.CPU cache每次加载的数据长度是固定的，比如64字节，那么即是我们只请求了4字节的数据，它也会读取64字节的内容到L1 缓存中，方便之后再请求数据的时候先从L1 缓存中查找。其中L1缓存分为数据缓存和指令缓存。</p>
<ul>
<li>提升数据缓存命中率：按照内存布局的顺序访问，比如访问二维数组，则按照行排列的方式去访问数据。</li>
<li>提升指令缓存命中率：按照有规律的分支语句可以提升CPU的分支预测器的执行效率，如果分支预测可以预测到接下来要执行 if 里的指令，还是 else 指令的话，就可以「提前」把这些指令放在指令缓存中，这样 CPU 可以直接从 Cache 读取到指令，于是执行速度就会很快。</li>
</ul>
<h1 id="伪共享的问题"><a href="#伪共享的问题" class="headerlink" title="伪共享的问题"></a>伪共享的问题</h1><p>多个线程同时读写同一个Cache Line的不同变量，而导致Cache Line失效的问题，称为伪共享。避免方法为将两个有可能地址连续的变量，使用对齐地址的方法使得二者不在一个Cache Line中，例如：</p>
<pre><code>struct test&#123;
    int a;
    int b __cacheline_aligned_in_smp;
&#125;;
</code></pre>
<h1 id="CPU对于线程的选择"><a href="#CPU对于线程的选择" class="headerlink" title="CPU对于线程的选择"></a>CPU对于线程的选择</h1><p>1.完全公平调度：CFS方法，对于普通任务，为其安排一个虚拟运行时间，如果一个任务在运行，那么运行时间越长，其虚拟运行时间就越大，如果一个任务没有被运行，其虚拟运行时间就不变。CPU优先会选择虚拟运行时间较短的任务来运行。<br>2.CPU运行队列：实际上任务数要远大于CPU核心数，这时候就需要队列来排队。每个CPU都有自己的运行队列，其中分为三个队列：Deadline运行队列，Realtime运行队列和CFS运行队列，其中CFS就是用红黑树来进行描述的，其最左侧的叶子节点就是下一次最先被调度的任务。当然这三个队列的优先级是不一样的，Deadline &gt; Realtime &gt; CFS</p>
<h1 id="C-内存优化"><a href="#C-内存优化" class="headerlink" title="C++内存优化"></a>C++内存优化</h1><p>1.编译器优化：开启O2优化选项<br>2.算法和数据结构的优化</p>
<ul>
<li>如果是确定的数据长度，主要做查询工作，建议使用数组来完成</li>
<li>如果时插入删除为主，需要使用链表的操作</li>
<li>结构体里面按照CPU位长对齐<br>3.函数优化：使用内联函数，使用引用传递或者移动语义<br>4.类：定义移动构造和移动赋值运算符，避免不必要的复制操作</li>
</ul>
<h1 id="C-中有几种类型的new"><a href="#C-中有几种类型的new" class="headerlink" title="C++中有几种类型的new"></a>C++中有几种类型的new</h1><p>1.plain new：也就是我们常用的new，其在空间分配失败的情况下返回bad_alloc而不是NULL<br>2.nothrow new：空间分配失败的情况下，不抛出异常，而是返回NULL<br>3.palcement new：主要用途就是反复使用一块较大的动态分配的内存，来构造不同类型的对象或者他们的数组，需要显式的调用析构函数来销毁，不能使用delete，因为其构造的对象或者数组的大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏，或者释放内存出现运行时错误。</p>
<h1 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h1><p>1.隐藏：编译多个文件时，没有static的全局变量和函数都具有全局可见性，而加了的只有在本文件中才可见<br>2.全局变量和static变量都在静态变量区，热着都会在程序刚开始运行就完成初始化，也是唯一一次初始化，值为0（没有给定值的情况下）<br>3.类中的static成员变量属于整个类所有，类的所有对象只有一份拷贝；类的static成员函数属于整个类所有，函数没有this指针，因而只能访问类的static成员变量<br>4.类的static成员变量必须先初始化再使用，只能在类体外进行初始化。<br>5.static成员函数不能被virtual修饰，因为static不属于任何对象或者实例，所以加virtual没有意义。况且static函数没有this指针，而虚函数的指向函数表的指针是通过this指针指向的，所以无法实现。</p>
<h1 id="类成员初始化方式？构造函数的执行顺序？为什么使用成员初始化列表会快一些"><a href="#类成员初始化方式？构造函数的执行顺序？为什么使用成员初始化列表会快一些" class="headerlink" title="类成员初始化方式？构造函数的执行顺序？为什么使用成员初始化列表会快一些"></a>类成员初始化方式？构造函数的执行顺序？为什么使用成员初始化列表会快一些</h1><p>1.初始化方式</p>
<ul>
<li>赋值初始化：通过函数体内进行赋值初始化</li>
<li>列表初始化：在冒号后使用初始化列表进行初始化<br>二者的区别：在函数体中初始化，是在所有的数据成员被分配内存空间后进行的；而列表初始化是给数据成员分配内存空间时就进行初始化，此时函数体还未执行。<br>2.一个派生类构造函数的执行顺序：</li>
<li>虚拟基类的构造函数，如果有多个，就按照继承的顺序执行构造函数</li>
<li>基类的构造函数（多个普通基类也按照继承的顺序执行构造函数）</li>
<li>类类型的成员对象的构造函数（按照初始化顺序）</li>
<li>派生类自己的构造函数<br>3.因为方法一是在构造函数中进行赋值操作，会产生临时对象，降低程序的效率。而成员初始化列表对于类类型，实际上是少了一次调用构造函数的过程，对于内置数据类型二者没有区别。</li>
</ul>
<h1 id="必须使用成员列表初始化的情况"><a href="#必须使用成员列表初始化的情况" class="headerlink" title="必须使用成员列表初始化的情况"></a>必须使用成员列表初始化的情况</h1><p>1.初始化一个引用成员<br>2.初始化一个常量成员<br>3.该类是继承一个基类，并且基类中有构造函数，构造函数有一组参数时<br>4.该类的成员变量类型是类类型，而该类类型的构造函数带参数时</p>
<h1 id="C-赋值，浅拷贝，深拷贝，零拷贝"><a href="#C-赋值，浅拷贝，深拷贝，零拷贝" class="headerlink" title="C++ 赋值，浅拷贝，深拷贝，零拷贝"></a>C++ 赋值，浅拷贝，深拷贝，零拷贝</h1><p>1.浅拷贝：只复制指向某个对象的指针，而不是复制对象本身，新旧对象还是共享同一块内存<br>2.深拷贝：会另外创造一个一样的对象，和原本的对象不共享内存，修改新对象不会修改旧对象<br>3.零拷贝：操作系统中的mmap操作</p>
<h1 id="coredump错误"><a href="#coredump错误" class="headerlink" title="coredump错误"></a>coredump错误</h1><p>程序由于异常或者bug在运行时异常退出或终止，在一定条件下生成一个叫core的文件，该文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等。</p>
<h1 id="静态类型和动态类型，静态绑定和动态绑定"><a href="#静态类型和动态类型，静态绑定和动态绑定" class="headerlink" title="静态类型和动态类型，静态绑定和动态绑定"></a>静态类型和动态类型，静态绑定和动态绑定</h1><ul>
<li>静态类型：对象在声明时采用的类型，在编译期已经确定</li>
<li>动态类型：通常是<strong>指针或者引用…</strong>目前所指向的对象类型，在运行期决定</li>
<li>静态绑定：发生在编译期，绑定的是静态类型</li>
<li>动态绑定：绑定的是动态类型，发生在运行期</li>
<li>非虚函数一般都是静态绑定，虚函数都是动态绑定</li>
</ul>
<h1 id="怎样判断两个浮点数是否相同"><a href="#怎样判断两个浮点数是否相同" class="headerlink" title="怎样判断两个浮点数是否相同"></a>怎样判断两个浮点数是否相同</h1><p>通过相减来和预先设定的精度比较</p>
<h1 id="100层，两个小球"><a href="#100层，两个小球" class="headerlink" title="100层，两个小球"></a>100层，两个小球</h1><p>每次从第k层开始，那么如果碎了，就可以从1到(k - 1)逐次扫描，<br>下一次从k + (k - 1)开始，如果碎了，那么就可以从k + 1到2k - 2，加上之前第一次也总共是K次<br>所以k + k - 1 + k - 2 … &lt;&#x3D; 100，那么k最大可以取14</p>
<h1 id="手动实现strcpy（注意异常情况）"><a href="#手动实现strcpy（注意异常情况）" class="headerlink" title="手动实现strcpy（注意异常情况）"></a>手动实现strcpy（注意异常情况）</h1><pre><code>void mystrcpy(char *dst, const char *src)&#123;
    assert(src != NULL);
    assert(dst != NULL);
    while(*dst++ = *src)&#123;
        ;
    &#125;
&#125;
</code></pre>
<p>或者 </p>
<pre><code>char* mystrcpy(char *dst, const char *src)&#123;
    assert(src != NULL);
    assert(dst != NULL);
    char* start = dst;
    while(*dst++ = *src)&#123;
        ;
    &#125;
    return start;
&#125;
</code></pre>
<h1 id="为什么析构函数一般写成虚函数"><a href="#为什么析构函数一般写成虚函数" class="headerlink" title="为什么析构函数一般写成虚函数"></a>为什么析构函数一般写成虚函数</h1><p>由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。<br>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。</p>
<h1 id="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"><a href="#基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间" class="headerlink" title="基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间"></a>基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间</h1><p>1.虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成<br>2.C++中虚函数表位于常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</p>
<h1 id="构造函数、析构函数、虚函数可否声明为内联函数"><a href="#构造函数、析构函数、虚函数可否声明为内联函数" class="headerlink" title="构造函数、析构函数、虚函数可否声明为内联函数"></a>构造函数、析构函数、虚函数可否声明为内联函数</h1><p>1.将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请&#x2F;释放内存，构造&#x2F;析构对象等），致使构造函数&#x2F;析构函数并不像看上去的那么精简。其次，class中的函数默认是inline型的，编译器也只是有选择性的inline，将构造函数和析构函数声明为内联函数是没有什么意义的。<br>2.当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下。</p>
<h1 id="C-模板是什么，你知道底层怎么实现的？"><a href="#C-模板是什么，你知道底层怎么实现的？" class="headerlink" title="C++模板是什么，你知道底层怎么实现的？"></a>C++模板是什么，你知道底层怎么实现的？</h1><p>编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译。</p>
<h1 id="构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"><a href="#构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？" class="headerlink" title="构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？"></a>构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？</h1><p>1.构造函数顺序</p>
<ul>
<li>基类构造函数。如果有多个基类，则构造函数的调用顺序是某类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。</li>
<li>成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。</li>
<li>派生类构造函数。<br>2.析构函数顺序</li>
<li>调用派生类的析构函数；</li>
<li>调用成员类对象的析构函数；</li>
<li>调用基类的析构函数。</li>
</ul>
<h1 id="单例模式的两种实现"><a href="#单例模式的两种实现" class="headerlink" title="单例模式的两种实现"></a>单例模式的两种实现</h1><p>1.懒汉方式：单例实例在第一次被使用的时候才进行初始化，称为延迟初始化</p>
<pre><code>class Singleton&#123;
private:
    Singleton()&#123;&#125;;
    ~Singleton()&#123;&#125;;
    Singleton(const Singleton&amp;);
    Singleton&amp; operator=(const Singleton&amp;);

public:
    static Singleton&amp; getInstance()&#123;
        static Singleton instance;
        return instance;
    &#125;
&#125;
</code></pre>
<p>使用了局部静态变量的方式来保证线程安全</p>
<p>2.饿汉模式：单例模式在程序运行时立即被初始化</p>
<pre><code>class Singleton&#123;
private:
    Singleton()&#123;&#125;;
    ~Singleton()&#123;&#125;;
    Singleton(const Singleton&amp;);
    Singleton&amp; operator=(const Singleton&amp;);
private:
    static Singleton instance;
public:
    static Singleton&amp; getInstance()&#123;
        return instance;
    &#125;
&#125;

//初始化
Singleton Singleton::instance;
</code></pre>
<p>问题：没有线程安全问题，但是static Singleton instance 和 static Singleton&amp; getInstance()二者的初始化顺序不确定，如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p>
<h1 id="shared-ptr的实现"><a href="#shared-ptr的实现" class="headerlink" title="shared_ptr的实现"></a>shared_ptr的实现</h1><pre><code>template&lt;typename T&gt;
class SharedPtr&#123;
public:
    SharedPtr(T* ptr = NULL):_ptr(ptr), _pCount(new int(1))&#123;&#125;
    SharedPtr(const SharedPtr&amp; s):_ptr(s._ptr), _pCount(s._pCount)&#123;
        (*_pCount)++;
    &#125;

    SharedPtr&lt;T&gt;&amp; operator=(const SharedPtr&amp; s)&#123;
        if(_ptr_ != s._ptr)&#123;
            if(--(*_pCount) == 0)&#123;
                delete _ptr;
                delete _pCount;
            &#125;
            _ptr = s._ptr;
            _pCount = s._pCount;
            (*_pcount)++;
        &#125;
        return *this;
    &#125;

    T&amp; operator*()&#123;
        return *ptr;
    &#125;

    T* operator&amp;()&#123;
        return ptr;
    &#125;

    ~Shared()&#123;
        --(*_pCount);
        if(*_pCount == 0)&#123;
            delete _ptr;
            delete _pCount;
            _ptr = nullptr;
            _pcount = nullptr;
        &#125;
    &#125;

private:
    T* _ptr;
    unsigned_int* _pCount;
&#125;
</code></pre>
<h1 id="shared-ptr指针的大小"><a href="#shared-ptr指针的大小" class="headerlink" title="shared_ptr指针的大小"></a>shared_ptr指针的大小</h1><p>8字节：一个指针，指向被保护的对象，还有一个计数类，其实现是一个指针，指向两个int类型的变量，分别是shared_ptr的引用计数和weak_ptr的数量</p>
<h1 id="vector扩容什么时候使用移动构造"><a href="#vector扩容什么时候使用移动构造" class="headerlink" title="vector扩容什么时候使用移动构造"></a>vector扩容什么时候使用移动构造</h1><p>如果vector内保存的是一个类类型，并且该类类型的移动构造函数声明为 noexcept，则会调用移动构造（浅拷贝），否则调用深拷贝，即拷贝构造，这样会大大浪费资源</p>
<h1 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h1><p>1.稳定排序：能保证两个相等的元素在排序之后前后顺序不变</p>
<ul>
<li>冒泡排序：因为每次遇到相等判断，是不会发生交换的</li>
<li>插入排序：如果比当前的最大者还大，就插在后面，遇到相等的情况，则插入到相等元素的后面，能保证顺序不变</li>
<li>归并排序：在合并的过程中，遇到两个相等的元素，会把处在前面的元素先保存，最终保证了稳定性</li>
</ul>
<p>2.不稳定排序：</p>
<ul>
<li>快速排序：在中枢元素和交界元素交换的时候会破坏稳定性</li>
<li>堆排序</li>
</ul>
<h1 id="一个很大的二维数组，里面大部分数据都是0，怎么保存"><a href="#一个很大的二维数组，里面大部分数据都是0，怎么保存" class="headerlink" title="一个很大的二维数组，里面大部分数据都是0，怎么保存"></a>一个很大的二维数组，里面大部分数据都是0，怎么保存</h1><p>可以使用数组压缩的方式来解决，压缩后的格式为：第一行保存的是原始数组的行列数，和有效数据数，接下来的每一行保存的是原始数据中某个有效数据的行列以及数值。这样使用 n * 3的数组就可以保存原来的数据</p>
<h1 id="编写String类的构造函数，析构函数和赋值函数"><a href="#编写String类的构造函数，析构函数和赋值函数" class="headerlink" title="编写String类的构造函数，析构函数和赋值函数"></a>编写String类的构造函数，析构函数和赋值函数</h1><pre><code>class String&#123;
private：
    char* m_data;
public:
    String(const char* str = nullptr)&#123;&#125;;
    String(const String&amp; str);
    ~String()&#123;&#125;;
    String&amp; operator=(const String&amp; str);
&#125;

String::String(const char* str)&#123;
    if(NULL == str)&#123;
        m_data = new char[1];
        *m_data = &#39;\0&#39;;
    &#125;else&#123;
        int len = strlen(str);
        m_data = new char[len + 1];
        strcpy_s(m_data, len + 1, str.m_data);
    &#125;
&#125;

String::String(const String&amp; str)&#123;
    int len = strlen(str.m_data);
    m_data = new char[len + 1];
    strcpy_s(m_data, len + 1, str);
&#125;

String::~String&#123;
    if(m_data != nullptr)&#123;
        delete[] m_data;
        m_data = nullptr;
    &#125;
&#125;

String&amp; String::String(const String&amp; str)&#123;
    //如果与str对象时一样的，即自赋值
    if(this == &amp;str)&#123;
        return *this;
    &#125;
    delete[] m_data;
    int len = strlen(str.m_data);
    m_data = new char[len + 1];
    strcpy_s(m_data, len + 1, str.m_data);
    return *this;
&#125;
</code></pre>
<h1 id="实现一个unique-ptr"><a href="#实现一个unique-ptr" class="headerlink" title="实现一个unique_ptr"></a>实现一个unique_ptr</h1><pre><code>template&lt;typename T&gt;
class MyUniquePtr
&#123;
public:
    MyUniquePtr(T* ptr = nullptr):mPtr(ptr)&#123;&#125;;
    ~MyUniquePtr()&#123;
        if(mPtr)&#123;
            delete mPtr;
            mPtr = nullptr;
        &#125;
    &#125;
    MyUniquePtr(MyUniquePtr &amp;&amp;P) noexcept;
    MyUniquePtr&amp; operator=(MyUniquePtr &amp;&amp;p) noexcept;

    MyUniquePtr(const MyUniquePt &amp;p) = delete;
    MyUniquePtr&amp; operator=(const MyUniquePtr &amp;p) = delete;

    void reset(T *q = nullptr) noexcept&#123;
        if(q != mPtr)&#123;
            if(mPtr)&#123;
                delete mPtr;
            &#125;
            mPtr = q;
        &#125;
    &#125;

    T* release() noexcept&#123;
        T* res = mPtr;
        mPtr = nullptr;
        return res;
    &#125;

    void swap(MyUniquePtr &amp;p) noexcept&#123;
        using std::swap;
        swap(mPtr, p.mPtr);
    &#125;

private:
    T* mPtr;
&#125;;

template &lt;typename T&gt;
MyUniquePtr&lt;T&gt;&amp; MyUniquePtr&lt;T&gt;::operator=(MyUniquePtr &amp;&amp;p) noexcept&#123;
    swap(*this, p);
    return *this;
&#125;

template &lt;typename T&gt;
MyUniquePtr&lt;T&gt;::MyUniquePtr(MyUniquePtr &amp;&amp;p) noexcept: mPtr(p.mPtr)&#123;
    p.mPtr = nullptr;
&#125;
</code></pre>
<h1 id="前序和后序不能确定二叉树"><a href="#前序和后序不能确定二叉树" class="headerlink" title="前序和后序不能确定二叉树"></a>前序和后序不能确定二叉树</h1><p>前序和后序在本质上都是将父节点与子结点进行分离,但并没有指明左子树和右子树的能力,因此得到这两个序列只能明确父子关系,而不能确定一个二叉树。</p>
<h1 id="实现LRU"><a href="#实现LRU" class="headerlink" title="实现LRU"></a>实现LRU</h1><p>struct DLinkedNode {<br>    int key, value;<br>    DLinkedNode* prev;<br>    DLinkedNode* next;<br>    &#x2F;* 构造函数便于新定义节点时初始化对象 *&#x2F;<br>    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}<br>    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}<br>};</p>
<p>class LRUCache {<br>private:<br>    unordered_map&lt;int, DLinkedNode*&gt; map;<br>    DLinkedNode* head;<br>    DLinkedNode* tail;<br>    int size;       &#x2F;&#x2F; 缓冲区使用的大小<br>    int capacity;   &#x2F;&#x2F; 缓冲区的容量</p>
<p>public:<br>    LRUCache(int _capacity): capacity(_capacity), size(0) {<br>        &#x2F;* 使用伪头部和伪尾部节点 <em>&#x2F;<br>        head &#x3D; new DLinkedNode();<br>        tail &#x3D; new DLinkedNode();<br>        head-&gt;next &#x3D; tail;<br>        tail-&gt;prev &#x3D; head;<br>    }<br>    &#x2F;</em> 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 <em>&#x2F;<br>    int get(int key) {<br>        if (!map.count(key)) return -1;<br>        &#x2F;</em> 如果 key 存在，先通过哈希表定位，再移到头部 <em>&#x2F;<br>        DLinkedNode</em> node &#x3D; map[key];<br>        moveToHead(node);<br>        return node-&gt;value;<br>    }</p>
<pre><code>void put(int key, int value) &#123;
    if (!map.count(key)) &#123;
        /* 如果 key 不存在，创建一个新的节点 */
        DLinkedNode* node = new DLinkedNode(key, value);
        /* 添加进哈希表 */
        map[key] = node;
        /* 添加至双向链表的头部 */
        addToHead(node);
        /* 缓存大小+1 */
        size++;
        if (size &gt; capacity) &#123;
            DLinkedNode* removed = removeTail();// 如果超出容量，删除双向链表的尾部节点
            map.erase(removed-&gt;key);// 删除哈希表中对应的项
            delete removed;// 防止内存泄漏
            size--;// 缓存大小-1
        &#125;
    &#125;
    else &#123;
        /* 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部 */
        DLinkedNode* node = map[key];
        node-&gt;value = value;
        moveToHead(node);
    &#125;
&#125;
</code></pre>
<p>&#x2F;<strong><strong><strong><strong><strong><strong><strong><strong>定义双向链表需要用的API函数</strong></strong></strong></strong></strong></strong></strong></strong>&#x2F;<br>public:<br>    &#x2F;* 在虚拟头节点后添加新的节点 node <em>&#x2F;<br>    void addToHead(DLinkedNode</em> node) {<br>        node-&gt;prev &#x3D; head;<br>        node-&gt;next &#x3D; head-&gt;next;<br>        head-&gt;next-&gt;prev &#x3D; node;<br>        head-&gt;next &#x3D; node;<br>    }<br>    &#x2F;* 删除当前节点 node 这里也是为什么使用双向链表的原因方便删除节点 <em>&#x2F;<br>    void removeNode(DLinkedNode</em> node) {<br>        node-&gt;prev-&gt;next &#x3D; node-&gt;next;<br>        node-&gt;next-&gt;prev &#x3D; node-&gt;prev;<br>    }<br>    &#x2F;* 把出现频率比较高的节点放入 头部 <em>&#x2F;<br>    void moveToHead(DLinkedNode</em> node) {<br>        removeNode(node);<br>        addToHead(node);<br>    }<br>    &#x2F;* 移除尾部节点 并返回尾部最后一个节点 <em>&#x2F;<br>    DLinkedNode</em> removeTail() {<br>        DLinkedNode* node &#x3D; tail-&gt;prev;<br>        removeNode(node);<br>        return node;<br>    }<br>};</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>void Quick_Sort(int *arr, int begin, int end){<br>    if(begin &gt; end)<br>        return;<br>    int tmp &#x3D; arr[begin];<br>    int i &#x3D; begin;<br>    int j &#x3D; end;<br>    while(i !&#x3D; j){<br>        while(arr[j] &gt;&#x3D; tmp &amp;&amp; j &gt; i)<br>            j–;<br>        while(arr[i] &lt;&#x3D; tmp &amp;&amp; j &gt; i)<br>            i++;<br>        if(j &gt; i){<br>            int t &#x3D; arr[i];<br>            arr[i] &#x3D; arr[j];<br>            arr[j] &#x3D; t;<br>        }<br>    }<br>    arr[begin] &#x3D; arr[i];<br>    arr[i] &#x3D; tmp;<br>    Quick_Sort(arr, begin, i-1);<br>    Quick_Sort(arr, i+1, end);<br>}</p>
<h1 id="stl常用容器在内存中的位置"><a href="#stl常用容器在内存中的位置" class="headerlink" title="stl常用容器在内存中的位置"></a>stl常用容器在内存中的位置</h1><ul>
<li>在栈区定义容器变量，变量本身存储在栈区，但是变量存储的数据在堆区；</li>
<li>在堆空间定义的容器变量，变量本身存储在堆区，存储的数据也在堆区；</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gaotf</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
