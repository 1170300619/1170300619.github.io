<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="热爱技术，笔耕不辍">
<meta property="og:type" content="website">
<meta property="og:title" content="漱石斋笔谈">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="漱石斋笔谈">
<meta property="og:description" content="热爱技术，笔耕不辍">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="gaotf">
<meta property="article:tag" content="PostgreSQL">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>漱石斋笔谈</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">漱石斋笔谈</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">gaotf 的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gaotf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">gaotf</p>
  <div class="site-description" itemprop="description">热爱技术，笔耕不辍</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/1170300619" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1170300619" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3469205806@qq.com" title="E-Mail → 3469205806@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/04/19/%E4%BD%BF%E7%94%A8pthread%E6%9E%84%E5%BB%BA%E5%9B%BA%E5%AE%9A%E6%AD%BB%E9%94%81%E5%9C%BA%E6%99%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/19/%E4%BD%BF%E7%94%A8pthread%E6%9E%84%E5%BB%BA%E5%9B%BA%E5%AE%9A%E6%AD%BB%E9%94%81%E5%9C%BA%E6%99%AF/" class="post-title-link" itemprop="url">使用pthread构建固定死锁场景</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-19 00:00:00" itemprop="dateCreated datePublished" datetime="2024-04-19T00:00:00+08:00">2024-04-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:47:50" itemprop="dateModified" datetime="2024-04-26T10:47:50+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PostgresSQL/" itemprop="url" rel="index"><span itemprop="name">PostgresSQL</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PostgresSQL/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">多线程</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PostgresSQL/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%AD%BB%E9%94%81/" itemprop="url" rel="index"><span itemprop="name">死锁</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用pthread中的条件变量和锁，构建了一个可以模拟死锁的脚本，能实现每个线程按顺序执行，从而形成固定死锁场景，方便测试死锁算法性能，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &quot;libpq-fe.h&quot;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define RING_TRANS_NUM 5</span><br><span class="line">#define OTHER_TRANS_NUM 10</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">pthread_cond_t conds[RING_TRANS_NUM + OTHER_TRANS_NUM];</span><br><span class="line">static int turn = 0;  // 当前执行的线程编号</span><br><span class="line"></span><br><span class="line">typedef struct Tag</span><br><span class="line">&#123;</span><br><span class="line">    int row_id;</span><br><span class="line">    int thread_id;</span><br><span class="line">&#125;Tag;</span><br><span class="line"></span><br><span class="line">enum cn_port &#123;</span><br><span class="line">    cn01 = 1,</span><br><span class="line">    cn02 = 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void free_and_end_trans(PGconn *conn, PGresult *res)</span><br><span class="line">&#123;</span><br><span class="line">    if(res != NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        PQclear(res);</span><br><span class="line">    &#125;</span><br><span class="line">    PQfinish(conn);</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *other_thread_function(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    PGconn *conn = NULL;</span><br><span class="line">    PGresult *res = NULL;</span><br><span class="line">    char conn_info[100];</span><br><span class="line">    int cur_port = rand() % 2 + cn01;</span><br><span class="line"></span><br><span class="line">    snprintf(conn_info, sizeof(conn_info),</span><br><span class="line">             &quot;dbname = postgres user = gaotianfu password = 129212351GTFgtf_ host = 127.0.0.1 port = %d&quot;, cur_port);</span><br><span class="line"></span><br><span class="line">    conn = PQconnectdb(conn_info);</span><br><span class="line">    if (PQstatus(conn) != CONNECTION_OK) &#123;</span><br><span class="line">        free_and_end_trans(conn, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 开启事务 */</span><br><span class="line">    res = PQexec(conn, &quot;BEGIN&quot;);</span><br><span class="line">    if (PQresultStatus(res) != PGRES_COMMAND_OK) &#123;</span><br><span class="line">        free_and_end_trans(conn, res);</span><br><span class="line">    &#125;</span><br><span class="line">    PQclear(res);</span><br><span class="line"></span><br><span class="line">    Tag *tag = (Tag *)arg;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    while (turn != tag-&gt;thread_id) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;conds[tag-&gt;thread_id], &amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    turn = turn == (RING_TRANS_NUM + OTHER_TRANS_NUM - 1) ? (RING_TRANS_NUM - 1) : turn + 1;</span><br><span class="line">    pthread_cond_signal(&amp;conds[turn]); // 通知下一个线程</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    char update_query[100];</span><br><span class="line">    snprintf(update_query, sizeof(update_query), &quot;UPDATE a SET str = &#x27;11&#x27; WHERE id = %d&quot;,  tag-&gt;row_id);</span><br><span class="line">    free(tag);</span><br><span class="line">    res = PQexec(conn, update_query);</span><br><span class="line">    if (PQresultStatus(res) == PGRES_COMMAND_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        PQclear(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = PQexec(conn, &quot;END&quot;);</span><br><span class="line">    free_and_end_trans(conn, res);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *ring_thread_function(void *arg) &#123;</span><br><span class="line">    PGconn *conn = NULL;</span><br><span class="line">    PGresult *res = NULL;</span><br><span class="line">    char conn_info[100];</span><br><span class="line">    int cur_port = rand() % 2 + cn01;</span><br><span class="line"></span><br><span class="line">    snprintf(conn_info, sizeof(conn_info),</span><br><span class="line">             &quot;dbname = xxx user = xxx password = xxx host = xxx port = %d&quot;, cur_port);</span><br><span class="line"></span><br><span class="line">    conn = PQconnectdb(conn_info);</span><br><span class="line">    if (PQstatus(conn) != CONNECTION_OK) &#123;</span><br><span class="line">        free_and_end_trans(conn, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 开启事务 */</span><br><span class="line">    res = PQexec(conn, &quot;BEGIN&quot;);</span><br><span class="line">    if (PQresultStatus(res) != PGRES_COMMAND_OK) &#123;</span><br><span class="line">        free_and_end_trans(conn, res);</span><br><span class="line">    &#125;</span><br><span class="line">    PQclear(res);</span><br><span class="line"></span><br><span class="line">    Tag *tag = (Tag *)arg;</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; 2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        while (turn != tag-&gt;thread_id) &#123;</span><br><span class="line">            pthread_cond_wait(&amp;conds[tag-&gt;thread_id], &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">//        printf(&quot;%lu  my_thread_id is %d, ture is %d &quot;,pthread_self(), tag-&gt;thread_id, turn);</span><br><span class="line"></span><br><span class="line">        char update_query[100];</span><br><span class="line">        snprintf(update_query, sizeof(update_query), &quot;UPDATE a SET str = &#x27;11&#x27; WHERE id = %d&quot;,  tag-&gt;row_id);</span><br><span class="line"></span><br><span class="line">        if(i == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            turn = turn == (RING_TRANS_NUM - 2) ?  RING_TRANS_NUM: turn + 1; // 倒数第二个 ring_thread 通知 other_thread</span><br><span class="line">            pthread_cond_signal(&amp;conds[turn]);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            printf(&quot;the %d time, %lu  update %d, signal  %d\n&quot;, i, pthread_self(), tag-&gt;row_id, turn);</span><br><span class="line">        &#125;</span><br><span class="line">        res = PQexec(conn, update_query);</span><br><span class="line">        if (PQresultStatus(res) == PGRES_COMMAND_OK)</span><br><span class="line">        &#123;</span><br><span class="line">            if((tag-&gt;row_id == RING_TRANS_NUM + 1) &amp;&amp; (i == 1))</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot; make deadlock\n&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot; %lu update %d\n&quot;, pthread_self(), tag-&gt;row_id);</span><br><span class="line">            &#125;</span><br><span class="line">            PQclear(res);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i == 1)</span><br><span class="line">        &#123;</span><br><span class="line">            free(tag);</span><br><span class="line">        &#125;</span><br><span class="line">        if(i == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            tag-&gt;row_id = (tag-&gt;row_id == RING_TRANS_NUM) ? 1 : tag-&gt;row_id + 1;</span><br><span class="line">            turn = turn == (RING_TRANS_NUM - 1) ? 0 : (turn % RING_TRANS_NUM) + 1;</span><br><span class="line">            pthread_cond_signal(&amp;conds[turn]); // 通知下一个线程</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            printf(&quot;the %d time, %lu , signal  %d\n&quot;, i, pthread_self(), turn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = PQexec(conn, &quot;END&quot;);</span><br><span class="line">    free_and_end_trans(conn, res);</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    for (int i = 0; i &lt; RING_TRANS_NUM + OTHER_TRANS_NUM; ++i) &#123;</span><br><span class="line">        pthread_cond_init(&amp;conds[i], NULL); // 初始化条件变量</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_t *ring_thread;</span><br><span class="line">    ring_thread = (pthread_t *) malloc(sizeof(pthread_t) * RING_TRANS_NUM);</span><br><span class="line"></span><br><span class="line">    pthread_t *other_thread;</span><br><span class="line">    other_thread = (pthread_t *) malloc(sizeof(pthread_t) * OTHER_TRANS_NUM);</span><br><span class="line"></span><br><span class="line">    /* 形成依赖 */</span><br><span class="line">    for(int i = 0; i &lt; RING_TRANS_NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Tag *cur_tag = (Tag *) malloc(sizeof(Tag));</span><br><span class="line">        cur_tag-&gt;row_id = i + 1;</span><br><span class="line">        cur_tag-&gt;thread_id = i;</span><br><span class="line">        pthread_create(&amp;ring_thread[i], NULL, ring_thread_function, (void *) cur_tag);</span><br><span class="line">        pthread_detach(ring_thread[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* 其他依赖 */</span><br><span class="line">    for(int i = 0; i &lt; OTHER_TRANS_NUM; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Tag *cur_tag = (Tag *) malloc(sizeof(Tag));</span><br><span class="line">        cur_tag-&gt;row_id = 2;  /* 只更新第 2 行 */</span><br><span class="line">        cur_tag-&gt;thread_id = i + RING_TRANS_NUM;</span><br><span class="line">        pthread_create(&amp;other_thread[i], NULL, other_thread_function, (void *) cur_tag);</span><br><span class="line">        pthread_detach(other_thread[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        sleep(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面的代码实现的效果为，首先形成一个长依赖路径，路径上的每个事务都更新自己的数据行，例如第一个事务更新第一行数据，第二个事务更新第二行数据，第<code>RING_TRANS_NUM</code>个事务更新第<code>RING_TRANS_NUM</code>行数据，此时通知第一个事务所在的线程去更新第二行数据，第二个事务去更新第三行数据，直到第<code>RING_TRANS_NUM - 1</code>个事务更新第<code>RING_TRANS_NUM</code>行数据。这样就形成了长依赖路径。</p>
<p>然后添加其他依赖，这些依赖依附于上述长依赖路径，本程序中设置其他依赖都更新第二行数据。当这些其他依赖都执行完事务语句时，通知第<code>RING_TRANS_NUM</code>个事务所在的线程去更新第一行数据，最终形成了死锁环。</p>
<script src="https://utteranc.es/client.js"
        repo="1170300619/170300619.github.io"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/26/git%E5%B8%B8%E7%94%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%8F%8A%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/07/26/git%E5%B8%B8%E7%94%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%8F%8A%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">git常用工作流及命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-07-26 20:41:21" itemprop="dateCreated datePublished" datetime="2023-07-26T20:41:21+08:00">2023-07-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:53:29" itemprop="dateModified" datetime="2024-04-26T10:53:29+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/git/" itemprop="url" rel="index"><span itemprop="name">git</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-git仓库的结构"><a href="#1-git仓库的结构" class="headerlink" title="1. git仓库的结构"></a>1. git仓库的结构</h1><p>首先介绍以下几个术语：</p>
<ul>
<li>remote：表示远程仓库</li>
<li>repository：表示本地仓库</li>
<li>workspace：表示自己项目的工作区间</li>
<li>index：暂存区，接下来可以commit</li>
</ul>


<h1 id="2-工作流"><a href="#2-工作流" class="headerlink" title="2. 工作流"></a>2. 工作流</h1><p>推荐使用 <strong>github flow</strong> 的工作模式，即不在主仓库的分支上开发，而是首先 <strong>fork</strong> 到自己的 <strong>workspace</strong> 下。每次开发，首先 <strong>checkout</strong> 一个分支，开发后 <strong>commit</strong>，并 <strong>push</strong> 到自己的仓库内，再向主仓库提 <strong>MR</strong>。</p>
<h2 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork"></a>2.1 fork</h2><p>一般主仓库是组长建立的，保存着所有人开发的代码，为了防止污染导致数据丢失问题，剩下的小组成员需要对主仓库进行 <strong>fork</strong>，即将其拷贝一份到自己账户下，这样之后的开发工作就可以从自己的仓库开始。</p>
<h2 id="2-2-clone"><a href="#2-2-clone" class="headerlink" title="2.2 clone"></a>2.2 clone</h2><p>接下来从自己的仓库进行clone。需要注意的是，一般一个仓库都有多个分支，比如有 <strong>master</strong> 主分支和 <strong>develop</strong> 分支，所以 <strong>clone</strong> 时要找到对应的分支，例如要克隆 <strong>develop</strong> 分支，使用的命令如下：</p>
<pre><code>git clone -b develop ssh链接
</code></pre>
<p>命令中 <strong>ssh</strong> 链接需要填写自己仓库下的 <strong>ssh</strong> 链接。</p>
<h2 id="2-3-添加远程仓库"><a href="#2-3-添加远程仓库" class="headerlink" title="2.3 添加远程仓库"></a>2.3 添加远程仓库</h2><p>在项目的根目录重新打开 <strong>git bash</strong>，首先输入 <strong>git remote -v</strong> 来查看现有的仓库</p>


<p>其中的 <strong>origin</strong> 表示是自己的远程仓库名称，一个用来 <strong>fetch</strong>，一个用来 <strong>push</strong>。接下来需要将组长的主仓库添加进来，使用的命令为：</p>
<pre><code>git remote add upstream 主仓库ssh链接
</code></pre>
<p>其中upstream是给主仓库起的名字，这个名字可以是任意的。再次查看当前的远程仓库：</p>


<h2 id="2-4-拉取最新代码"><a href="#2-4-拉取最新代码" class="headerlink" title="2.4 拉取最新代码"></a>2.4 拉取最新代码</h2><p>由于主仓库是合并开发，因此其代码进度是最快的，在每次开发前，都需要从主仓库拉取最新的代码，例如要从主仓库拉取 <strong>develop</strong> 分支的最新代码。这里有两种方式，第一种是使用 <strong>git fetch + git merge</strong> 的组合方式，好处是可以在 <strong>fetch</strong> 后查看更新，从而在 <strong>merge</strong> 的时候更方便的解决潜在的代码冲突；第二种方式是使用 <strong>git pull</strong>，它会立即拉取远程仓库的更新，并且直接合并到你的本地分支，这种情况下会导致合并后的代码产生大量冲突，解决起来很麻烦。因此推荐使用第一种组合方式。使用的命令为：</p>
<pre><code>git fetch upstream develop
</code></pre>
<p>由于我们之前已经在本地拉取了 <strong>develop</strong> 分支，因此上面的 <strong>git fetch</strong> 命令是不创建本地新分支的方式，然后使用如下代码查看版本的差异</p>
<pre><code>git log -p develop..upstream/develop
</code></pre>
<p>或者</p>
<pre><code>git diff develop
</code></pre>
<p>然后使用如下代码进行合并</p>
<pre><code>git merge upstream/develop
</code></pre>
<p>需要注意的是，合并过程中可能出现冲突的情况，我们可以对冲突的文件进行编辑。冲突的产生是多个用户同时修改了同一个文件的相同区域的内容。具体会发生冲突的情况和解决方法可以查看<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27905183/article/details/78575247">git中发生冲突的原因和解决方案</a>。</p>
<h2 id="2-5-开发"><a href="#2-5-开发" class="headerlink" title="2.5 开发"></a>2.5 开发</h2><p>通过输入 <strong>git branch</strong> 可以查看当前处于哪个分支；输入 <strong>git branch -a</strong> 可以查看所有的本地分支和远程分支；以及可以输入 <strong>git status</strong> 来查看当前分支和分支的状态。</p>
<h2 id="2-6-新建分支"><a href="#2-6-新建分支" class="headerlink" title="2.6 新建分支"></a>2.6 新建分支</h2><p>有了最新的代码，就可以开始着手写代码了。但是需要注意，不要直接在本地的develop分支上直接写，而是要新建一个分支，使用如下命令：</p>
<pre><code>git checkout -b check # (分支名称，随意)
</code></pre>
<p>这样我们就新建了一个check分支，且直接切换到其上，上面的代码其实做了两件事：</p>
<pre><code>git branch check # 新建 check 分支
git checkout check # 切换到 check 分支上
</code></pre>
<h2 id="2-7-贮藏代码"><a href="#2-7-贮藏代码" class="headerlink" title="2.7 贮藏代码"></a>2.7 贮藏代码</h2><p>当你想提交代码时，始终要记得，主仓库内的代码可能还是比你的进展要更快，因此你还需要到主仓库中拉取最新的代码，这里需要你先把当前的进度 commit 到本地暂存区，或者使用 git stash，将代码贮藏来保管当前的进度。使用的命令为：</p>
<pre><code>git stash save &quot;save message&quot;
</code></pre>
<p>然后切换到 develop 分支上，还是使用 git fetch 和 git merge 去拉取合并最新的代码。贮藏的代码实际上被储存在一个栈上，越晚贮藏的越接近栈顶，可以使用如下代码查看栈中贮藏的信息：</p>
<pre><code>git stash list
</code></pre>


<p>可以看到有三个贮藏，使用如下命令可以将栈顶的贮藏重新应用</p>
<pre><code>git stash apply
</code></pre>
<p>如果想应用其中一个更早的贮藏，可以通过名字来指定</p>
<pre><code>git stash apply stash@&#123;2&#125;
</code></pre>
<p>如上的命令只会尝试应用贮藏的工作，意味着堆栈上还有它，可以使用如下命令将贮藏从堆栈上移除：</p>
<pre><code>git stash drop stash@&#123;2&#125;
</code></pre>
<p>或者可以使用如下代码来应用栈顶的贮藏，并且将其从栈顶弹出</p>
<pre><code>git stash pop
</code></pre>
<p>最后记得要将 check 分支合并到本地的 develop 分支上，之后的操作都要在 develop 上进行。使用的命令如下：</p>
<pre><code>git checkout develop
git merge check
</code></pre>
<h2 id="2-8-提交和推送"><a href="#2-8-提交和推送" class="headerlink" title="2.8 提交和推送"></a>2.8 提交和推送</h2><p>接下来要将代码提交到本地仓库，首先查看代码的状态</p>
<pre><code>git diff # 可以查看到这次的改动内容，按 q 退出
</code></pre>
<p>然后使用跟踪所有的文件</p>
<pre><code>git add .
</code></pre>
<p>随后提交到暂存区</p>
<pre><code>git commit -m &quot;add a new txt file&quot;
</code></pre>
<p>随后就可以推送到自己的远程仓库</p>
<pre><code>git push origin HEAD:分支名称
</code></pre>
<p>这里的 HEAD 指的是当前分支，冒号后面指的是要 push 的分支，如果远程仓库没有，则会自动创建该分支</p>
<h2 id="2-9-提MR"><a href="#2-9-提MR" class="headerlink" title="2.9 提MR"></a>2.9 提MR</h2><p>在自己的远程仓库内，可以向主仓库提交分支合并请求，一般是自己的 develop 分支合并到主仓库的 develop 分支，如下时 gitlab 的示例：<br>、</p>


<p>接下来可以增加这次合并请求的描述，加 title 和 description等，之后就可以 submit 提交。<br>分支合并请求通过后，可以选择将本地的 check 分支删除</p>
<pre><code>git branch -d check
</code></pre>
<h2 id="2-10-注意点"><a href="#2-10-注意点" class="headerlink" title="2.10 注意点"></a>2.10 注意点</h2><p>如果有项目伙伴因需求更改了项目文件名称或是一些文件夹的名称，需要告知所有在工作中的伙伴停下手中的工作，等待文件名称修改后，push到仓库后，其他伙伴再拉新的代码，再进行工作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/09/25/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">数据库笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-25 14:24:51" itemprop="dateCreated datePublished" datetime="2022-09-25T14:24:51+08:00">2022-09-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:48:15" itemprop="dateModified" datetime="2024-04-26T10:48:15+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">总结笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="关系型数据库和非关系型数据库的区别"><a href="#关系型数据库和非关系型数据库的区别" class="headerlink" title="关系型数据库和非关系型数据库的区别"></a>关系型数据库和非关系型数据库的区别</h1><p>1.关系型数据库：指用关系模型来组织数据信息的数据库<br>关系模型指的是二维表格模型，而一个关系型数据库便是由二维表以及表之间的关系所构成的一个数据集合。<br>2.关系型数据库的优势：</p>
<ul>
<li>便于理解：二维表构造非常贴近逻辑；</li>
<li>应用方便：支持通用的SQL（结构化查询语言）语句；</li>
<li>易于维护：全部由表结构组成，文件格式一致；</li>
<li>复杂操作：可以用SQL句子多个表之间做非常繁杂的查询；</li>
<li>事务管理：促使针对安全性性能很高的数据信息浏览规定得到完成。<br>3.关系型数据库存在的不足</li>
<li>读写性能差，尤其是海量信息的效率高读写能力；</li>
<li>固定不动的表构造，灵便度稍欠；</li>
<li>高并发读写时，硬盘I&#x2F;O存在瓶颈；</li>
<li>可扩展性不足，不像web server和app server那样简单的添- 加硬件和服务节点来拓展性能和负荷工作能力。</li>
</ul>
<p>4.非关系型数据库概念介绍<br>非关系型数据库：指非关系型的，分布式系统的，且一般不确保遵照ACID标准的数据储存系统。<br>非关系型数据库算是一种数据结构化储存的集合，可以是文档或键值对等。<br>5.非关系型数据库的类型：</p>
<ul>
<li>键值储存数据库</li>
<li>列储存数据库</li>
<li>文档型数据库</li>
<li>图数据库<br>6.非关系型数据库的优点</li>
<li>格式灵活：数据存储格式非常多样，应用领域广泛，而关系型数据库则只适用基础的关系模型。</li>
<li>性能优越：NOSQL是根据键值对的，不用历经SQL层的分析，因此 性能非常高。</li>
<li>可扩展性：基于键值对，数据之间耦合度极低，因此容易水平扩展。</li>
<li>低成本：非关系型数据库部署简易，且大部分可以开源使用。<br>6.非关系型数据库的不足：</li>
<li>不支持sql，学习和运用成本比较高；</li>
<li>无事务处理机制；</li>
<li>数据结构导致复杂查询不容易实现。</li>
</ul>
<h1 id="为什么使用索引"><a href="#为什么使用索引" class="headerlink" title="为什么使用索引"></a>为什么使用索引</h1><ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机IO变为顺序IO。</li>
</ul>
<h1 id="执行一条SQL查询语句期间发生了什么"><a href="#执行一条SQL查询语句期间发生了什么" class="headerlink" title="执行一条SQL查询语句期间发生了什么"></a>执行一条SQL查询语句期间发生了什么</h1><p>1.连接器：建立连接，管理连接、校验用户身份；<br>2.查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；<br>3.解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；<br>4.执行 SQL：执行 SQL 共有三个阶段：</p>
<ul>
<li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li>
<li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li>
<li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li>
</ul>
<h1 id="MyISAM和InnoDB实现B树索引方式的区别是什么？"><a href="#MyISAM和InnoDB实现B树索引方式的区别是什么？" class="headerlink" title="MyISAM和InnoDB实现B树索引方式的区别是什么？"></a>MyISAM和InnoDB实现B树索引方式的区别是什么？</h1><p>1.MyISAM，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值，然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”<br>2.InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<br>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h1 id="Innodb为什么要用自增id作为主键？"><a href="#Innodb为什么要用自增id作为主键？" class="headerlink" title="Innodb为什么要用自增id作为主键？"></a>Innodb为什么要用自增id作为主键？</h1><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。</p>
<h1 id="你了解MySQL的内部构造吗？一般可以分为哪两个部分？"><a href="#你了解MySQL的内部构造吗？一般可以分为哪两个部分？" class="headerlink" title="你了解MySQL的内部构造吗？一般可以分为哪两个部分？"></a>你了解MySQL的内部构造吗？一般可以分为哪两个部分？</h1><p>1.服务层包括连接器、查询缓存、分析器、优化器、执行器等<br>2.存储引擎层负责数据的存储和提取</p>
<h1 id="说一说Drop、Delete与Truncate的共同点和区别"><a href="#说一说Drop、Delete与Truncate的共同点和区别" class="headerlink" title="说一说Drop、Delete与Truncate的共同点和区别"></a>说一说Drop、Delete与Truncate的共同点和区别</h1><p>Drop、Delete、Truncate都表示删除，但是三者有一些差别： Delete用来删除表的全部或者一部分数据行，执行delete之后，用户需要提交(commmit)或者回滚(rollback)来执行删除或者撤销删除，会触发这个表上所有的delete触发器。 Truncate删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器，TRUNCATE比delete更快，占用的空间更小。 Drop命令从数据库中删除表，所有的数据行，索引和权限也会被删除，所有的DML触发器也不会被触发，这个命令也不能回滚。<br>因此，在不再需要一张表的时候，用Drop；在想删除部分数据行时候，用Delete；在保留表而删除所有数据的时候用Truncate。</p>
<h1 id="文件索引和数据库索引为什么使用B-树"><a href="#文件索引和数据库索引为什么使用B-树" class="headerlink" title="文件索引和数据库索引为什么使用B+树?"></a>文件索引和数据库索引为什么使用B+树?</h1><p>1.文件与数据库都是需要较大的存储，也就是说，它们都不可能全部存储在内存中，故需要存储到磁盘上。而所谓索引，则为了数据的快速定位与查找，那么索引的结构组织要尽量减少查找过程中磁盘I&#x2F;O的存取次数，因此B+树相比B树更为合适。数据库系统巧妙利用了局部性原理与磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I&#x2F;O就可以完全载入<br>2.最重要的是，B+树还有一个最大的好处：方便扫库。B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持，这是数据库选用B+树的最主要原因。<br>3.B+tree的磁盘读写代价更低：B+tree的内部结点并没有指向关键字具体信息的指针(红色部分)，因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一块盘中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多，相对来说IO读写次数也就降低了</p>
<h1 id="数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗"><a href="#数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗" class="headerlink" title="数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗"></a>数据库为什么要进行分库和分表呢？都放在一个库或者一张表中不可以吗</h1><p>通过分表，可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用</p>
<ul>
<li>水平分表：取模分表就属于随机分表，而时间维度分表则属于连续分表。 如何设计好垂直拆分，我的建议：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。 对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。</li>
<li>库内分表，仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等。</li>
</ul>
<h1 id="索引失效的情况"><a href="#索引失效的情况" class="headerlink" title="索引失效的情况"></a>索引失效的情况</h1><p>1.对索引使用左或者左右模糊匹配：因为B+树是按照索引值有序排列的，只能根据前缀进行比较<br>2.对索引使用函数：不过可以针对函数计算后的值建立一个索引，从而使得该索引的值是函数计算后的值，就可以通过扫描索引来查询数据<br>3.对索引使用表达式计算<br>4.对索引隐式类型转换<br>5.联合索引非最左匹配<br>6.WHEREA子句中的OR</p>
<h1 id="数据库事务是什么，都有哪些操作？"><a href="#数据库事务是什么，都有哪些操作？" class="headerlink" title="数据库事务是什么，都有哪些操作？"></a>数据库事务是什么，都有哪些操作？</h1><p>事务即为数据库的操作序列，要么完全执行，要么完全不执行。满足ACID属性。<br>A:原子性：要么全做，要么全不做<br>C：一致性：即事务操作前后满足完整性约束，比如A给B转账，完成后，A的少了200元，B的多了200元<br>I：隔离性：事务可以是并发的，隔离性可以保证多个事务并发执行由于使用相同的数据而互不干扰。每个事务都有自己的数据空间。<br>D：持久性：事务完成后，对数据的修改是永久的，即使系统故障也不会丢失。<br>事务的操作：开启事务，回滚，提交。其中回滚在数据没有提交之前可以回滚到之前的版本。</p>
<h1 id="脏读，幻读，不可重复读的概念"><a href="#脏读，幻读，不可重复读的概念" class="headerlink" title="脏读，幻读，不可重复读的概念"></a>脏读，幻读，不可重复读的概念</h1><p>1.脏读：一个事务读到了另一个未提交事务修改过的数据（因为此时第二个事务有可能发生回滚操作）<br>2.不可重复读：在一个事务内多次读取同一个数据，出现了两次读到的数据不一样的情况（比如A在读一个数据时，B修改了这个数据，当A再次读这个数据时，读到的数据和上一次不一样）<br>3.幻读：在一个事务内多次查询某个符合查询条件的记录数量，前后两次记录数量不一样（比如数据增加或者被删除）</p>
<p>三者的严重程度：脏读 &gt; 不可重复读 &gt; 幻读</p>
<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><p>1.读未提交：一个事务还没提交时，其所做的变更就可以被其它事务看到（会发生脏读，不可重复读和幻读）<br>2.读提交：一个事务提交后，它所做的变更才能被其它事务看到（会发生不可重复读和幻读）<br>3.可重复读：一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据一样（InnoDB默认的隔离级别）（会发生幻读）<br>4.串行化：会对记录加上读写锁，后访问的事务必须等前面的事务处理完才能继续执行。</p>
<h1 id="MYSQL有哪些锁"><a href="#MYSQL有哪些锁" class="headerlink" title="MYSQL有哪些锁"></a>MYSQL有哪些锁</h1><p>1.全局锁：使得整个数据库处于只读状态<br>2.表级锁：</p>
<ul>
<li>表锁：分为读锁（共享锁）和写锁（独占锁）</li>
<li>元数据锁（MDL)：对数据库表进行操作时，会自动的给这个表加上MDL，在事务提交后释放。</li>
<li>意向锁：</li>
</ul>
<h1 id="MySQL如何实现事务提交和回滚"><a href="#MySQL如何实现事务提交和回滚" class="headerlink" title="MySQL如何实现事务提交和回滚"></a>MySQL如何实现事务提交和回滚</h1><p>1.实现数据恢复：redo log<br>redo log分为两部分：</p>
<ul>
<li>内存中的redo log Buffer是日志缓冲区，这部分数据是容易丢失的</li>
<li>磁盘上的redo log file是日志文件，这部分数据已经持久化到磁盘，不容易丢失<br>在MySQL中可以自已控制log buffer刷新到log file中的频率，通过innodb_flush_log_at_trx_commit参数可以设置事务提交时log buffer如何保存到log file中，innodb_flush_log_at_trx_commit参数有3个值(0、1、2)，表示三种不同的方式</li>
<li>为1表示事务每次提交都会将log buffer写入到os buffer，并调用操作系统的fsync()方法将日志写入log file，这种方式的好处是就算MySQL崩溃也不会丢数据，redo log file保存了所有已提交事务的日志，MySQL重新启动后会通过redo log file进行恢复。但这种方式每次提交事务都会写入磁盘，IO性能较差</li>
<li>为0表示事务提交时不会将log buffer写入到os buffer中，而是每秒写入os buffer然后调用fsync()方法将日志写入log file，这种方式在MySQL系统崩溃时会丢失大约1秒钟的数据</li>
<li>为2表示事务每次提交仅将log buffer写入到os buffer中，然后每秒调用fsync()方法将日志写入log file，这种方式在MySQL崩溃时也会丢失大约1秒钟的数据</li>
</ul>
<p>2.undo log<br>和redo log类似，也分为内存缓冲区和磁盘的日志文件，但是undo log记录的是相反的语句，当事务需要回滚的时候，可以从undo log中找到相应的内容进行回滚操作。</p>
<p>3.二者的区别<br>为了保证数据的持久性，数据库在执行SQL操作数据之前会先记录redo log和undo log<br>redo log是重做日志，通常是物理日志，记录的是物理数据页的修改，它用来恢复提交后的物理数据页<br>undo log是回滚日志，用来回滚行记录到某个版本，undo log一般是逻辑日志，根据行的数据变化进行记录<br>redo&#x2F;undo log都是写先写到日志缓冲区，再通过缓冲区写到磁盘日志文件中进行持久化保存<br>undo日志还有一个用途就是用来控制数据的多版本（MVCC）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/20/http%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/20/http%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">http详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-20 20:10:51" itemprop="dateCreated datePublished" datetime="2022-08-20T20:10:51+08:00">2022-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:53:49" itemprop="dateModified" datetime="2024-04-26T10:53:49+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/http%E5%8D%8F%E8%AE%AE/" itemprop="url" rel="index"><span itemprop="name">http协议</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/http%E5%8D%8F%E8%AE%AE/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">总结笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="http请求报文"><a href="#http请求报文" class="headerlink" title="http请求报文"></a>http请求报文</h1><p>http请求报文由请求行、请求头部、空行 和 请求包体 4 个部分组成，如下图所示：</p>


<ol>
<li>请求行：请求行由方法字段、URL字段和HTTP协议版本3个部分组成，下面主要介绍一下GET和POST方法：</li>
</ol>
<ul>
<li><p>GET：当客户端要从服务器中读取某个资源时，使用GET方法。</p>
</li>
<li><p>POST：当客户端给服务器提供信息较多时可以使用POST 方法，POST 方法向服务器提交数据，比如完成表单数据的提交，将数据提交给服务器处理。GET 一般用于获取&#x2F;查询资源信息，POST 会附带用户数据，一般用于更新资源信息。</p>
</li>
<li><p>如果带参数时，在约定中，GET方法的参数应该放在URL中，POST方法参数应该放在请求体中。例如，如果参数是 <code>name=Java, age = 25</code>，那么GET方法的报文是这样的:</p>
<p>  GET &#x2F;updateInfo?name&#x3D;JavA&amp;age&#x3D;25 HTTP&#x2F;1.1<br>  Host: localhost</p>
</li>
</ul>
<p>POST方法的报文为：</p>
<pre><code>POST /updateInfo HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded

name=Javanx&amp;age=25
</code></pre>
<p>如果不带参数，最大的区别就是二者请求行的方法名称不同而已。实际上两种方法都是基于TCP连接的，GET也可以有请求包体，POST也不一定要使用请求包体，只要客户端和服务端约定好规范即可。</p>
<ol>
<li>请求头部：请求头部由关键字&#x2F;值对组成，每行一对，关键字和值用英文冒号“:”分隔。常见的头部信息有：</li>
</ol>
<ul>
<li>User-Agent：产生请求的浏览器类型;</li>
<li>Accept：客户端可识别的响应内容类型列表;星号 “ * ” 用于按范围将类型分组，用 “ <em>&#x2F;</em> ” 指示可接受全部类型，用“ type&#x2F;* ”指示可接受 type 类型的所有子类型;</li>
<li>Accept-Language：客户端可接受的自然语言</li>
<li>Accept-Encoding：客户端可接受的编码压缩格式;</li>
<li>Host：请求的主机名，允许多个域名同处一个IP 地址，即虚拟主机;</li>
<li>connection：连接方式(close 或 keep-alive);</li>
<li>Cookie：存储于客户端扩展字段，向同一域名的服务端发送属于该域的cookie;</li>
<li>content-length:表示包体数据长度，用来POST方法区分下一条请求的界限</li>
</ul>
<ol start="3">
<li>空行：最后一个请求头部之后是一个空行，发送回车符和和换行符，通知服务端以下不再有请求头。</li>
<li>请求包体：请求包体不在GET方法中使用，而是在POST方法中使用。适用于需要客户填写表单的场合。</li>
</ol>


<h1 id="http响应报文"><a href="#http响应报文" class="headerlink" title="http响应报文"></a>http响应报文</h1><p>HTTP响应报文由状态行、响应头部、空行和响应包体4个部分组成，如下图所示：</p>



<p>下面对响应报文格式进行简单的分析：</p>
<ul>
<li>状态行：由HTTP协议版本，状态码和状态码的描述文本3个部分组成</li>
<li>状态码由三位数字组成， 常用的有以下：<br>1xx：表示服务器已接收了客户端请求，客户端可继续发送请求;<br>2xx：表示服务器已成功接收到请求并进行处理;<br>3xx：表示服务器要求客户端重定向;<br>4xx：表示客户端的请求有非法内容;<br>5xx：表示服务器未能正常处理客户端的请求而出现意外错误;</li>
<li>响应头部：</li>
</ul>
<ol>
<li>Location：Location响应报头域用于重定向接受者到一个新的位置。例如：客户端所请求的页面已不存在原先的位置，为了让客户端重定向到这个页面新的位置，服务器端可以发回Location响应报头后使用重定向语句，让客户端去访问新的域名所对应的服务器上的资源;</li>
<li>Connection：连接方式<br>对于请求来说：close(告诉 WEB 服务器或者代理服务器，在完成本次请求的响应后，断开连接，不等待本次连接的后续请求了)。keepalive(告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求);<br>对于响应来说：close(连接已经关闭); keepalive(连接保持着，在等待本次连接的后续请求); Keep-Alive：如果浏览器请求保持连接，则该头部表明希望WEB 服务器保持连接多长时间(秒);例如：Keep-Alive：300;</li>
</ol>
<ul>
<li>空行：最后一个响应头部之后是一个空行，发送回车符和换行符，通知服务器以下不再有响应头部。</li>
<li>响应包体：服务器返回给客户端的文本信息</li>
</ul>
<h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><ol>
<li>GET方法的长度限制：首先说明一点，HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。原因是指：解析URL的时候要分配内存，即分配一个buffer来保存所有要储存的数据，处理长 URL 要消耗比较多的资源，为了性能和安全（防止恶意构造长 URL 来攻击）考虑，会给 URL 长度加限制。</li>
<li>POST 方法会产生两个 TCP 数据包？<br>有些文章中提到，post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。HTTP 协议中没有明确说明 POST 会产生两个 TCP 数据包，而且实际测试(Chrome)发现，header 和 body 不会分开发送。所以，header 和 body 分开发送是部分浏览器或框架的请求方法，不属于 post 必然行为。</li>
<li>HTTP请求和响应的步骤，例如在浏览器地址栏键入URL,按下回车以后会经历以下流程：</li>
</ol>
<ul>
<li>浏览器向DNS服务器请求解析该URL中的域名对应的IP地址</li>
<li>解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接</li>
<li>浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP第三次握手的报文数据发送给服务器</li>
<li>服务器对浏览器请求做出响应，并把对应的html文本发送给浏览器</li>
<li>释放TCP连接：若connection 模式为close，则服务器主动关闭TCP 连接，客户端被动关闭连接，释放TCP 连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求</li>
<li>浏览器将html文本显示内容</li>
</ul>
<ol start="4">
<li>服务器如何解析POST包体数据，即如何辨别包体结束？<br>一般有两种方式：第一种方式就是在包头中有个content-Length字段，这个字段的值的大小标识了POST数据的长度，服务器收到一个数据包后，先从包头解析出这个字段的值，再根据这个值去读取相应长度的作为http协议的包体数据。还有一个格式叫做http chunked技术（分块），大致意思是将大包分成小包</li>
<li>如果某个客户端通过程序模拟了一个连接请求，但是迟迟不发含有\r\n\r\n的数据，这路连接将一直占用，这里我们可以设置一个最大URL长度，如果超过这个长度还不包含\r\n\r\n的话我们认为连接非法，将连接断开。并且如果一个客户端连接后不发送任何数据，这样会浪费大量的连接资源，所以还需要一个定时器去定时检测哪些http连接超过这个最大时间没发送数据，找到后将连接断开。</li>
</ol>
<h1 id="DNS解析流程"><a href="#DNS解析流程" class="headerlink" title="DNS解析流程"></a>DNS解析流程</h1><p>1.首先看浏览器缓存，若没有则看操作系统缓存，如果没有则去看host文件，如果没有则开始进行对服务器的询问<br>2.首先客户端询问本地DNS服务器，自己要查找的url的IP地址，如果本地服务器能找到缓存则返回，否则本地服务器会去询问根服务器，根服务器返回给它一个顶级域名服务器的地址；本地服务器会再去询问顶级域名服务器，后者会给它一个权威域名服务器地址，本地服务器再去询问，直到查询到自己要找的url的IP地址，并将其返回给客户端，客户端和目标建立连接</p>
<h1 id="路由表转发规则"><a href="#路由表转发规则" class="headerlink" title="路由表转发规则"></a>路由表转发规则</h1><p>如果有多个网卡，即有多个源IP地址，我们需要判断使用哪个来发送IP数据报<br>1.根据目的IP地址，和本地路由表中的多个条目的子网掩码进行与运算，得到的结果和路由表中的目的IP地址进行比对，正确的就是我们要选择的网卡，<br>2。如果没有匹配的网卡，那么选择默认网关，其目标IP地址和子网掩码都是0.0.0.0<br>3.后续将数据包发送给路由器，路由表中的Gateway就表示路由器的IP地址，即源IP地址</p>
<h1 id="如何优化HTTP-1-1"><a href="#如何优化HTTP-1-1" class="headerlink" title="如何优化HTTP&#x2F;1.1"></a>如何优化HTTP&#x2F;1.1</h1><ol>
<li>避免发送HTTP请求：缓存技术（强制缓存和协商缓存）</li>
<li>在需要发送 HTTP 请求时，考虑如何减少请求次数</li>
</ol>
<ul>
<li>减少重定向请求次数：如果有代理服务器，那么重定向的过程可以由它来进行，减少HTTP请求次数（301和308表示客户端可以将重定向响应缓存到本地磁盘，之后自动用新的url来替换之前的url来访问服务器）</li>
<li>合并请求（对于多个小的资源的请求，合并成一个总的资源请求）</li>
<li>延迟发送请求：请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。</li>
</ul>
<ol start="3">
<li>减少 HTTP 响应的数据大小</li>
</ol>
<ul>
<li>无损压缩：br，gzip算法：将常出现的数据用较短的二进制比特序列表示，将不常出现的数据用较长的二进制比特序列表示</li>
<li>有损压缩：比如对图</li>
<li></li>
</ul>
<h1 id="TCP为什么是三次握手"><a href="#TCP为什么是三次握手" class="headerlink" title="TCP为什么是三次握手"></a>TCP为什么是三次握手</h1><p>1.阻止重复历史连接的初始化（主要原因）<br>如果是两步，那么服务端接收到之后就会建立连接，并向客户端发送数据，如果当前建立的连接并不是客户端需要的，那么就白白浪费了这次历史连接的建立，增加了开销。<br>2.同步双方的初始序列号：如果只有两次，那么服务端的序列号无法被确认，四次的话又可以压缩，所以是三次。<br>3.避免资源浪费：如果初始SYN发生了网络阻塞，客户端进行了超时重传，那么服务端由于不知道自己发送的SYN+ACK是否被接收到，只能再次建立连接。</p>
<h1 id="为什么每次建立-TCP-连接时，初始化的序列号都要求不一样"><a href="#为什么每次建立-TCP-连接时，初始化的序列号都要求不一样" class="headerlink" title="为什么每次建立 TCP 连接时，初始化的序列号都要求不一样"></a>为什么每次建立 TCP 连接时，初始化的序列号都要求不一样</h1><ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）<br>客户端和服务端建立一个 TCP 连接，在客户端发送数据包被网络阻塞了，然后超时重传了这个数据包，而此时服务端设备断电重启了，之前与客户端建立的连接就消失了，于是在收到客户端的数据包的时候就会发送 RST 报文。紧接着，客户端又与服务端建立了与上一个连接相同四元组的连接；在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号正好是在服务端的接收窗口内，所以该数据包会被服务端正常接收，就会造成数据错乱。</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收</li>
</ul>
<p>初始序列号的产生：M + F<br>M是一个计时器，每隔4微秒 + 1，F是根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。</p>
<h1 id="既然-IP-层会分片，为什么-TCP-层还需要-MSS"><a href="#既然-IP-层会分片，为什么-TCP-层还需要-MSS" class="headerlink" title="既然 IP 层会分片，为什么 TCP 层还需要 MSS"></a>既然 IP 层会分片，为什么 TCP 层还需要 MSS</h1><p>如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。<br>因为 IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。<br>经过 TCP 层分片后，如果一个 TCP 分片丢失后，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率</p>
<h1 id="为什么需要-TIME-WAIT状态"><a href="#为什么需要-TIME-WAIT状态" class="headerlink" title="为什么需要 TIME_WAIT状态"></a>为什么需要 TIME_WAIT状态</h1><ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；<br>如果某一个网络包被延迟，并且在延迟过程中客户端和服务端连接断开，然后如果TIME_WAIT状态没有或者过短，那么如果客户端和服务端以相同的四元组重新建立连接，那么该被延迟的数据是有可能被窗口接受的，而TIME_WAIT持续2MSL时间，就是为了让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
<li>如果客户端（主动关闭方）最后一次 ACK 报文（第四次挥手）在网络中丢失了，那么按照 TCP 可靠性原则，服务端（被动关闭方）会重发 FIN 报文。</li>
</ul>
<p>假设客户端没有 TIME_WAIT 状态，而是在发完最后一次回 ACK 报文就直接进入 CLOSE 状态，如果该 ACK 报文丢失了，服务端则重传的 FIN 报文，而这时客户端已经进入到关闭状态了，在收到服务端重传的 FIN 报文后，就会回 RST 报文。<br>服务端收到这个 RST 并将其解释为一个错误（Connection reset by peer），这对于一个可靠的协议来说不是一个优雅的终止方式。</p>
<p>为了防止这种情况出现，客户端必须等待足够长的时间，确保服务端能够收到 ACK，如果服务端没有收到 ACK，那么就会触发 TCP 重传机制，服务端会重新发送一个 FIN，这样一去一来刚好两个 MSL 的时间。<br>客户端在收到服务端重传的 FIN 报文时，TIME_WAIT 状态的等待时间，会重置回 2MSL。</p>
<h1 id="为什么需要CLOSE-WAIT状态"><a href="#为什么需要CLOSE-WAIT状态" class="headerlink" title="为什么需要CLOSE_WAIT状态"></a>为什么需要CLOSE_WAIT状态</h1><p>因为虽然此时服务端收到了客户端断开连接的请求，此时需要通知进程调用close和shutdown函数来断开连接，而此时可能应用层还有别的任务需要处理，所以需要一个中间状态，然后等调用close或者shutdown函数后，服务端才会变为last_ack状态</p>
<h1 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h1><p>1.超时重传：数据包丢失和确认应答丢失<br>其机制是每一次重传时间增加一倍<br>2.快速重传：数据驱动，三次同样的ACK就会触发，但是并不知道所需要的ACK后面的需不需要重传<br>3.SACK：选择性确认，三次同样的ACK触发，TCP头部保存已经收到的数据段信息，只选择没有接收到的数据段重新发送。<br>4.D-SACK：告知发送方有哪些数据被重复接收了（例如ACK丢失和网络延时），会同时包括ACK和SACK两种，其中ACK表示需要的下一个包序列，SACK表示重复接收到的包，不需要再进行发送</p>
<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>1.概念：无需等待确认应答，而可以继续发送数据的最大值。窗口大小一般由接收方告诉发送方<br>2.发送窗口中分为两部分，一部分是已经发送但是还没有收到ACK的窗口大小，一部分是还没有发送的可用的发送部分，每当接收到一些ACK之后，窗口就可以向右滑动来增加可用部分<br>3.接收窗口表示未接收到但可以接收的数据，每次接收到数据后，窗口就可以向右滑动<br>涉及到的部分是流量控制：发送窗口和接收窗口所存放的数据都是放在系统内存缓冲区的，会在数据传输的过程中不断被系统调整</p>
<h1 id="全连接队列满了之后只能丢弃连接吗"><a href="#全连接队列满了之后只能丢弃连接吗" class="headerlink" title="全连接队列满了之后只能丢弃连接吗"></a>全连接队列满了之后只能丢弃连接吗</h1><p>丢弃连接是Linux内核的默认行为，我们可以通过设置参数tcp_abort_on_overflow的值来修改他的行为</p>
<ul>
<li>值为0，则表示如果队列满了，则丢弃客户端发送的最后一次ack</li>
<li>值为1，则服务端会发送一个RST给客户端，表示废弃掉这个握手过程和这个连接</li>
</ul>
<p>通常情况下，应该将该值设置为0，来应对突发的流量，因为可能过一段时间后，全连接队列就能空出位置来接收客户端重新发送的ack，二者还能够成功建立连接</p>
<h1 id="为什么需要四次挥手"><a href="#为什么需要四次挥手" class="headerlink" title="为什么需要四次挥手"></a>为什么需要四次挥手</h1><p>因为服务端收到客户端的FIN报文时，马上会回复一个ACK报文，但是服务端应用程序可能还有数据要发送，所以并不能马上发送FIN报文，而是将该权限交给应用程序</p>
<ul>
<li>如果应用程序还要发送数据，那么发送完数据后才调用关闭连接的函数</li>
<li>如果应用程序不再发送数据，那么直接就可以调用关闭连接的函数</li>
</ul>
<h1 id="三次挥手"><a href="#三次挥手" class="headerlink" title="三次挥手"></a>三次挥手</h1><p>如果服务端没有数据要发送而且开启了TCP延迟确认的情况，那么第二次挥手和第三次挥手就会合并成一次。<br>TCP延迟确认的规则：</p>
<ul>
<li>如果有响应数据要发送，那么响应数据和ACK会一起发送</li>
<li>如果没有响应数据要发送，那么会等待一段时间看是否有响应数据需要发送</li>
<li>如果在等待期间又接收到了数据，那么会立即发送ACK</li>
</ul>
<h1 id="没有accept也可以建立连接"><a href="#没有accept也可以建立连接" class="headerlink" title="没有accept也可以建立连接"></a>没有accept也可以建立连接</h1><p>accept最终返回是从全连接队列中取出一个元素，在前面的过程中实际上已经构建了连接<br>全连接队列和半连接队列是在服务点listen阶段内核创建的，其中全连接队列是链表，半连接队列是哈希表<br>没有listen的情况下也可以建立连接，比如两个客户端产生连接或者客户端和自己建立连接，这是因为内核有一个全局的hash表，可以用来存放客户端的连接信息，当消息发出后，经过回环地址重新回来以后，从hash表中取出连接信息，建立连接。</p>
<h1 id="TCP的异常断开连接情况"><a href="#TCP的异常断开连接情况" class="headerlink" title="TCP的异常断开连接情况"></a>TCP的异常断开连接情况</h1><p>1.如果进程崩溃，那么内核会发送FIN，和另一端进行四次挥手断开连接<br>2.如果客户端宕机且没有重启，不会发生四次挥手：</p>
<ul>
<li>如果服务端发送数据，那么会超时重传，直到达到最大重传次数断开连接</li>
<li>如果服务端不发送数据，如果服务端开启了keepalive，那么会去探测对方是否还在，如果探测不到，就会断开连接，如果没有开启保活机制，那么会一直保持在连接状态<br>3.如果客户端宕机且迅速重启：此时如果服务端向客户端发送数据，都会收到它发送的RST断开连接的报文</li>
</ul>
<h1 id="拔掉网线的问题"><a href="#拔掉网线的问题" class="headerlink" title="拔掉网线的问题"></a>拔掉网线的问题</h1><p>实际上拔掉网线不会影响TCP四元组的信息，其连接状态还是存在<br>1.如果有数据传输</p>
<ul>
<li>在数据传输的重传次数到达最大之前插入网线，还是能保持连接</li>
<li>达到最大重传次数前没有插入网线，则断开连接<br>2.如果没有数据传输</li>
<li>如果二者都没有keepalive，那么二者都默认是连接状态</li>
<li>如果开启了保活机制，那么在探测期间内插入了网线，还是保持连接，如果探测失败，则断开连接</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/14/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0c%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/14/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0c%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">手动实现c字符串的基本函数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-14 14:47:31" itemprop="dateCreated datePublished" datetime="2022-08-14T14:47:31+08:00">2022-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:46:29" itemprop="dateModified" datetime="2024-04-26T10:46:29+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">总结笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2/" itemprop="url" rel="index"><span itemprop="name">字符串</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1-strlen函数"><a href="#1-strlen函数" class="headerlink" title="1.strlen函数"></a>1.strlen函数</h2><p>原型：size_t strlen(const char *str)，计算字符串的长度</p>
<pre><code>int my_strlen(const char *str)&#123;
    int count = 0;
    assert(str != nullptr);
    while(*str != &#39;\0&#39;)&#123;
        count++;
        str++;
    &#125;
    return count;
&#125;
</code></pre>
<h2 id="2-strcpy函数"><a href="#2-strcpy函数" class="headerlink" title="2.strcpy函数"></a>2.strcpy函数</h2><p>原型：char *strcpy(char *dest, const char *src)，将src指向的字符串复制到dest中</p>
<pre><code>char *my_strcpy(char *str_des, const char *str_source)&#123;
    assert(str_des != nullptr);
    assert(str_source != nullptr);
    char *ret = str_des;
    while((*str_des++ = *str_source++) != &#39;\0&#39;)&#123;
        ;
    &#125;
    return ret;
&#125;
</code></pre>
<h2 id="3-strcat函数"><a href="#3-strcat函数" class="headerlink" title="3.strcat函数"></a>3.strcat函数</h2><p>原型：char *strcat(char *dest, const char *src)，将src指向的字符串追加到dest指向的字符串结尾。</p>
<pre><code>char *my_strcat(char *str_des, const char *str_source)&#123;
    assert(str_des != nullptr);
    assert(str_source != nullptr);
    char *ret = str_des;
    while(*str_des)&#123;
        str_des++;
    &#125;
    while((*str_des++ = *str_source++) != &#39;\0&#39;)&#123;
        ;
    &#125; 
    
    return ret;
    
&#125;
</code></pre>
<h2 id="4-strcmp函数"><a href="#4-strcmp函数" class="headerlink" title="4.strcmp函数"></a>4.strcmp函数</h2><p>原型：int strcmp(const char *str1, const char *str2)，把str1指向的字符串和str2指向的字符串进行比较，小于返回一个小于零的值，大于返回一个大于零的值，相等返回0</p>
<pre><code>int my_strcmp(const char *str1, const char *str2)&#123;
    while(*str1 &amp;&amp; *str2)&#123;
        if(*str1 == *str2)&#123;
            str1++;
            str2++;
        &#125;
        else if(*str1 &gt; *str2)return -1;
        else return 1;
    &#125;
    if(*str1)return 1;
    if(*str2)return -1;
    return 0;
&#125;
</code></pre>
<h2 id="5-strchr函数"><a href="#5-strchr函数" class="headerlink" title="5.strchr函数"></a>5.strchr函数</h2><p>原型：char *strchr(const char *str, int c)，在参数str所指向的字符串中搜索第一次出现字符c的位置，如果未找到返回NULL</p>
<pre><code>char *my_strchr(const char *str, char c)&#123;
    while(*str++ != &#39;\0&#39;)&#123;
        if(*str == c)return str;
    &#125;
    return NULL;
&#125;
</code></pre>
<h2 id="6-strstr函数"><a href="#6-strstr函数" class="headerlink" title="6.strstr函数"></a>6.strstr函数</h2><p>原型：char *strstr(const char *haystack, const char *needle)，在字符串haystack中查找第一次出现字符串needle的位置，不包括终止符’\0’</p>
<pre><code>char *my_strstr(char *str1, char *str2)&#123;
    const char *index1;
    const char *index2;
    if(!str1 || !str2)return str1;
    
    //遍历str1字符串
    while(*str1)&#123;
        index1 = str1;
        index2 = str2;
        do&#123;
            if(!*index2)return str1;
        &#125;while(*index1++ == *index2++);
        str1++;
    &#125;
    return NULL;
    
&#125;
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0shared-ptr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/13/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0shared-ptr/" class="post-title-link" itemprop="url">从零实现shared_ptr</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-13 15:38:42" itemprop="dateCreated datePublished" datetime="2022-08-13T15:38:42+08:00">2022-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:45:39" itemprop="dateModified" datetime="2024-04-26T10:45:39+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">总结笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/shared-ptr/" itemprop="url" rel="index"><span itemprop="name">shared_ptr</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="本文结构"><a href="#本文结构" class="headerlink" title="本文结构"></a>本文结构</h1><ul>
<li>基础构造函数</li>
<li>复制语义</li>
<li>移动语义</li>
<li>一些工具函数</li>
<li>析构函数</li>
</ul>
<h2 id="1-基础构造函数"><a href="#1-基础构造函数" class="headerlink" title="1.基础构造函数"></a>1.基础构造函数</h2><p>面试中如果要求实现一个shared_ptr，我们可以从最简单的结构写起：</p>
<pre><code>template&lt;class T&gt;
class my_shared_ptr&#123;
private:
    T* m_ptr = nullptr;
    unsigned int * m_ref_count = nullptr;
    //默认构造函数
public:   
    my_shared_ptr(): m_ptr(nullptr), m_ref_count(nullptr)&#123; &#125;
    my_shared_ptr(T* ptr): m_ptr(ptr), m_ref_count(new unsigned int(1))&#123; &#125;
&#125;;
</code></pre>
<p><strong>1.为什么m_ref_count这个引用计数要用指针来表示？</strong><br>因为shared_ptr会被复制来复制去的，对于同一个被引用的对象，其引用计数需要同时更新和共享，使用指针的话就会比较方便。<br><strong>2.shared_ptr的引用计数是线程安全的吗？</strong><br>在其源代码中，是线程安全的，因为最后使用了_Atomic_word类型来计数，表明其是一个原子操作，保证了线程安全。<br><strong>3.shared_ptr储存的指针是线程安全的吗？</strong><br>并不是，源代码中指针类型是element_type*，其为用户使用时自定义的指针类型，没有保证原子操作。</p>
<h2 id="2-拷贝构造部分"><a href="#2-拷贝构造部分" class="headerlink" title="2.拷贝构造部分"></a>2.拷贝构造部分</h2><pre><code>//拷贝构造函数
my_shared_ptr(const my_shared_ptr &amp; obj)&#123;
    m_ptr = obj.m_ptr;
    m_ref_count = obj.m_ref_count;
    if(m_ref_count != nullptr)&#123;
        (*m_ref_count)++;
    &#125;
&#125;

//拷贝重载=运算符
my_shared_ptr&amp; operator=(const my_shared_ptr &amp; obj)&#123;
    if(obj.m_ptr == m_ptr)&#123;
        return *this;
    &#125;
    
    //先处理原有的指针和引用计数
    if(m_ref_count != nullptr)&#123;
        (*m_ref_count)--;
        if(*m_ref_count == 0)&#123;
            delete m_ptr;
            delete m_ref_count;
        &#125;
    &#125;
    
    m_ptr = obj.m_ptr;
    m_ref_count = obj.m_ref_count;
    
    if(m_ref_count != nullptr)&#123;
        (*m_ref_count)++;
    &#125;
    return *this;
&#125;
</code></pre>
<p><strong>1.为什么拷贝构造的参数是const my_shared_ptr&amp;，而不是const my_shared_ptr</strong><br>因为我们写的是拷贝构造函数，如果参数为后者，相当于要调用一次拷贝构造，就会无限递归下去。<br><strong>2.为什么重载&#x3D;运算符的返回值是my_shared_ptr&amp;，能不能返回void</strong><br>理论上是可以的，但是为了支持连等a &#x3D; b &#x3D; c，还是要返回my_shared_ptr&amp;</p>
<h2 id="3-移动构造部分"><a href="#3-移动构造部分" class="headerlink" title="3.移动构造部分"></a>3.移动构造部分</h2><pre><code>//移动语义
//移动构造
my_shared_ptr(my_shared_ptr &amp;&amp; dying_obj): m_ptr(nullptr), m_ref_count(nullptr)&#123;
    //初始化后交换指针和引用计数，相当于清除了dying_obj的内容
    dying_obj.swap(*this);
&#125;
//移动赋值
my_shared_ptr &amp; operator=(my_shared_ptr &amp;&amp; dying_obj)&#123;

    //my_shared_ptr(std::move(dying_obj))用移动构造函数创建出一个新的shared_ptr(此时原shared_ptr的内容被清除了)
    //再和this交换指针和引用计数
    //因为this的内容被交换到了当前的临时创建的my_shared_ptr里，原this指向的引用计数-1

    my_shared_ptr(std::move(dying_obj)).swap(*this);
    return *this;
&#125;

void swap(my_shared_ptr &amp; other)&#123;
    std::swap(m_ptr, other.m_ptr);
    std::swap(m_ref_count, other.m_ref_count);
&#125;
</code></pre>
<h2 id="4-一些工具函数"><a href="#4-一些工具函数" class="headerlink" title="4.一些工具函数"></a>4.一些工具函数</h2><p>指针相关的运算符重载和获取引用计数的函数</p>
<pre><code>//重载指针运算符
T* operator-&gt;() const&#123;
    return m_ptr;
&#125;

//重载解引用运算符
T* operator*() const&#123;
    return *m_ptr;
&#125;

T* get() const&#123;
    return m_ptr;
&#125;

unsigned int use_count() const&#123;
    return *m_ref_count;
&#125;
</code></pre>
<h2 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5.析构函数"></a>5.析构函数</h2><pre><code>//析构函数
~my_shared_ptr()&#123;
    if(m_ref_count == nullptr)&#123;
        return;
    &#125;
    (*m_ref_count)--;
    if(*m_ref_count &gt; 0)&#123;
        return;
    &#125;
    
    if(m_ptr != nullptr)&#123;
        delete m_ptr;
    &#125;
    delete m_ref_count;
&#125;
</code></pre>
<h2 id="6-make-shared函数"><a href="#6-make-shared函数" class="headerlink" title="6.make_shared函数"></a>6.make_shared函数</h2><p>1.为什么会推荐使用std::make_shared，而不是直接构造std::shared_ptr<br>如果直接构造shared_ptr，那么是先分配一块内存给实例化对象，再分配一块内存给引用计数模块（引用计数，删除器等），但是std::make_shared可以一次性分配一整块内存给引用计数模块和实例化对象，这样有两部分优点：</p>
<ul>
<li><p>优点一：异常安全<br>在C++17之前，在某种情况下构造一个std::shared_ptr不一定是安全的，看下面的案例：</p>
<p>  void F(const std::shared_ptr<Lhs> &amp;lhs, const std::shared_ptr<Rhs> &amp;rhs) { &#x2F;* … *&#x2F; }</p>
<p>  F(std::shared_ptr<Lhs>(new Lhs(“foo”)),<br>  std::shared_ptr<Rhs>(new Rhs(“bar”)));</p>
</li>
</ul>
<p>一个可能的执行顺序是</p>
<pre><code>1.new Lhs(&quot;foo&quot;)
2.new Rhs(&quot;bar&quot;)
3.std::shared_ptr&lt;Lhs&gt;
4.std::shared_ptr&lt;Rhs&gt;
</code></pre>
<p>假设在第2步出现了一个异常（比如内存耗尽或者构造函数的异常），那么第一步分配的内存地址就没有保存在任何地方，所以这块内存永远回收不了，导致内存泄露。使用std::make_shared就可以避免这种问题。</p>
<ul>
<li>优点二：减少开销<br>一次性分配一整块内存来使用可以减少碎片化内存，减少使用临时变量，也减少了和内核的交流。</li>
</ul>
<p>2.有没有什么情况下没法使用std::make_shared</p>
<ul>
<li><p>有时候我们把构造函数定义为私有，就可以强制用户使用工厂模式A::Create创建shared_ptr，这样可以避免用户直接创建实例或者使用生指针进而管理不善导致内存泄漏。</p>
<pre><code>  #include &lt;iostream&gt;
  #include &lt;memory&gt;

  class A
  &#123;
      public:
      static std::shared_ptr&lt;A&gt; Create()&#123; return std::shared_ptr&lt;A&gt;(new A(100)); &#125;

      int GetId()&#123; return m_i; &#125;

      private:
      int m_i;
      A(int i): m_i(i)&#123;std::cout&lt;&lt;&quot;private ctor called&quot;&lt;&lt;std::endl;&#125;;
  &#125;;

  int main()
  &#123;
      std::shared_ptr&lt;A&gt; s_ptr = A::Create();
      std::cout&lt;&lt;s_ptr-&gt;GetId()&lt;&lt;std::endl;

      //A * p = new A(300);  //make_shared无法访问私有构造函数
      return 0;
  &#125;
</code></pre>
</li>
</ul>
<p>在这种情况下，std::make_shared进行placement new操作的时候，会直接调用构造函数，但因为我们的构造函数都是私有的，这时候就会报错。而我们在工厂模式里直接new出来的实例是通过成员函数new操作符operator new访问的私有构造函数，所以没有问题。</p>
<ul>
<li>还有一种情况，make_shared 只分配一次内存, 这看起来很好. 减少了内存分配的开销. 问题来了, weak_ptr 会保持控制块(强引用, 以及弱引用的信息)的生命周期, 而因此连带着保持了对象分配的内存, 只有最后一个 weak_ptr 离开作用域时, 内存才会被释放. 原本强引用减为 0 时就可以释放的内存, 现在变为了强引用, 弱引用都减为 0 时才能释放, 意外的延迟了内存释放的时间. 这对于内存要求高的场景来说, 是一个需要注意的问题。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">操作系统知识笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-27 23:15:17" itemprop="dateCreated datePublished" datetime="2022-07-27T23:15:17+08:00">2022-07-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:43:48" itemprop="dateModified" datetime="2024-04-26T10:43:48+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">总结笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.Linux 中一个进程的虚拟内存分布长什么样？内核空间+用户空间（6 种不同的内存段）<br>代码段：存放程序代码，运行前就已经确定（编译时确定）<br>常量区：存放const定义的全局变量，define定义的常量和字符串常量等<br>数据段：存放已经初始化的全局变量<br>bss段：存放没有初始化的全局变量或默认为0的全局变量，执行期间会将这一段的内容全部设为0<br>栈：存放函数参数和局部变量，由系统进行申请和释放，空间较小，先进先出<br>堆：存放动态分配的内存，由用户自己申请和释放（比如malloc和free）</p>
<p>2.为什么要使用虚拟内存<br>如果没有虚拟地址，cpu访问的都是真实的物理地址，那么会产生：程序直接访问真实内存，没有顺序没有规则，很容易导致错误的产生，并且无法同时运行多个程序。<br>有了虚拟地址以后：</p>
<ul>
<li>程序可以用一系列相邻的虚拟地址访问实际物理内存中不相邻的大内存缓冲区</li>
<li>程序可以使用虚拟地址访问大于可用物理地址的内存缓冲区</li>
<li>不同进程之间的虚拟地址分隔开，不同进程不会操作同一个物理地址，防止程序崩溃</li>
</ul>
<h1 id="中断问题"><a href="#中断问题" class="headerlink" title="中断问题"></a>中断问题</h1><p>Linux将中断问题分为上下两部分</p>
<ul>
<li>上半部分对应硬件，硬中断，用来快速处理中断，把网卡的数据读到内存中，更新一下硬件寄存器的状态</li>
<li>下半部分对应内核，软中断，通常耗时比较长，例如从内存中读取数据，根据协议栈对网络数据进行逐层解析和处理，最终交给应用程序</li>
</ul>
<h1 id="cpu写入问题"><a href="#cpu写入问题" class="headerlink" title="cpu写入问题"></a>cpu写入问题</h1><ol>
<li>写直达：同时把数据写入Cache和内存</li>
</ol>
<ul>
<li>如果Cache中有该数据，先将数据更新，再写入到内存中</li>
<li>如果Cache中没有该数据，则直接写入到内存中</li>
</ul>
<ol start="2">
<li>写回：当写数据时，新的数据被写入到Cache中，只有当修改过的Cache Block被替换时才写入到内存中<br>这种情况下，只有当缓存不命中，且对应的Cache Block是脏的情况下，才会将该脏的数据写入内存中，然后将要写入的数据，先从内存读入到Cache Block中，然后再把当前要写入的数据写入到Cache Block中，并标记为脏的</li>
</ol>
<h1 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h1><p>如果有多个CPU核心操作缓存数据，按照写回原则，则会出错，因为当没有发生缓存不命中且对应数据为脏时，缓存中的数据不会写回到内存中，此时其他核心从内存中读取的数据就是错的。为了解决，需要写传播和事务的串行化</p>
<ul>
<li>写传播：当某个CPU核心更新了Cache中的数据，需要广播到其他核心中，使用总线嗅探技术</li>
<li>事务的串行化：基于总线嗅探技术实现的MESI方法，解决了上述两个问题</li>
</ul>
<h1 id="malloc申请内存的方式"><a href="#malloc申请内存的方式" class="headerlink" title="malloc申请内存的方式"></a>malloc申请内存的方式</h1><p>1.brk()函数从堆申请内存，具体为将指针从堆的低地址向高地址移动，小于128KB<br>2.mmap()函数从文件映射区分配内存，大于128KB<br>malloc分配的是虚拟地址，如果该虚拟地址没有被访问，则不会映射到真实物理地址，如果操作系统访问虚拟地址，通过页表查询发现虚拟地址对应的页没有在物理内存中，就会发生缺页中断，然后才会建立虚拟地址和物理内存之间的映射<br>不能都使用mmap函数，因为其会发生运行态的切换，而且mmap申请的内存总是会被释放掉，从而每次访问都会缺页中断，导致CPU消耗过大<br>也不能都使用brk函数，因为其堆指针连续向上增长，会产生内存碎片问题，导致内存泄露</p>
<h1 id="free释放内存的问题"><a href="#free释放内存的问题" class="headerlink" title="free释放内存的问题"></a>free释放内存的问题</h1><p>1.如果是malloc使用brk()函数申请的内存，则不会释放掉<br>2.如果是mmap()函数申请的内存，则会释放掉<br>其中malloc返回给用户的数据会有一个16字节的信息头，其中保存了该内存块的大小，这样free释放的时候就知道要释放多大的内存块了</p>
<h1 id="内存分配的过程"><a href="#内存分配的过程" class="headerlink" title="内存分配的过程"></a>内存分配的过程</h1><p>应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存，CPU 就会产生缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的缺页中断函数处理。缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。<br>如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</p>
<ul>
<li>后台内存回收（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。</li>
<li>直接内存回收（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。</li>
<li>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发 OOM （Out of Memory）机制。OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</li>
</ul>
<h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><p>1.先来先服务<br>2.最短作业：优先选择运行时间最短的<br>3.高响应比优先调度算法：等待时间 + 要求服务时间&#x2F; 要求服务时间（无法实现）<br>4.时间片轮转算法：每个进程被分配一个时间片<br>5.最高优先级调度算法：静态和动态优先级<br>6.多级反馈队列：多个队列，每个队列优先级从高到低，新来的任务先加入第一级的队尾，按照先来先服务运行，如果没有运行完则加入第二级的队尾，如果来了一个优先级高的，则先去运行优先级高的任务队列，此时将原任务加入当前队列的队尾</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>1.匿名管道：通过fork父进程的文件描述符来建立连接，先进先出<br>2.命名管道：在不相关的进程间也能进行通信，其创建了一个类型为管道的设备文件<br>3.消息队列：在内核中，不适合比较大的文件传输，同时会带来用户态与内核态之间的数据拷贝开销<br>4.共享内存：一个虚拟内存，映射到同一块真实物理内存<br>5.信号量：P操作-1，如果小于0，则阻塞 V操作：如果小于等于0则有进程阻塞，唤醒它，如果大于0，则没有进程阻塞</p>
<ul>
<li>1：互斥信号量</li>
<li>0：同步信号量：需要先执行的只需要V操作，需要后执行的只需要P操作<br>6.信号：异常状态下的通信<br>7.Socket：跨网络和不同的主机间进程通信</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>1.死锁的四个条件</p>
<ul>
<li>互斥</li>
<li>忙等待</li>
<li>不可剥夺</li>
<li>环路等待</li>
</ul>
<p>2.如何避免</p>
<ul>
<li>资源有序分配法来打破环路等待：如果两个进程需要的资源相同，那么就按照同样的顺序去获取资源</li>
</ul>
<h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><p>1.互斥锁：获取不到资源时，将CPU释放，去执行其他进程<br>2.自旋锁：获取不到资源时，线程会忙等待，直到拿到锁<br>3.读写锁：当写锁没有被线程持有，那么多个线程可以持有读锁，如果线程持有了读锁，那么其他线程的读锁和写锁都会被阻塞</p>
<ul>
<li>读优先锁：写锁被阻塞，且后来的读锁也会先与写锁被执行</li>
<li>写优先锁：读锁会阻塞写锁，但是后面的线程无法再持有读锁，那么写线程就会接着被执行</li>
<li>比较公平的方法：把所有锁加入一个队列，先来先执行<br>4.以上都是悲观锁，还有乐观锁：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</li>
</ul>
<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p>1.先进先出：选择在内存中保留时间最长的页面<br>2.最近最久未使用：LRU<br>3.最不常用：选择访问次数最少的<br>4.时钟页面：所有页面保存在环形列表中，表针指向最老的页面，如果发生缺页就检查访问位置：如果是0则淘汰，并插入当前页面，如果是1，则置为0，表针向前一个走</p>
<h1 id="如果系统中具有快表后，那么地址的转换过程变成什么样了？"><a href="#如果系统中具有快表后，那么地址的转换过程变成什么样了？" class="headerlink" title="如果系统中具有快表后，那么地址的转换过程变成什么样了？"></a>如果系统中具有快表后，那么地址的转换过程变成什么样了？</h1><ul>
<li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li>
<li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li>
<li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</li>
</ul>
<h1 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h1><p>1.首次适应算法：空闲分区以地址递增的次序排列，每次都从低地址开始查找空闲分区链或者空闲分区表，找到第一个能满足大小的空闲分区。<br>2.最佳适应算法：空闲分区按容量递增次序链接，每次分配内存时按顺序查找空闲分区表，找到大小能满足要求的第一个空闲分区。<br>3.最坏适应算法：空闲分区按容量递减次序链接，每次分配内存时按顺序查找空闲分区表，找到大小能满足要求的第一个空闲分区。<br>4.邻近适应算法：空闲分区以地址递增的顺序排列（可排成一个循环链表），每次分配内存时从上次查找结束的位置开始查找空闲分区链，找到大小能满足要求的第一个空闲分区。</p>
<h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><p>1.静态链接：函数和数据被编译进一个二进制文件，链接时，链接器从库中复制这些函数和数据，并把他们和应用程序的其他模块组合起来创建最终的可执行文件。</p>
<ul>
<li>空间浪费：每个可执行文件中对所有需要的目标文件都要有一个副本</li>
<li>更新困难：每当库函数代码发生变化，就需要重新编译链接形成可执行程序</li>
<li>优点：运行速度快<br>2.动态链接：把程序按照模块拆分成各个相对独立的部分，在程序运行时才将他们链接到一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</li>
<li>共享库：即使每个程序都依赖一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是多个程序在执行时共享同一个副本。</li>
<li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再链接一遍。</li>
<li>性能损耗：每次程序运行都需要进行链接，性能会有一定损失。</li>
</ul>
<h1 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h1><p>问题描述：允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<pre><code>typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() &#123;
    while(TRUE) &#123;
        down(&amp;count_mutex);
        count++;
        if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&amp;count_mutex);

        read();  

        down(&amp;count_mutex);
        count--;
        if(count == 0) up(&amp;data_mutex);//最后一个读者要对数据进行解锁，防止写进程无法访问
        up(&amp;count_mutex);
    &#125;
&#125;

void writer() &#123;
    while(TRUE) &#123;
        down(&amp;data_mutex);

        write();

        up(&amp;data_mutex);
    &#125;
&#125;
</code></pre>
<h1 id="中断和异常的区别"><a href="#中断和异常的区别" class="headerlink" title="中断和异常的区别"></a>中断和异常的区别</h1><p>1.中断是硬件产生的，通过中断控制器发给CPU，CPU判断其来自哪个硬件设备，最后发送给内核，由内核进行处理<br>2.异常由CPU产生，例如缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常等。其会发送给内核，由内核来进行异常处理。</p>
<h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><p>1.用户态：用户可以操作和访问的空间，这个空间通常存放我们用户自己的数据等<br>2.内核态：是系统内核来操作的一块空间，用来存放系统内核的函数，接口等<br>3.二者之间的最大区别就是特权级不同：用户态拥有最低的特权级，内核态拥有较高的特权级<br>4.为什么要分为内核态和用户态：为了安全性。在CPU的一些指令中，有些指令如果用错，将导致整个系统崩溃。分开之后，如果用户需要某些操作，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行操作。<br>5.什么样的功能应该在内核态下实现：</p>
<ul>
<li>CPU的管理和内存管理：更为安全</li>
<li>诊断和测试程序：因为需要访问计算机的所有资源</li>
<li>文件系统：用户数据的管理可以放在用户态下，而对于文件系统本身的管理，需要放在内核态中。</li>
<li>IO管理：因为要访问各种设备和底层数据结构，所以也要放在内核态实现。<br>6.如何辨别当前处于哪个态：CPU中有一个状态字，标识了当前的状态，用户态为3，内核态为0</li>
</ul>
<h1 id="用户态和内核态的切换"><a href="#用户态和内核态的切换" class="headerlink" title="用户态和内核态的切换"></a>用户态和内核态的切换</h1><p>1.系统调用：其机制核心还是通过操作系统为用户特别开放的一个中断来实现，表现为一个正常的异常（软中断）。</p>
<ul>
<li>进程调用：exit和fork</li>
<li>文件系统访问：chmod和chown</li>
<li>设备调用：read和write</li>
<li>信息读取：读取设备信息</li>
<li>通信：pipe和mmap<br>2.中断：当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有<br>用户态到内核态的切换。<br>3.异常：当CPU在执行用户态的程序时，发现某些异常情况，就会触发由当前进程切换到异常的内核相关程序中，比如缺页异常。</li>
</ul>
<h1 id="申请的虚拟内存大小超过了物理内存的大小"><a href="#申请的虚拟内存大小超过了物理内存的大小" class="headerlink" title="申请的虚拟内存大小超过了物理内存的大小"></a>申请的虚拟内存大小超过了物理内存的大小</h1><p>1.应用程序使用malloc申请的内存实际上是虚拟内存，此时并不会分配物理内存，只有当应用程序读取了虚拟内存，CPU会去访问这块虚拟内存，发现并没有映射到物理内存上，CPU就会产生缺页中断，用户态切换到内核态，由缺页中断处理函数去处理</p>
<ul>
<li>如果有空闲物理内存，就会直接分配，并且建立虚拟内存和物理内存的映射</li>
<li>如果没有，内核就会开始内存回收的任务，如果空闲的物理内存大小不够，就会触发OOM<br>2.在32位机器上，最大可申请的虚拟内存大小是3G<br>3.在64位机器上，最大可申请的虚拟内存大小是128T，即使物理内存只有2G，我们也可以申请4G或者8G的虚拟内存，此时分为两种情况：</li>
<li>没有开启Swap分区：此时由于物理内存不够，最终会触发OOM（内存溢出）</li>
<li>开启了Swap分区，此时进程可以正常运行（Swap机制会将不常用的内存先写到磁盘中，然后释放这些内存，再次访问这些内存时，从磁盘读入即可）</li>
</ul>
<h1 id="Swap机制触发的条件"><a href="#Swap机制触发的条件" class="headerlink" title="Swap机制触发的条件"></a>Swap机制触发的条件</h1><p>1.内存不足：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个内存回收的过程是强制的直接内存回收（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。<br>2.内存闲置：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（kSwapd），我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。</p>
<h1 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h1><p>1.用户态的轻量级线程，是线程内部调度的基本单位，只在用户态内进行切换<br>2.先将寄存器上下文和栈保存，等切换回来的时候再进行恢复<br>3.同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理<br>4.基本没有到内核态切换的开销，可以不加锁的访问全局变量，所以上下文切换的非常快<br>5.其通信方式是共享队列和消息队列</p>
<h1 id="一般需要几级页表"><a href="#一般需要几级页表" class="headerlink" title="一般需要几级页表"></a>一般需要几级页表</h1><p>32位系统下，一个页大小是4KB，虚拟地址4GB，那么可以分为100万个页，一个页表项4B，那么4B * 2 * 2^20 &#x3D; 4MB，这对应的是一个进程，而多个进程就会有多个页表，导致页表会及其庞大<br>32位系统两级分页就足够了，64位的系统是4级分页</p>
<h1 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h1><p>一方面，有了中断功能，PC系统就可以使CPU和外设同时工作，使系统可以及时地响应外部事件。而且有了中断功能，CPU可允许多个外设同时工作。这样就大大提高了CPU的利用率，也提高了数据输入、输出的速度。 另一方面，有了中断功能，就可以使CPU及时处理各种软硬件故障。计算机在运行过程中，往往会出现事先预料不到的情况或出现一些故障，如电源掉电、存储出错，运算溢出等等。计算机可以利用中断系统自行处理，而不必停机或报告工作人员。</p>
<h1 id="CPU-Cache的数据结构和读取过程"><a href="#CPU-Cache的数据结构和读取过程" class="headerlink" title="CPU Cache的数据结构和读取过程"></a>CPU Cache的数据结构和读取过程</h1><p>1.存储结构：Cache Line组成，包括头标记和数据块，每次载入数据都是按照Cache Line整个读取<br>2.访问和存储：索引 + 有效位 + 组标记 + 偏移量，访问步骤如下：</p>
<ul>
<li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Cache Line 的地址；</li>
<li>找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；</li>
<li>对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；</li>
<li>根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。</li>
</ul>
<h1 id="关于伪共享的问题"><a href="#关于伪共享的问题" class="headerlink" title="关于伪共享的问题"></a>关于伪共享的问题</h1><p>1.如果两个变量属于同一个Cache Line块，而恰好两个CPU核心需要分别修改这两个变量，则会发生Cache Line没有起到缓存的作用，降低了代码执行的速度<br>2.避免伪共享的方法<br>将变量设置为内存对齐，用空间换取时间</p>
<h1 id="CPU选择线程的问题"><a href="#CPU选择线程的问题" class="headerlink" title="CPU选择线程的问题"></a>CPU选择线程的问题</h1><p>1.三个运行队列：</p>
<ul>
<li>Deadline运行队列</li>
<li>实时任务运行队列</li>
<li>CFS运行队列：完全公平调度，优先选择虚拟运行时间少的任务，虚拟运行时间 +&#x3D; 实际运行时间 &#x2F; 权重</li>
</ul>
<h1 id="硬中断和软中断"><a href="#硬中断和软中断" class="headerlink" title="硬中断和软中断"></a>硬中断和软中断</h1><p>Linux 将中断处理程序分为上半部和下半部：<br>上半部，对应硬中断，由硬件触发中断，用来快速处理中断；<br>下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作，Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型</p>
<h1 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h1><p>1.切换内容：用户空间的虚拟内存，栈，全局变量等；内核空间的堆栈、寄存器等<br>2.何时发生切换：CPU时间片用完；内存不足，则进程也会被挂起，当有优先级更高的进程运行，当前进程也会被挂起；发生硬件中断的时候也会发生进程的切换</p>
<h1 id="互斥锁和自旋锁"><a href="#互斥锁和自旋锁" class="headerlink" title="互斥锁和自旋锁"></a>互斥锁和自旋锁</h1><p>互斥锁加锁失败会发生线程的上下文切换，需要消耗一定的时间，自旋锁是用户态完成加锁和解锁操作，不会主动产生线程上下文切换，运行时间更快，自旋锁通过 CPU 提供的 CAS 函数实现，包含两个步骤：</p>
<ul>
<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>
<li>第二步，将锁设置为当前线程持有；<br>CAS 函数就把这两个步骤合并成一条硬件级指令，形成原子指令，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">计算机网络面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-09 12:38:22" itemprop="dateCreated datePublished" datetime="2022-07-09T12:38:22+08:00">2022-07-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:45:25" itemprop="dateModified" datetime="2024-04-26T10:45:25+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">总结笔记</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ping命令的工作原理"><a href="#ping命令的工作原理" class="headerlink" title="ping命令的工作原理"></a>ping命令的工作原理</h1><p>1.ping发送一个ICMP（Internet Control Messages Protocol），即因特网信报控制协议；接收端回声消息给目的地并报告是否收到所希望的应答。它的原理是：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，通过对方回复的数据包来确定两台网络机器是否连接相通，时延是多少。<br>2.ping是应用层直接使用网络层ICMP的一个例子，它没有通过运输层的TCP或UDP。所以ICMP属于网络层协议。<br>3.对于ping命令，我们需要的到达的效果是检查是否联通。那么只需要我们的请求方带上数字标识8（回送请求），如果对方回送的数值是0，那么证明两者是联通的。<br>4.一个例子：</p>
<ul>
<li>执行 ping 192.168.0.5：此时ping命令会构建一个固定格式的ICMP请求数据包</li>
<li>IP层协议将以地址“192.168.0.5”作为目的地址，本机IP地址作为源地址，加上一些其他的控制信息，构建一个IP数据包发往192.168.0.5。 </li>
<li>目的主机相关操作：接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议。IP层检查后，将有用的信息提取后交给ICMP协议。ICMP协议后者处理后，马上构建一个ICMP应答包，发送给主机A。</li>
</ul>
<h1 id="IPV4每个部分的含义"><a href="#IPV4每个部分的含义" class="headerlink" title="IPV4每个部分的含义"></a>IPV4每个部分的含义</h1><p>1.版本：4位，表示是IPV4还是IPV6<br>2.首部长度：默认20B<br>3.总长度：首部+数据和的长度，最大65535B，而MTU为1500B<br>4.标识：用于分片后进行重装<br>5.标志：MF &#x3D; 1表示后面还有分片，MF &#x3D; 0表示是最后一个分片，DF &#x3D; 0表示允许分片<br>6.TTL：生存时间，报文经过每个路由器都将减一，当为0时，丢弃该报文<br>7.协议：6表示TCP，17表示UDP<br>8.首部校验和：只检验数据报首部<br>9.源地址和目的地址</p>
<h1 id="epoll如何知道数据已经被完整读取"><a href="#epoll如何知道数据已经被完整读取" class="headerlink" title="epoll如何知道数据已经被完整读取"></a>epoll如何知道数据已经被完整读取</h1><p>用epoll + ET模式读取数据，当检查到监听的socket可以读取数据时，使用recv函数读取上面的数据，当该函数返回-1且errno是EAGAIN或EWOULDBLOCK的时候，表示数据已经全部读取完毕。</p>
<h1 id="epoll的ET模式时-如果数据只读了一半-也就是缓冲区的数据只读了一点-然后又来新事件了怎么办？"><a href="#epoll的ET模式时-如果数据只读了一半-也就是缓冲区的数据只读了一点-然后又来新事件了怎么办？" class="headerlink" title="epoll的ET模式时,如果数据只读了一半,也就是缓冲区的数据只读了一点,然后又来新事件了怎么办？"></a>epoll的ET模式时,如果数据只读了一半,也就是缓冲区的数据只读了一点,然后又来新事件了怎么办？</h1><p>这里我使用通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</p>
<h1 id="http断点续传"><a href="#http断点续传" class="headerlink" title="http断点续传"></a>http断点续传</h1><p>1.http 1.1中定义了断点续传的相关Range和Content-Range字段。</p>
<ul>
<li>客户端：Range字段，指定第一个字节的位置和最后一个字节的位置，有多种格式，可以具体的指示需要哪些字节，甚至可以指定多个范围值</li>
<li>服务端：Content-Range字段，返回当前接受的范围和文件总大小，响应完成后，返回的响应头内容也不一样，例如200 OK表示不使用断点续传的方式，206则表示使用断点续传的方式</li>
<li>增强校验：在实际场景中，会出现一种情况，即在终端发起续传请求时，URL 对应的文件内容在服务器端已经发生变化，此时续传的数据肯定是错误的。如何解决这个问题了？显然此时需要有一个标识文件唯一性的方法。在 RFC2616 中也有相应的定义，比如实现Last-Modified 来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动。同时 FC2616 中还定义有一个 ETag 的头，可以使用 ETag 头来放置文件的唯一标识。<br>2.工作原理</li>
<li>第一次请求：客户端发起GET请求一个文件，服务器处理请求，返回文件内容以及相应的 Header，其中包括 Etag（例如：627-4d648041f6b80）（假设服务器支持 Etag 生成并已开启了 Etag）状态码为 200。</li>
<li>第二次请求（断点续传）：客户端发起 HTTP GET 请求一个文件，同时发送 If-Range（该头的内容就是第一次请求时服务器返回的 Etag：627-4d648041f6b80）。<br>服务器判断接收到的 Etag 和计算出来的 Etag 是否匹配，如果匹配，那么响应的状态码为 206；否则，状态码为 200。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/05/%E7%89%9B%E5%AE%A2c-%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/05/%E7%89%9B%E5%AE%A2c-%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">牛客C++面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-05 20:15:56" itemprop="dateCreated datePublished" datetime="2022-07-05T20:15:56+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:46:43" itemprop="dateModified" datetime="2024-04-26T10:46:43+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">总结笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一-C-部分"><a href="#一-C-部分" class="headerlink" title="一. C++部分"></a>一. C++部分</h1><h3 id="1-说一说指针和引用的区别"><a href="#1-说一说指针和引用的区别" class="headerlink" title="1.说一说指针和引用的区别"></a>1.说一说指针和引用的区别</h3><p>指针内部保存的是指向的对象的地址信息，而引用是变量的别名；<br>指针可以随时初始化，而引用被定义之后就要初始化，不可以为空<br>sizeof引用是被引用的对象的大小，而sizeof指针是指针类型的大小<br>指针既有顶层const（指针本身不能变），也有底层const（指针指向的对象不能变），而引用只有底层const，顶层const是无意义的。<br>二者的<code>++</code>操作不同，指针<code>++</code>表示指针运算，而引用<code>++</code>表示变量执行<code>++</code>。<br>引用只是C++的语法糖，可以看作是自动取地址解引用的常量指针。在汇编层面是一样的。</p>
<h3 id="2-struct和class的区别"><a href="#2-struct和class的区别" class="headerlink" title="2.struct和class的区别"></a>2.struct和class的区别</h3><p>默认的（继承）访问权限，class是private，struct默认是public<br>class可以实现模板类，而struct不可以<br>struct是值类型，而class是引用类型</p>
<h3 id="3-C-中多态"><a href="#3-C-中多态" class="headerlink" title="3.C++中多态"></a>3.C++中多态</h3><p>为了使代码重用性增加，使得代码可以模块化<br>静态多态：通过重载函数和泛型编程实现，通过基类指针指向的对象不同而调用不同的函数。是在编译器就完成的，编译器根据实参类型来确定。具有更好的类型安全性，因为编译阶段会对所有的绑定类型进行检查。<br>动态多态：通过虚函数和继承实现，运行时确定。虚函数表保存在只读数据段，编译器将类对象的前四个字节设置为指向虚函数表的指针。</p>
<h3 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4.面向对象"></a>4.面向对象</h3><p>面向对象的三大特征：封装、继承、多态。封装：将客观事物进行抽象，将其属性和方法合成为一个类，类封装了成员变量和成员函数，同时又实现对属性和方法的权限控制，降低与外界的耦合度 继承：子类继承父类的各种属性和方法，同时子类还可以在父类的基础上重新定义和扩展父类的属性和方法，使其具有不同的功能，继承提高了代码的复用性及可维护性 多态：同一调用语句在父类和子类间使用时具有不同的表现形式，可以使用同一段代码处理不行类型的对象，提高代码的复用性</p>
<h3 id="5-浅拷贝和深拷贝"><a href="#5-浅拷贝和深拷贝" class="headerlink" title="5.浅拷贝和深拷贝"></a>5.浅拷贝和深拷贝</h3><p>浅拷贝 (Shallow Copy) 只复制某个对象的指针, 而不复制对象本身, 新旧对象还是共享同一块内存。在对象析构后，容易产生指针访问一个不存在的对象，从而产生悬空指针。<br>深拷贝 (Deep Copy) 在拷贝的过程中会另外创造一个一模一样的对象. 新对象跟原对象不共享内存, 修改新对象不会改到原对象. </p>
<h3 id="6-STL容器的实现和查找时间复杂度"><a href="#6-STL容器的实现和查找时间复杂度" class="headerlink" title="6.STL容器的实现和查找时间复杂度"></a>6.STL容器的实现和查找时间复杂度</h3><ol>
<li>vector 采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为： 插入: O(N) 查看: O(1) 删除: O(N) 2. deque 采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为： 插入: O(N) 查看: O(1) 删除: O(N) 3. list 采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为： 插入: O(1) 查看: O(N) 删除: O(1) 4. map、set、multimap、multiset 上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为: 插入: O(logN) 查看: O(logN) 删除: O(logN) 5. unordered_map、unordered_set、unordered_multimap、 unordered_multiset 上述四种容器采用哈希表实现，不同操作的时间复杂度为： 插入: O(1)，最坏情况O(N) 查看: O(1)，最坏情况O(N) 删除: O(1)，最坏情况O(N) 注意：容器的时间复杂度取决于其底层实现方式。</li>
</ol>
<h3 id="7-STL-中容器的类型，每种分别有哪些容器"><a href="#7-STL-中容器的类型，每种分别有哪些容器" class="headerlink" title="7.STL 中容器的类型，每种分别有哪些容器"></a>7.STL 中容器的类型，每种分别有哪些容器</h3><ol>
<li>序列式容器 array、vector、deque、list、forward_list 2. 关联式容器 map、multimap、set、multiset 3. 无序关联式容器 unordered_map、unordered_multimap、unordered_set、unordered_multiset 4. 容器适配器 stack、queue、priority_queue</li>
</ol>
<h3 id="8-简述一下-C-的重载和重写"><a href="#8-简述一下-C-的重载和重写" class="headerlink" title="8.简述一下 C++ 的重载和重写"></a>8.简述一下 C++ 的重载和重写</h3><ol>
<li>重载<br>a. 重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同（参数列表不同）。调用的时候根据函数的参数来区别不同的函数，函数重载跟返回值无关。<br>b. 重载的规则 - 函数名相同 - 必须具有不同的参数列表 - 可以有不同的访问修饰符<br>c. 重载用来实现静态多态（函数名相同，功能不一样）。<br>d. 重载是多个函数或者同一个类中方法之间的关系，是平行关系。</li>
<li>重写<br>a. 重写（也叫覆盖）是指在派生类中重新对基类中的虚函数重新实现。即函数名和参数都一样，只是函数的实现体不一样。<br>b. 重写的规则： - 方法声明必须完全与父类中被重写的方法相同 - 访问修饰符的权限要大于或者等于父类中被重写的方法的访问修饰符 - 子类重写的方法可以加virtual，也可以不加<br>c. 重写用来实现动态多态（根据调用方法的对象的类型来执行不同的函数）。<br>d. 重写是父类和子类之间的关系，是垂直关系。</li>
</ol>
<p>隐藏的实质是：在函数查找时，名字查找先于类型检查。如果派生类中成员和基类中的成员同名，就隐藏掉。编译器首先在相应作用域中查找函数，如果找到名字一样的则停止查找。</p>
<h3 id="9-简述一下虚函数的实现原理"><a href="#9-简述一下虚函数的实现原理" class="headerlink" title="9.简述一下虚函数的实现原理"></a>9.简述一下虚函数的实现原理</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75172640">https://zhuanlan.zhihu.com/p/75172640</a></p>
<ol>
<li>C++ 中的虚函数的作用主要是实现了动态多态的机制。 2. 虚函数实现原理 编译器处理虚函数时，给每个对象添加一个隐藏的成员。隐藏的成员是一个指针类型的数据，指向的是函数地址数组，这个数组被称为虚函数表（virtual function table，vtbl）。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚函数表中保存的是派生类的虚函数地址，如果派生类没有重写基类中的虚函数，则派生类对象的虚函数表中保存的是父类的虚函数地址。使用虚函数时，对于内存和执行速度方面会有一定的成本： 1. 每个对象都会变大，变大的量为存储虚函数表指针； 2. 对于每个类，编译器都会创建一个虚函数表； 3. 对于每次调用虚函数，都需要额外执行一个操作，就是到表中查找虚函数地址。</li>
</ol>
<h3 id="10-为什么将析构函数设置成虚函数"><a href="#10-为什么将析构函数设置成虚函数" class="headerlink" title="10.为什么将析构函数设置成虚函数"></a>10.为什么将析构函数设置成虚函数</h3><p>虚析构函数的主要作用是为了防止遗漏资源的释放，防止内存泄露。如果基类中的析构函数没有声明为虚函数，基类指针指向派生类对象时，则当基类指针释放时不会调用派生类对象的析构函数，而是调用基类的析构函数，如果派生类析构函数中做了某些释放资源的操作，则这时就会造成内存泄露。</p>
<h3 id="11-哈希冲突的原因和影响因素，哈希冲突的解决方法"><a href="#11-哈希冲突的原因和影响因素，哈希冲突的解决方法" class="headerlink" title="11.哈希冲突的原因和影响因素，哈希冲突的解决方法"></a>11.哈希冲突的原因和影响因素，哈希冲突的解决方法</h3><ol>
<li>哈希冲突产生的原因 哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过哈希函数产生的哈希值是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的值，这时候就产生了哈希冲突。</li>
<li>产生哈希冲突的影响因素 装填因子（装填因子&#x3D;数据总数 &#x2F; 哈希表长）、哈希函数、处理冲突的方法 </li>
<li>哈希冲突的解决方法<br>a.开放地址方法：如果冲突，则根据冲突的值再建立一个值，如果还冲突就重复操作直到不再冲突<br>b.链式地址法：将所有冲突的都放入一个链表中<br>c.建立公共溢出区：基本表和溢出表<br>d.再哈希法：同时构建多个哈希函数，一个发生冲突就使用另一个</li>
</ol>
<h3 id="12-map，unordered-map-的区别"><a href="#12-map，unordered-map-的区别" class="headerlink" title="12.map，unordered_map 的区别"></a>12.map，unordered_map 的区别</h3><p>map：内部实现了一个红黑树，该结构具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素，因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了 map 的效率。<br>unordered_map：内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。</p>
<h3 id="13-红黑树的特性，为什么要有红黑树"><a href="#13-红黑树的特性，为什么要有红黑树" class="headerlink" title="13.红黑树的特性，为什么要有红黑树"></a>13.红黑树的特性，为什么要有红黑树</h3><p>在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树，红黑树具有如下特点：<br> 1、具有二叉查找树的特点；<br> 2、根节点是黑色的；<br> 3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；<br> 4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；<br> 5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。</p>
<h3 id="14-vector-的扩容机制，扩容以后，它的内存地址会变化吗？"><a href="#14-vector-的扩容机制，扩容以后，它的内存地址会变化吗？" class="headerlink" title="14.vector 的扩容机制，扩容以后，它的内存地址会变化吗？"></a>14.vector 的扩容机制，扩容以后，它的内存地址会变化吗？</h3><p> 当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步： 1. 完全弃用现有的内存空间，重新申请更大的内存空间； 2. 将旧内存空间中的数据，按原有顺序移动到新的内存空间中； 3. 最后将旧的内存空间释放。 因为 vector 扩容需要申请新的空间，所以扩容以后它的内存地址会发生改变。vector 扩容是非常耗时的，为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity&gt;&#x3D;size），以便后期使用。<br> vector底层使用三个指针来实现，分别是：顺序表头，顺序表的有效长度位置，顺序表末尾。<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51723227/article/details/121374795#:~:text=%E5%9C%A8%E6%A0%87%E5%87%86C%2B%2B%E4%B8%AD%2C,%2C%E8%BE%BE%E5%88%B0%E5%AD%98%E5%82%A8%E6%95%88%E6%9E%9C">https://blog.csdn.net/m0_51723227/article/details/121374795#:~:text=%E5%9C%A8%E6%A0%87%E5%87%86C%2B%2B%E4%B8%AD%2C,%2C%E8%BE%BE%E5%88%B0%E5%AD%98%E5%82%A8%E6%95%88%E6%9E%9C</a>.</p>
<h3 id="15-请你说说-map-实现原理，各操作的时间复杂度是多少"><a href="#15-请你说说-map-实现原理，各操作的时间复杂度是多少" class="headerlink" title="15.请你说说 map 实现原理，各操作的时间复杂度是多少"></a>15.请你说说 map 实现原理，各操作的时间复杂度是多少</h3><ol>
<li>map 实现原理 map 内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而 AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此 map 内部所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map 中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值，使用中序遍历可将键值按照从小到大遍历出来。 2. 各操作的时间复杂度 插入: O(logN) 查看: O(logN) 删除: O(logN)</li>
</ol>
<h3 id="16-shared-ptr-怎么知道跟它共享对象的指针释放了"><a href="#16-shared-ptr-怎么知道跟它共享对象的指针释放了" class="headerlink" title="16.shared_ptr 怎么知道跟它共享对象的指针释放了"></a>16.shared_ptr 怎么知道跟它共享对象的指针释放了</h3><p>shared_ptr基于”引用计数”模型实现，多个shared_ptr可指向同一个动态对象，并维护一个共享的引用计数器，记录了引用同一对象的shared_ptr实例的数量。当最后一个指向动态对象的shared_ptr销毁时，会自动销毁其所指对象(通过delete操作符)。</p>
<h3 id="17-请你说说左值、右值、左值引用、右值引用、右值引用的使用场景"><a href="#17-请你说说左值、右值、左值引用、右值引用、右值引用的使用场景" class="headerlink" title="17.请你说说左值、右值、左值引用、右值引用、右值引用的使用场景"></a>17.请你说说左值、右值、左值引用、右值引用、右值引用的使用场景</h3><ol>
<li>左值 在 C++ 中可以取地址的、有名字的就是左值 int a &#x3D; 10; &#x2F;&#x2F; 其中 a 就是左值 </li>
<li>右值 不能取地址的、没有名字的就是右值 int a &#x3D; 10; &#x2F;&#x2F; 其中 10 就是右值右值 </li>
<li>左值引用 左值引用就是对一个左值进行引用。传统的 C++ 引用（现在称为左值引用）使得标识符关联到左值。左值是一个表示数据的表达式（如变量名或解除引用的指针），程序可获取其地址。最初，左值可出现在赋值语句的左边，但修饰符 const 的出现使得可以声明这样的标识符，即不能给它赋值，但可获取其地址： int n; int * pt &#x3D; new int; const int b &#x3D; 101; int &amp; rn &#x3D; n; int &amp; rt &#x3D; *pt; const int &amp; rb &#x3D; b; const int &amp; rb &#x3D; 10; </li>
<li>右值引用 右值引用就是对一个右值进行引用。C++ 11 新增了右值引用（rvalue reference），这种引用可指向右值（即可出现在赋值表达式右边的值），但不能对其应用地址运算符。右值包括字面常量（C-风格字符串除外，它表示地址）、诸如 x + y 等表达式以及返回值的函数（条件是该函数返回的不是引用），右值引用使用 &amp;&amp; 声明： int x &#x3D; 10; int y &#x3D; 23; int &amp;&amp; r1 &#x3D; 13; int &amp;&amp; r2 &#x3D; x + y; double &amp;&amp; r3 &#x3D; std::sqrt(2.0); </li>
<li>右值引用的使用场景 右值引用可以实现移动语义、完美转发。</li>
</ol>
<h3 id="17-weak-ptr-如何解决-shared-ptr-的循环引用问题？"><a href="#17-weak-ptr-如何解决-shared-ptr-的循环引用问题？" class="headerlink" title="17.weak_ptr 如何解决 shared_ptr 的循环引用问题？"></a>17.weak_ptr 如何解决 shared_ptr 的循环引用问题？</h3><p>weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数，依此特性可以解决 shared_ptr 的循环引用问题。 weak_ptr 没有解引用 * 和获取指针 -&gt; 运算符，它只能通过 lock 成员函数去获取对应的 shared_ptr 智能指针对象，从而获取对应的地址和内容。 不论是否有 weak_ptr 指向，一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。</p>
<h3 id="18-请你说说虚函数可以是内联函数吗"><a href="#18-请你说说虚函数可以是内联函数吗" class="headerlink" title="18.请你说说虚函数可以是内联函数吗"></a>18.请你说说虚函数可以是内联函数吗</h3><p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可以内联。virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
<h3 id="19-请你说说迭代器失效原因，有哪些情况"><a href="#19-请你说说迭代器失效原因，有哪些情况" class="headerlink" title="19.请你说说迭代器失效原因，有哪些情况"></a>19.请你说说迭代器失效原因，有哪些情况</h3><p>STL 中某些容器调用了某些成员方法后会导致迭代器失效。例如 vector 容器，如果调用 reserve() 来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector 容器的元素可能已经被复制或移到了新的内存地址。 </p>
<ol>
<li>序列式容器迭代器失效 对于序列式容器，例如 vector、deque，由于序列式容器是组合式容器，当当前元素的迭代器被删除后，其后的所有元素的迭代器都会失效，这是因为 vector、deque都是连续存储的一段空间，所以当对其进行 erase 操作时，其后的每一个元素都会向前移一个位置。解决：erase 返回下一个有效的迭代器。 </li>
<li>关联式容器迭代器失效 对于关联容器，例如如 map、 set，删除当前的迭代器，仅仅会使当前的迭代器失效，只要在 erase 时，递增当前迭代器即可。这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个节点不会对其他点造成影响。erase 迭代器只是被删元素的迭代器失效，但是返回值为 void，所以要采用 erase(iter++) 自增方式删除迭代器。</li>
</ol>
<h3 id="20-请你说说-auto-和-decltype-如何使用"><a href="#20-请你说说-auto-和-decltype-如何使用" class="headerlink" title="20.请你说说 auto 和 decltype 如何使用"></a>20.请你说说 auto 和 decltype 如何使用</h3><p>auto 实现自动类型推断，要求进行显示初始化，让编译器能够将变量的类型设置为初始值的类型<br>decltype 将变量的类型声明为表达式指定的类型。decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型,而且decltype并不会对表达式进行求值。</p>
<h3 id="21-说说-C-中智能指针和指针的区别是什么？"><a href="#21-说说-C-中智能指针和指针的区别是什么？" class="headerlink" title="21.说说 C++ 中智能指针和指针的区别是什么？"></a>21.说说 C++ 中智能指针和指针的区别是什么？</h3><p>智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。指针是一种数据类型，用于保存内存地址，而智能指针是类模板。</p>
<h3 id="22-简述一下-C-中的四种类型转换"><a href="#22-简述一下-C-中的四种类型转换" class="headerlink" title="22.简述一下 C++ 中的四种类型转换"></a>22.简述一下 C++ 中的四种类型转换</h3><p>1.static_cast 静态转换 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换 - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的 - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的 用于基本数据类型之间的转换，如把 int 转换成 char，把 char 转换成 int。这种转换的安全性也要开发人员来保证<br>2.dynamic_cast 动态转换 dynamic_cast 主要用于类层次间的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的 在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全<br>3. const_cast 常量转换 该运算符用来修改类型的const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 常量引用被转换成非常量引用，并且仍然指向原来的对象 注意:不能直接对非指针和非引用的变量使用 const_cast 操作符<br>4. reinterpret_cast 重新解释转换 这是最不安全的一种转换机制，最有可能出问题 主要用于将一种数据类型从一种类型转换为另一种类型，它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针</p>
<h1 id="new-和-delete-是如何实现的"><a href="#new-和-delete-是如何实现的" class="headerlink" title="new 和 delete 是如何实现的"></a>new 和 delete 是如何实现的</h1><p>1.new的实现过程是：首先调用名为operator new 的标准库函数，分配足够大的内存来保存指定类型的一个对象，接下来运行该类型的构造函数，用于初始化该对象，最后返回该对象的指针。<br>2.delete的实现过程：对指针指向的对象运行适当的析构函数，然后调用operator delete的标准库函数释放该对象的内存</p>
<h1 id="指针占多少字节"><a href="#指针占多少字节" class="headerlink" title="指针占多少字节"></a>指针占多少字节</h1><p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。32位编译环境下为4字节，64位编译环境下为8字节</p>
<h1 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h1><p>1.顶层const可以表示任意的对象是常量，这一点对任何数据类型都使用，底层const则与指针和引用的复合类型有关<br>2.当执行对象的拷贝操作时，顶层const不受什么影响，但是底层const的限制不能被忽略。<br>3.对于重载，顶层const不构成重载，底层const构成重载</p>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><p>1.列不可再分<br>2.属性完全依赖于主键（一张表中包含了多种不同的属性，那么必须要分成多张表）<br>3.属性不依赖于其他非主属性（要求已经分好了多张表的话，一张表中只能有另一张表的ID，而不能有其他任何信息）</p>
<h1 id="类成员继承权限问题"><a href="#类成员继承权限问题" class="headerlink" title="类成员继承权限问题"></a>类成员继承权限问题</h1><p>1.若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；<br>2.若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；<br>3.若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</p>
<h1 id="禁止隐式转换"><a href="#禁止隐式转换" class="headerlink" title="禁止隐式转换"></a>禁止隐式转换</h1><p>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
<h1 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h1><p>1.数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)&#x2F;sizeof(数组元素数据类型)；<br>2.用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。<br>3.在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</p>
<h1 id="写一个比较大小的模板"><a href="#写一个比较大小的模板" class="headerlink" title="写一个比较大小的模板"></a>写一个比较大小的模板</h1><pre><code>template&lt;typename type1, typename type2&gt;

type1 max(type1 a, type2 b)&#123;
    return a &gt; b ? a : b;
&#125;

void main()&#123;
    cout &lt;&lt; max(5.5, &#39;a&#39;) &lt;&lt; endl;
&#125;
</code></pre>
<p>其实该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a &gt; b 这一步是会报错的。这个时候往往需要对于 &gt; 号进行重载，这代码量瞬间上来了。</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数，比如epoll中可以通过回调函数找到对应的红黑树节点。</p>
<h1 id="delete和delete-的区别"><a href="#delete和delete-的区别" class="headerlink" title="delete和delete[]的区别"></a>delete和delete[]的区别</h1><p>delete只会调用一次析构函数。<br>delete[]会调用数组中每个元素的析构函数</p>
<h1 id="类的对象存储空间"><a href="#类的对象存储空间" class="headerlink" title="类的对象存储空间"></a>类的对象存储空间</h1><p>1.非静态成员的数据类型大小之和。<br>2.编译器加入的额外成员变量（如指向虚函数表的指针）。<br>3.为了边缘对齐优化加入的padding。<br>4.空类(无非静态数据成员)的对象的size为1,这样可以保证每个实例均有独占的内存地址，当作为基类时, size为0，如果带有虚函数，则大小比1大，因为还需要包含一个虚函数表指针<br>5.成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。</p>
<h1 id="在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h1><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题</p>
<h1 id="如果在类的析构函数中调用delete-this，会发生什么？"><a href="#如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="如果在类的析构函数中调用delete this，会发生什么？"></a>如果在类的析构函数中调用delete this，会发生什么？</h1><p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h1 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a>auto和decltype的区别</h1><h1 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h1><p>1.利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；<br>2.每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。<br>3.lambda语法如下：</p>
<pre><code>[capture] （parameters） mutable -&gt;return-type &#123;statement&#125;;
</code></pre>
<p>4.lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p>
<h1 id="STL中hashtable的实现"><a href="#STL中hashtable的实现" class="headerlink" title="STL中hashtable的实现"></a>STL中hashtable的实现</h1><p>1.STL中的hashtable使用的是开链法解决hash冲突问题<br>2.hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p>
<h1 id="vector如何释放空间"><a href="#vector如何释放空间" class="headerlink" title="vector如何释放空间"></a>vector如何释放空间</h1><p>1.由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。<br>2.如果使用vector，可以用swap()来帮助你释放多余内存或者清空全部内存。</p>
<h1 id="容器内删除一个元素"><a href="#容器内删除一个元素" class="headerlink" title="容器内删除一个元素"></a>容器内删除一个元素</h1><p>1.顺序容器（序列式容器，比如vector、deque）<br>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</p>
<pre><code>it = c.erase(it);
</code></pre>
<p>2.关联容器(关联式容器，比如map、set、multimap、multiset等)<br>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</p>
<pre><code>c.erase(it++)
</code></pre>
<h1 id="STL每种容器对应的迭代器"><a href="#STL每种容器对应的迭代器" class="headerlink" title="STL每种容器对应的迭代器"></a>STL每种容器对应的迭代器</h1><p>1.vector和deque：随机访问迭代器<br>2.stack、queue、priority_queue：无<br>3.list、(multi)set&#x2F;map：双向迭代器<br>unordered_(multi)set&#x2F;map、forward_list：前向迭代器</p>
<h1 id="sizeof和strlen的区别"><a href="#sizeof和strlen的区别" class="headerlink" title="sizeof和strlen的区别"></a>sizeof和strlen的区别</h1><p>1、sizeof会将空字符\0计算在内，而strlen不会将空字符\0计算在内；<br>2、sizeof会计算到字符串最后一个空字符\0并结束，而strlen如果遇到第一个空字符\0的话就会停止并计算遇到的第一个空字符\0前面的长度。</p>
<pre><code>int main(void)
&#123;
    char str[100] = &quot;abcde&quot;;
    printf(&quot;sizeof(str) = %lu\n&quot;, sizeof(str));     //字节大小为100

    char str1[] = &quot;abcde&quot;;
    printf(&quot;sizeof(str1) = %lu\n&quot;, sizeof(str1));   //字节大小为6

    char str2[] = &quot;\0abcde&quot;;
    printf(&quot;sizeof(str2) = %lu\n&quot;, sizeof(str2));   //字节大小为7

    char str3[] = &quot;\0ab\0c de&quot;;
    printf(&quot;sizeof(str3) = %lu\n&quot;, sizeof(str3));   //字节大小为9

    char str4[] = &quot;abcde&quot;;
    printf(&quot;strlen(str4) = %lu\n&quot;, strlen(str4));   //字符串长度为5

    char str5[100] = &quot;abcde&quot;;
    printf(&quot;strlen(str5) = %lu\n&quot;, strlen(str5));   //字符串长度为5

    char str6[] = &quot;\0abcde&quot;;
    printf(&quot;strlen(str6) = %lu\n&quot;, strlen(str6));   //字符串长度为0

    char str7[] = &quot;ab cde&quot;;
    printf(&quot;strlen(str7) = %lu\n&quot;, strlen(str7));   //字符串长度为6

    return 0;
&#125;
</code></pre>
<h1 id="哪些函数不能是虚函数？把你知道的都说一说"><a href="#哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="哪些函数不能是虚函数？把你知道的都说一说"></a>哪些函数不能是虚函数？把你知道的都说一说</h1><p>1.构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造<br>2.内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；<br>3.静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。<br>4.友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。<br>5.普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p>
<h1 id="什么时候必须要自定义析构函数"><a href="#什么时候必须要自定义析构函数" class="headerlink" title="什么时候必须要自定义析构函数"></a>什么时候必须要自定义析构函数</h1><p>如果本类中一个成员变量是别的对象的指针，而且这个指针不是传进来的地址而是这个指针指向的对象，是在本类中(如果是栈里的定位分配，也不用考虑内存)在堆中开辟的空间创建的。并且该指针没有进行过delete操作，那么久需要在析构方法中进行delete操作，此时我们就必须自己写析构函数。</p>
<h1 id="析构函数的析构过程"><a href="#析构函数的析构过程" class="headerlink" title="析构函数的析构过程"></a>析构函数的析构过程</h1><p>析构函数首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁。注意析构函数本身不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，销毁类类型成员执行它自己的析构函数，销毁内置类型不需要做什么。</p>
<h1 id="何时会调用析构函数"><a href="#何时会调用析构函数" class="headerlink" title="何时会调用析构函数"></a>何时会调用析构函数</h1><ul>
<li>变量在离开其作用域时</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁</li>
<li>对于动态分配的对象，当指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<h1 id="什么时候需要自己重写拷贝构造函数"><a href="#什么时候需要自己重写拷贝构造函数" class="headerlink" title="什么时候需要自己重写拷贝构造函数"></a>什么时候需要自己重写拷贝构造函数</h1><p>根据三&#x2F;五法则，如果需要定义一个非空的析构函数，那么通常情况下也需要自定义一个拷贝构造函数。即包含动态分配成员或者包含指针成员的类都应该提供拷贝构造函数，并且考虑重载赋值运算符。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/04/%E4%B8%AD%E6%9C%9B%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/04/%E4%B8%AD%E6%9C%9B%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">中望面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-04 22:52:06" itemprop="dateCreated datePublished" datetime="2022-07-04T22:52:06+08:00">2022-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:57:43" itemprop="dateModified" datetime="2024-04-26T10:57:43+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">总结笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.多态，运行时多态（虚函数表和继承），静态多态（重载和模板编程）<br>2.如何实现对象只能分配在栈上：c++中，类的对象建立分为两种，</p>
<ul>
<li>静态建立:由编译器在栈上为对象开辟空间，直接调用类的构造函数。<br>  <code>A a;</code></li>
<li>动态建立：由new关键字将对象建立在堆空间上，首先执行 operator new()函数，在堆上搜索合适的内存并分配，第二步是调用构造函数构造对象。即间接的调用类的构造函数。<br>  <code>A a = new A;</code><br>（1）只有使用new关键字才能在堆上建立对象，那么我们就可以将operator new()函数自行声明为私有函数即可，或者设置为delete。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private；</span><br><span class="line">    void* operator new(size_t t)&#123;&#125; //设置为私有</span><br><span class="line">    void operator delete(void *ptr)&#123;&#125;</span><br><span class="line">public:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>（2）只在堆上分配新对象<br>即不能直接调用类的构造函数。首先要知道，当对象建立在栈上面时, 是由编译器分配内存空间的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间。实际上，编译器在为类对象分配栈空间时, 会检查类的析构函数的访问性(其他非静态函数也会检查)，如果类的析构函数是私有的，则编程器不会在栈空间上为类对象分配内存。因此,我们只需要将析构函数设为私有，类对象就无法建立在栈上了。<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    A()&#123;&#125;</span><br><span class="line">    void destroy(delete this;)</span><br><span class="line">private:</span><br><span class="line">    ~A()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，由于new表达式会在分配内存以后调用构造函数，因此构造函数必须是公有的，同时由于delete此时无法访问私有的析构函数，因此必须提供一个destroy函数，来进行内存空间的释放。<br>3.c++11新特性<br>auto，智能指针，移动语义（右值引用），完美转发<br>4.内联函数和宏的区别</p>
<ul>
<li>内联函数是函数，有参数类型检查，更为安全</li>
<li>内联函数由编译器进行处理，而宏定义由预处理器进行处理</li>
<li>内联函数处理时被插入到对应代码区域，而宏定义只是简单的文本替换</li>
</ul>
<p>5.多线程<br>半同步半反应线程池<br>主线程充当异步线程，负责监听所有socket上的事件，若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件，并将数据封装成请求对象插入到请求队列中；所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</p>
<p>6.Linux进程调度和内存管理<br>7.设计模式<br>工厂模式和单例模式，适配器模式和策略模式<br>8.lambda表达式<br>9.手撕strcpy（不用任何库函数)<br>10.快排的 算法原理+手撕代码。<br>11.读代码说输出结果：一个简单的子类继承父类的代码<br>子类析构时，首先执行子类析构函数体的代码，然后执行子类成员对象所在类的析构函数，最后按照子类继承各个父类的次序，倒序各个父类的析构函数<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/371322392">https://zhuanlan.zhihu.com/p/371322392</a></p>
<p>12.栈溢出的原因<br>内存中栈一般存放，函数地址、函数参数、局部变量等信息存储于栈内存；<br>1&gt;函数调用层次过深，每调用一次，函数的参数、局部变量等信息就压一次栈。<br>2&gt;局部变量体积太大</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gaotf</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
