<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="热爱技术，笔耕不辍">
<meta property="og:type" content="website">
<meta property="og:title" content="漱石斋笔谈">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="漱石斋笔谈">
<meta property="og:description" content="热爱技术，笔耕不辍">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="gaotf">
<meta property="article:tag" content="PostgreSQL">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>漱石斋笔谈</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">漱石斋笔谈</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">gaotf 的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gaotf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">gaotf</p>
  <div class="site-description" itemprop="description">热爱技术，笔耕不辍</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/1170300619" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1170300619" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3469205806@qq.com" title="E-Mail → 3469205806@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/15/Java%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/15/Java%E6%B3%9B%E5%9E%8B/" class="post-title-link" itemprop="url">Java泛型</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-15 13:20:14" itemprop="dateCreated datePublished" datetime="2021-05-15T13:20:14+08:00">2021-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:54:15" itemprop="dateModified" datetime="2024-04-26T10:54:15+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E6%B3%9B%E5%9E%8B/" itemprop="url" rel="index"><span itemprop="name">泛型</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-为什么要使用泛型设计"><a href="#1-为什么要使用泛型设计" class="headerlink" title="1.为什么要使用泛型设计"></a>1.为什么要使用泛型设计</h1><p><strong>泛型程序设计</strong>意味着编写的代码可以对多种不同类型的对象重用。例如，你不想为收集<strong>String</strong>和<strong>File</strong>对象分别编写不同的类。实际上，也不需要这样做，因为一个<strong>ArrayList</strong>类就可以收集任何类的对象。这就是泛型程序设计的一个例子。</p>
<pre><code>List arrayList = new ArrayList();
arrayList.add(&quot;aaaa&quot;);
arrayList.add(100);

for(int i = 0; i&lt; arrayList.size();i++)&#123;
    String item = (String)arrayList.get(i);
    Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);
&#125;
</code></pre>
<p>毫无疑问，这个程序会在运行时崩溃，为了解决这样的问题（在编译阶段就可以解决），泛型应运而生。我们将第一行声明初始化<strong>list</strong>的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<pre><code>List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
...
//arrayList.add(100); 在编译阶段，编译器就会报错
</code></pre>
<h1 id="2-泛型的特性"><a href="#2-泛型的特性" class="headerlink" title="2.泛型的特性"></a>2.泛型的特性</h1><p>泛型只在编译阶段有效，下面是一个经典的泛型的例子。</p>
<pre><code>List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();
List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();

Class classStringArrayList = stringArrayList.getClass();
Class classIntegerArrayList = integerArrayList.getClass();

if(classStringArrayList.equals(classIntegerArrayList))&#123;
    Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);
&#125;
</code></pre>
<p>输出的结果是<strong>类型相同</strong>。通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说<strong>Java</strong>中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<h1 id="3-泛型类"><a href="#3-泛型类" class="headerlink" title="3.泛型类"></a>3.泛型类</h1><p>通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：<strong>List</strong>，<strong>Set</strong>，<strong>Map</strong>。<br>泛型类的基本写法为：</p>
<pre><code>class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;
    private 泛型标识 /*（成员变量类型）*/ var; 
    .....
    &#125;
&#125;
</code></pre>
<p>下面我们实现一个简单的泛型类：</p>
<pre><code>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt;&#123; 
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    &#125;

    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    &#125;
&#125;
</code></pre>
<p>传入参数时：如果传入泛型类型实参，会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。</p>
<pre><code>//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型
//传入的实参类型需与泛型的类型参数类型相同，即为Integer.
Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);

//传入的实参类型需与泛型的类型参数类型相同，即为String.
Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());
</code></pre>
<p>如果不选择传入泛型类型实参：在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<pre><code>Generic generic = new Generic(&quot;111111&quot;);
Generic generic1 = new Generic(4444);
Generic generic2 = new Generic(55.55);
Generic generic3 = new Generic(false);

Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic1.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic2.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic3.getKey());
</code></pre>
<p><font face = "黑体" font color = "red">注意：</font></p>
<ul>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
<li>不能对确切的泛型类型使用<strong>instanceof</strong>操作。如下面的操作是非法的，编译时会出错。</li>
</ul>
<pre><code>if(ex_num instanceof Generic&lt;Number&gt;)&#123; &#125;
</code></pre>
<h1 id="4-泛型接口"><a href="#4-泛型接口" class="headerlink" title="4.泛型接口"></a>4.泛型接口</h1><p>泛型接口常被用在各种类的生产器中：</p>
<pre><code>//定义一个泛型接口
public interface Generation&lt;T&gt; &#123;
    public T next();
&#125;
</code></pre>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<pre><code>/**
* 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中
* 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;
* 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;
*/
class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;
    @Override
    public T next() &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<pre><code>/**
* 传入泛型实参时：
* 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;
* 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。
* 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型
* 此时不需要在声明类中的泛型声明T
* 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。
*/
public class FruitGenerator implements Generator&lt;String&gt; &#123;

    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;

    @Override
    public String next() &#123;
        Random rand = new Random();
        return fruits[rand.nextInt(3)];
    &#125;
&#125;
</code></pre>
<h1 id="5-泛型方法"><a href="#5-泛型方法" class="headerlink" title="5.泛型方法"></a>5.泛型方法</h1><p>泛型方法的基本形式：</p>
<pre><code>/**
* 泛型方法的基本介绍
* @param tClass 传入的泛型实参
* @return T 返回值为T类型
* 说明：
*     1）public与返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。
*     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
*     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
*     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
*/
public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,
IllegalAccessException&#123;
        T instance = tClass.newInstance();
        return instance;
&#125;
</code></pre>
<h2 id="5-1-泛型方法的基本用法"><a href="#5-1-泛型方法的基本用法" class="headerlink" title="5.1 泛型方法的基本用法"></a>5.1 泛型方法的基本用法</h2><pre><code>public class GenericTest &#123;
    //这个类是个泛型类，在上面已经介绍过
    public class Generic&lt;T&gt;&#123;     
        private T key;

        public Generic(T key) &#123;
            this.key = key;
        &#125;

        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
        //所以在这个方法中才可以继续使用 T 这个泛型。
        public T getKey()&#123;
            return key;
        &#125;

        /**
        * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;
        * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
        public E setKey(E key)&#123;
            this.key = keu
        &#125;
        */
    &#125;

    /** 
    * 这才是一个真正的泛型方法。
    * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
    * 这个T可以出现在这个泛型方法的任意位置.
    * 泛型的数量也可以为任意多个 
    *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;
    *        ...
    *        &#125;
    */
    public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;
        System.out.println(&quot;container key :&quot; + container.getKey());
        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。
        T test = container.getKey();
        return test;
    &#125;

    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。
    public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;
        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
    &#125;

    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?
    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类
    public void showKeyValue2(Generic&lt;?&gt; obj)&#123;
        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
    &#125;

    /**
    * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#39;E&#39; &quot;
    * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。
    * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。
    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;
        ...
    &#125;  
    */

    /**
    * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#39;T&#39; &quot;
    * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。
    * 所以这也不是一个正确的泛型方法声明。
    public void showkey(T genericObj)&#123;

    &#125;
    */

    public static void main(String[] args) &#123;
        ...
    &#125;
&#125;
</code></pre>
<h2 id="5-2-泛型类中的泛型方法"><a href="#5-2-泛型类中的泛型方法" class="headerlink" title="5.2 泛型类中的泛型方法"></a>5.2 泛型类中的泛型方法</h2><p>有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下：</p>
<pre><code>public class GenericFruit &#123;
    class Fruit&#123;
        @Override
        public String toString() &#123;
            return &quot;fruit&quot;;
        &#125;
    &#125;

    class Apple extends Fruit&#123;
        @Override
        public String toString() &#123;
            return &quot;apple&quot;;
        &#125;
    &#125;

    class Person&#123;
        @Override
        public String toString() &#123;
            return &quot;Person&quot;;
        &#125;
    &#125;

    class GenerateTest&lt;T&gt;&#123;
        public void show_1(T t)&#123;
            System.out.println(t.toString());
        &#125;

        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。
        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。
        public &lt;E&gt; void show_3(E t)&#123;
            System.out.println(t.toString());
        &#125;

        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。
        public &lt;T&gt; void show_2(T t)&#123;
            System.out.println(t.toString());
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Apple apple = new Apple();
        Person person = new Person();

        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();
        //apple是Fruit的子类，所以这里可以
        generateTest.show_1(apple);
        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person
        //generateTest.show_1(person);

        //使用这两个方法都可以成功
        generateTest.show_2(apple);
        generateTest.show_2(person);

        //使用这两个方法也都可以成功
        generateTest.show_3(apple);
        generateTest.show_3(person);
    &#125;
&#125;
</code></pre>
<h2 id="5-3-静态方法与泛型"><a href="#5-3-静态方法与泛型" class="headerlink" title="5.3 静态方法与泛型"></a>5.3 静态方法与泛型</h2><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p>
<pre><code>public class StaticGenerator&lt;T&gt; &#123;
    ....
    ....
    /**
    * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
    * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
    * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：
        &quot;StaticGenerator cannot be refrenced from static context&quot;
    */
    public static &lt;T&gt; void show(T t)&#123;

    &#125;
&#125;
</code></pre>
<h2 id="5-4-泛型方法总结"><a href="#5-4-泛型方法总结" class="headerlink" title="5.4 泛型方法总结"></a>5.4 泛型方法总结</h2><p>一个基本的指导原则：</p>
<pre><code>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，

那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。

所以如果static方法要使用泛型能力，就必须使其成为泛型方法。
</code></pre>
<h1 id="6-泛型上下边界"><a href="#6-泛型上下边界" class="headerlink" title="6.泛型上下边界"></a>6.泛型上下边界</h1><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。为泛型添加上边界，即传入的类型实参必须是指定类型的子类型。</p>
<pre><code>public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
&#125;
</code></pre>
<p>具体情况：</p>
<pre><code>Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);
Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);
Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);
Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);

//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类
//showKeyValue1(generic1);

showKeyValue1(generic2);
showKeyValue1(generic3);
showKeyValue1(generic4);
</code></pre>
<p>如果我们把泛型类的定义也修改一下：</p>
<pre><code>public class Generic&lt;T extends Number&gt;&#123;
    private T key;

    public Generic(T key) &#123;
        this.key = key;
    &#125;

    public T getKey()&#123;
        return key;
    &#125;
&#125;
</code></pre>
<p>这种情况下：</p>
<pre><code>//这一行代码也会报错，因为String不是Number的子类
Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);
</code></pre>
<p>再来看一个例子：</p>
<pre><code>//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加
//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;
public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;
    System.out.println(&quot;container key :&quot; + container.getKey());
    T test = container.getKey();
    return test;
&#125;
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/08/14/Ceres%20Solvel%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E5%BB%BA%E6%A8%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/08/14/Ceres%20Solvel%20%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%E5%BB%BA%E6%A8%A1/" class="post-title-link" itemprop="url">Ceres Solvel非线性最小二乘法建模</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-08-14 14:47:31" itemprop="dateCreated datePublished" datetime="2020-08-14T14:47:31+08:00">2020-08-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:58:57" itemprop="dateModified" datetime="2024-04-26T10:58:57+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ceres-Solvel/" itemprop="url" rel="index"><span itemprop="name">Ceres Solvel</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ceres-Solvel/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">最小二乘优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Ceres由两个部分组成，一个是建模API，它提供了非常丰富的工具，可以迅速构建一个优化问题模型。另一个是解算器API，用于管控最小化算法。这一章将围绕如何用Ceres进行优化问题建模展开。</p>
<h1 id="自动微分AutoDiffCostFunction"><a href="#自动微分AutoDiffCostFunction" class="headerlink" title="自动微分AutoDiffCostFunction"></a>自动微分AutoDiffCostFunction</h1><p>定义一个<font face = "黑体" font color = "red">CostFunction</font>（例如使用数值微分法或者解析微分法）可能是一个繁琐且容易出错的过程，尤其是在计算导数的时候。为此，Ceres提供了<font face = "黑体" font color = "red">AutoDiffCostFunction</font>。</p>
<pre><code>template &lt;typename CostFunctor,
        int kNumResiduals,  // Number of residuals, or ceres::DYNAMIC.
        int N0,       // Number of parameters in block 0.
        int N1 = 0,   // Number of parameters in block 1.
        int N2 = 0,   // Number of parameters in block 2.
        int N3 = 0,   // Number of parameters in block 3.
        int N4 = 0,   // Number of parameters in block 4.
        int N5 = 0,   // Number of parameters in block 5.
        int N6 = 0,   // Number of parameters in block 6.
        int N7 = 0,   // Number of parameters in block 7.
        int N8 = 0,   // Number of parameters in block 8.
        int N9 = 0&gt;   // Number of parameters in block 9.
class AutoDiffCostFunction : public
SizedCostFunction&lt;kNumResiduals, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9&gt; &#123;
    public:
        explicit AutoDiffCostFunction(CostFunctor* functor);
        // Ignore the template parameter kNumResiduals and use
        // num_residuals instead.
        AutoDiffCostFunction(CostFunctor* functor, int num_residuals);
&#125;;
</code></pre>
<p>为了获得一个可以自动微分的代价函数，必须定义一个类。这个类中带有模板函数：<font face = "黑体" font color = "red">operator()</font>，它使用模板T类型进行代价函数运算。自动微分将根据需要用<font face = "黑体" font color = "red">Jet</font>类型替代替代模板T。但这个是隐藏的，编程的时候要把这个T看作一个双精度浮点数。这个函数必须把计算结果以最后一个参数（唯一一个非常量参数）传递出来，并且返回<font face = "黑体" font color = "red">True</font>，告诉计算机运算成功完成。例如，现在有一个标量的偏差函数$e &#x3D; k - x^Ty$。这里$x$和$y$都是二维向量参数，$k$是个常量 。这种类型的偏差，即一个常量和一个表达式的差值，在最小二乘法问题中很常见。例如，$x ^ T y$可能是一系列测量结果的期望值，那么每一次测量$K$都对应了一个代价函数类的实例。被加到<font face = "黑体" font color = "red">Problem</font>中的是$e ^ 2$或者$(k - x^Ty) ^ 2$。平方处理由Ceres优化框架完成。这个例子的具体代码如下：</p>
<blockquote>
<p>这里有个疑问，之前自动微分算法的代码中没有使用类，而是使用的struct，不知道为什么这里是class，个人认为应该都可以，因为我们的代码中都使用的struct。</p>
</blockquote>
<pre><code>class MyScalarCostFunctor &#123;
    MyScalarCostFunctor(double k): k_(k) &#123;&#125;

template &lt;typename T&gt;
bool operator()(const T* const x , const T* const y, T* e) const &#123;
    e[0] = k_ - x[0] * y[0] - x[1] * y[1];
    return true;
&#125;

private:
    double k_;
&#125;;
</code></pre>
<p>注意，在<font face = "黑体" font color = "red">operator()</font>的声明中，首先是输入参数，他们都是指向T类型数组的常指针。如果由更多的输入参数就跟在<font face = "黑体" font color = "red">y</font>后面。而输出值永远是最后一个参数，并且也是一个指向数组的指针。在上述例子中，<font face = "黑体" font color = "red">e</font>是标量，所以只赋值<font face = "黑体" font color = "red">e[0]</font>。</p>
<p>然后给出这个类的定义，它的自动微分代价函数可以如下构造：</p>
<pre><code>CostFunction* cost_function
    = new AutoDiffCostFunction&lt;MyScalarCostFunctor, 1, 2, 2&gt;(
        new MyScalarCostFunctor(1.0));              ^  ^  ^
                                                    |  |  |
                        Dimension of residual ------+  |  |
                        Dimension of x ----------------+  |
                        Dimension of y -------------------+
</code></pre>
<p>在这个例子中，对每次测量<font face = "黑体" font color = "red">k</font>都有一个实例。模板参数1,2,2将<font face = "黑体" font color = "red">Functor</font>描述为一个一维输出参数和两个二维输入参数。<font face = "黑体" font color = "red">AutoDiffCostFunction</font>也支持在运行时动态确定参数个数。例如下面的代码：</p>
<pre><code>CostFunction* cost_function
    = new AutoDiffCostFunction&lt;MyScalarCostFunctor, DYNAMIC,  2,  2&gt;(
        new CostFunctorWithDynamicNumResiduals(1.0),    ^     ^  ^
        runtime_number_of_residuals);  &lt;----+           |     |  |
                                            |           |     |  |
                                            |           |     |  |
           Actual number of residuals ------+           |     |  |
           Indicate dynamic number of residuals --------+     |  |
           Dimension of x ------------------------------------+  |
           Dimension of y ---------------------------------------+
</code></pre>
<p>Ceres目前支持代价函数最多有10个相互独立的变量，但是对每个变量有多少维度没有限制。</p>
<p>注意，新用户常常犯的一个错误就是把模板参数中的数字理解成参数的个数。但事实上，模板参数中数字的含义是每个参数的维度。这两个概念不能混淆。比如在这个例子中<font face = "黑体" font color = "red">x,y</font>都是二维变量，所以模板参数中有两个2。</p>
<h1 id="Problem的构建"><a href="#Problem的构建" class="headerlink" title="Problem的构建"></a>Problem的构建</h1><p><font face = "黑体" font color = "red">Problem</font>保持了非线性最小二乘问题的强化的边界。要创建最小二乘问题，可以使用<font face = "黑体" font color = "red">Problem::AddResidualBlock()</font>和<font face = "黑体" font color = "red">Problem::AddParameterBlock()</font>。例如，下面这个Problem包含了三个参数块，维度分别为3，4，5。同时有两个残差块，维度分别是2和6。</p>
<pre><code>double x1[] = &#123; 1.0, 2.0, 3.0 &#125;;
double x2[] = &#123; 1.0, 2.0, 3.0, 5.0 &#125;;
double x3[] = &#123; 1.0, 2.0, 3.0, 6.0, 7.0 &#125;;

Problem problem;
problem.AddResidualBlock(new MyUnaryCostFunction(...), x1);
problem.AddResidualBlock(new MyBinaryCostFunction(...), x2, x3);
</code></pre>
<p><font face = "黑体" font color = "red">Problem::AddResidualBlock()</font>，顾名思义，就是把残差块加入到Problem中。它添加了一个<font face = "黑体" font color = "red">CostFunction</font>，一个<font face = "黑体" font color = "red">LossFunction</font>（非必要）并且把<font face = "黑体" font color = "red">CostFunction</font>链接到一系列的参数块上。代价函数包含了关于期望的参数块大小的信息。该函数检查他们是否与<font face = "黑体" font color = "red">parameter_blocks</font>一致。如果不匹配，程序将终止。<font face = "黑体" font color = "red">LossFunction</font>可以是<font face = "黑体" font color = "red">Null</font>，这种情况下这一项的代价就是残差的平方。</p>
<blockquote>
<p>另外官网中给出了很多Problem的方法，可以查看一下。这里只对添加残差块的方法给出了实例。</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/20/Ceres%20Solvel%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/20/Ceres%20Solvel%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AE%97/" class="post-title-link" itemprop="url">Ceres Solvel非线性最小二乘问题的解算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-20 14:47:31" itemprop="dateCreated datePublished" datetime="2020-07-20T14:47:31+08:00">2020-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:59:16" itemprop="dateModified" datetime="2024-04-26T10:59:16+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ceres-Solvel/" itemprop="url" rel="index"><span itemprop="name">Ceres Solvel</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ceres-Solvel/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">最小二乘优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>如果想要高效地使用Ceres Solver，需要掌握一定的非线性最小二乘解算基础知识。所以在这一部分将将要介绍Ceres中核心优化算法的工作原理。</p>
<p>设$x \in \mathbb{R}^n$是一个$n$维向量，并且$F(x) &#x3D; [f_1(x),\cdots,f_m(x)] ^ T$是关于$x$的$n$维方程。那么我们关注下列优化问题</p>
<p>$$<br>argmin_x \frac{1}{2} \left | F(x) \right | ^ 2 \<br>L \le x \le U<br>$$<br>其中$L$和$U$分别是参数向量$x$的下限和上限。</p>
<p>因为对于一个一般的函数，求解全局最小值常常非常棘手，我们不得不关注局部最小值。$F(x)$的雅可比矩阵$J(x)$是一个$m \times n$的矩阵，其中$J_{ij}(x) &#x3D; \partial _j f_i(x)$，函数的梯度向量$g(x) &#x3D; \nabla \frac{1}{2} \left | F(x) \right | ^ 2 &#x3D; J(x)^T F(x)$。</p>
<p>在计算非线性优化问题的一个通用的策略是，求解原问题的近似简化问题。在每一次循环中，根据近似问题的解可以确定向量$x$的修正值$\triangle x$。对于非线性最小二问题，我们可以通过线性化来建立近似问题，即$F(x + \triangle x) \approx F(x) + J(x) \triangle x$。那么上述问题就变成下列问题：</p>
<p>$$<br>min_{\triangle x} \frac{1}{2} \left |F(x) + J(x) \triangle x \right |^2<br>$$</p>
<blockquote>
<p>这里官方教程跳了几步。要求全局最小值非常棘手，所以转而求局部最小值。而求局部最小值就是，从一个任意的起始点，观测四周的“更小值”。如果观测四周都比当前点大，那么当前点就是局部最小值点，算法达到收敛。否则，设这个新找到的最小值点为“当前点”，重复这一步骤。这也就是下文中”<strong>用$x \longleftarrow x + \triangle x$来更新</strong>“的含义。所以现在问题变成了，如何求解四周的点的值。即，给$x$赋予一个步长$\triangle x$，观察周围的$F(x + \triangle x)$，并且寻找最小值。</p>
</blockquote>
<p>根据步长的控制方法，非线性优化可以分成两大类。</p>
<blockquote>
<ul>
<li><strong>置信域法Trust Region</strong> （也有文献成为<strong>信任域法</strong>）置信域方法在搜索空间的子集内应用<strong>模型函数</strong>（通常是二次方程）来近似<strong>目标函数</strong>，这个空间被称为<strong>置信域</strong>。如果模型函数成功地使真正的目标函数最小化，则扩大置信域。否则收缩置信域并且再次尝试求解模型函数的优化问题。</li>
<li><strong>线搜索法Line Search</strong> 线搜索方法首先找到一个下降的方向，目标函数将沿其下降。然后再确定步长，从而决定沿该方向到底移动多远。 下降方向可以通过各种方法计算，如梯度下降法、牛顿法和拟牛顿法。步长可以精确或不精确地确定。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>这里我们只对共轭梯度法进行介绍（因为我们用的库函数所采用的方法就是共轭梯度法）</strong></p>
</blockquote>
<p>对以下形式的线性最小二乘问题：</p>
<p>$$<br>min_{\triangle x} \frac{1}{2} \left |F(x) + J(x) \triangle x \right |^2<br>$$<br>令$H(x) &#x3D; J(x) ^ TJ(x)$且$g(x) &#x3D; - J(x) ^ {T}f(x)$。为了标记方便，我们舍弃对$x$的依赖，那么很容易看出求解上式等价于求解<font face = "黑体" font color = "red">Normal Equation</font>方程</p>
<p>$$<br>H\triangle x &#x3D; g<br>$$<br>我们在程序中使用的计算上式的线性解算器是<font face = "黑体"><strong>CGNR</strong></font>，该解算器在法向方程上使用共轭梯度求解器，但没有明确地构建<font face = "黑体">Normal Equation</font>方程。 它利用下列关系：</p>
<p>$$<br>Hx &#x3D; J ^ TJx &#x3D; J^T(Jx)<br>$$<br>共轭梯度的收敛取决于调节器数量$\kappa(H)$，通常$H$的条件比较弱，并且必须使用预调节器才能获得合理的性能。 目前只有<font face = "黑体" font color = "red">JACOBI</font>预处理器可以用于<font face = "黑体" font color = "red">CGNR</font>。它使用$H$的块对角线来预处理<font face = "黑体">Normal Equation</font>方程。</p>
<p>当用户选择<font face = "黑体">CGNR</font>作为线性求解器时，Ceres会自动从精确的步长算法切换到不精确的步长算法。</p>
<h1 id="JACOBI预处理器"><a href="#JACOBI预处理器" class="headerlink" title="JACOBI预处理器"></a>JACOBI预处理器</h1><p>求解<font face = "黑体" font color = "red">Normal Equation</font>方程的收敛速度取决于$H$的特征值的分布。一个有用的上界是$\sqrt {\kappa H}$，$\sqrt {\kappa H}$是矩阵$H$的条件值。对于大多数$BA$问题来说，$\sqrt {\kappa H}$很大，直接应用共轭梯度法对该方程进行求解会导致糟糕的性能。</p>
<p>这个问题的解决方法是用一个预条件系统来替换$H\triangle x &#x3D; g$方程。给定一个线性系统，$Ax &#x3D; b$，预条件器$M$，预条件系统$M^{-1} Ax &#x3D; M^{-1}b$。这个算法被称作预处理共轭梯度法（PCG），它最坏的情况现在取决于预条件矩阵$\sqrt{M^{-1}A}$的条件数。</p>
<p>使用预条件器$M$的计算成本是计算$M$以及任意向量$y$的乘积$M^{-1}y$，因此，要考虑两个相互竞争的因素：$H$的结构中有多少是由$M$占据的，以至于条件值$\kappa(HM^{-1})$，以及构造和使用$M$的计算成本。理想的预调节器是条件值$\kappa(M^{-1}A) &#x3D; 1$。使用$M &#x3D; A$可以实现这一效果，但是不是一个实际的选择，因为应用这个预调函数需要一个线性方程组，等价于无预先条件的问题。通常情况下，$M$的信息越多，使用的成本就越高。例如，基于不完全$Cholesky$分解的预条件器比$Jacobi$预条件器具有更好的收敛性能，但代价也更高。</p>
<p>所有的预调节器中最简单的是对角或雅可比的预调机。例如，$M &#x3D; diag(A)$。对于像$H$这样的块状结构矩阵，可以将其推广到$Jacobi$的预调节器。Ceres实现的块$Jacobi$预调节器叫做<font face = "黑体" font color = "red">JACOBI</font>，当使用<font face = "黑体" font color = "red">CGNR</font>时，它指的是$H$的块对角线，即</p>
<p>$$<br>C_{i j}&#x3D;\left{\begin{array}{cc}<br>A_{i i} &amp; \text { if } i&#x3D;j \<br>0 &amp; \text { 其他 }<br>\end{array}\right.<br>$$</p>
<p><font face = "黑体" >PCG</font>算法的过程如下：假设$x_0 \in \mathbb{R}^n$是初始向量，</p>
<p>$$<br>\begin{aligned}<br>&amp;r_{0}&#x3D;b-A x_{0}\<br>&amp;z_{0}&#x3D;C^{-1} r_{0}\<br>&amp;d_{0}&#x3D;z_{0}\<br>&amp;\text { For } k&#x3D;0,1,2, \ldots\<br>&amp;\alpha_{k}&#x3D;\frac{z_{k}^{\top} r_{k}}{d_{k}^{\top} A d_{k}}\<br>&amp;x_{k+1}&#x3D;x_{k}+\alpha_{k} d_{k}\<br>&amp;r_{k+1}&#x3D;r_{k}-\alpha_{k} A d_{k}\<br>&amp;z_{k+1}&#x3D;C^{-1} r_{k+1}\<br>&amp;\beta_{k+1}&#x3D;\frac{z_{k+1}^{\top} r_{k+1}}{z_{k}^{\top} r_{k}}\<br>&amp;d_{k+1}&#x3D;x_{k+1}+\beta_{k+1} d_{k}<br>\end{aligned}<br>$$</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/07/14/Ceres%20Solvel%E7%BF%BB%E8%AF%91%E7%AC%AC%E4%B8%80%E6%9C%9F-%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/07/14/Ceres%20Solvel%E7%BF%BB%E8%AF%91%E7%AC%AC%E4%B8%80%E6%9C%9F-%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3/" class="post-title-link" itemprop="url">Ceres Solvel翻译第一期-说明文档</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-07-14 14:47:31" itemprop="dateCreated datePublished" datetime="2020-07-14T14:47:31+08:00">2020-07-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:59:08" itemprop="dateModified" datetime="2024-04-26T10:59:08+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ceres-Solvel/" itemprop="url" rel="index"><span itemprop="name">Ceres Solvel</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ceres-Solvel/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">最小二乘优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="非线性最小二乘法"><a href="#非线性最小二乘法" class="headerlink" title="非线性最小二乘法"></a>非线性最小二乘法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Ceres可以解决有界约束形式的鲁棒非线性最小二乘问题，形式如下：</p>
<p>$$min_x\frac{1}{2}\sum_i\rho_i(\left |f_i(x_{i_1},\cdots,x_{i_k})  \right |^2)$$</p>
<p>$$s.t. l_i\le x_j\le u_j$$<br>这一表达式在工程和科学领域有非常广泛的应用，比如统计学中的曲线拟合，或者在计算机视觉中依据图像进行三维模型的构建等等。</p>
<p>$\rho_i(\left |f_i(x_{i_1},\cdots,x_{i_k})  \right |^2)$这一部分被称为残差块（<font color=red font face="黑体">ResidualBlock</font>)，其中的$f_i(\cdot )$叫做代价函数（<font color=red font face="黑体">CostFuction</font>)。代价函数依赖于一系列参数$[x_{i_1},\cdots,x_{i_k}]$,这一系列参数（均为标量）称为参数块（<font color=red font face="黑体">ParameterBlock</font>)。当然参数块中也可以只含有一个变量。$l_j$和$u_j$分别是变量块$x_j$的上下边界。  </p>
<p>$\rho_i$是损失函数（<font color=red font face="黑体">LossFuction</font>)。损失函数是一个标量函数，其作用是减少异常值（<font color=red font face="黑体">Outliers</font>)对优化结果的影响。其效果类似于对函数的过滤。</p>
<p>一个特殊情况是，$\rho_i(f<br>(x)) &#x3D; f(x)$,也就是没有对函数进行任何过滤，损失函数的输出等于输入。若同时令$l_j &#x3D; -\infty$并且$u_j &#x3D; \infty$，即参数块的取值没有限制，那么此时问题变成了非线性最小二乘问题。表达式如下：  </p>
<p>$$\frac{1}{2}\sum_i\left | f_i(x_{i_1},\cdots,x_{i_k}) \right |^2$$</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><p>每个程序最简单的示例被称为Hello World。本节将简单描述Ceres的Hello World示例，以便让读者对库的使用步骤快速建立认识。<br>在Hello World这个例子中，待优化的函数是$f(x) &#x3D; 10 - x$，重载操作符如下：</p>
<pre><code>struct CostFunctor &#123;
    template &lt;typename T&gt;
    bool operator()(const T* const x, T* residual) const &#123;
        residual[0] = T(10.0) - x[0];
        return true;
    &#125;
&#125;;
</code></pre>
<p>重点要注意这里的<font face ="黑体" font color = red>operator()</font>是一个模板方法，这里假设所有的输入和输出都是同一类型<font face ="黑体" font color = red>T</font>。在后面的代码中，Ceres通过调用<font face ="黑体" font color = red>CostFunctor::operator&#60;T&#62;()</font>来使用这一重载操作符。在这个例子中可以令<font face ="黑体" font color = red>T &#x3D; double</font>，然后仅仅以double类型输出残差值。也可以令<font face ="黑体" font color = red>T &#x3D; Jet</font>然后输出雅可比矩阵。这一部分在后面会有更详细的介绍。</p>
<blockquote>
<p>雅可比矩阵实际上就是对一个含有多个参数的函数$f(x)$求一系列一阶偏微分</p>
</blockquote>
<p>一旦残差方程建立，我们就可以用Ceres来实现非线性最小二乘法的优化算法。代码如下：  </p>
<pre><code>int main(int argc, char** argv) &#123;
google::InitGoogleLogging(argv[0]);

// The variable to solve for with its initial value.
double initial_x = 5.0;
double x = initial_x;

// Build the problem.
Problem problem;

// Set up the only cost function (also known as residual). This uses
// auto-differentiation to obtain the derivative (jacobian).
CostFunction* cost_function =
    new AutoDiffCostFunction&lt;CostFunctor, 1, 1&gt;(new CostFunctor);
problem.AddResidualBlock(cost_function, nullptr, &amp;x);

// Run the solver!
Solver::Options options;
options.linear_solver_type = ceres::DENSE_QR;
options.minimizer_progress_to_stdout = true;
Solver::Summary summary;
Solve(options, &amp;problem, &amp;summary);

std::cout &lt;&lt; summary.BriefReport() &lt;&lt; &quot;\n&quot;;
std::cout &lt;&lt; &quot;x : &quot; &lt;&lt; initial_x
            &lt;&lt; &quot; -&gt; &quot; &lt;&lt; x &lt;&lt; &quot;\n&quot;;
return 0;
&#125;
</code></pre>
<p><font face ="黑体" font color = red>AutoDiffCostFuction</font>将刚刚建立的<font face ="黑体" font color = red>CostFuctor</font>结构的一个实例作为输入，自动生成其微分并且赋予其一个<font face ="黑体" font color = red>CostFuction</font>类型的接口。<br>编译完成，运行结果如下：（原文中$x$初始值输出错误，修正为上面代码中的$5$）</p>
<pre><code>iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time
0     4.512500e+01    0.00e+00    9.50e+00   0.00e+00   0.00e+00  1.00e+04       0     5.33e-04   3.46e-03
1     4.511598e-07    4.51e+01    9.50e-04   9.50e+00   1.00e+00  3.00e+04       1     5.00e-04   4.05e-03
2     5.012552e-16    4.51e-07    3.17e-08   9.50e-04   1.00e+00  9.00e+04       1     1.60e-05   4.09e-03
Ceres Solver Report: Iterations: 2, Initial cost: 4.512500e+01, Final cost: 5.012552e-16, Termination: CONVERGENCE
x : 5 -&gt; 10
</code></pre>
<p>初始值为$5$，最终通过两次循环之后到达最优解$10$。其实本例是一个线性问题，因为$f(x) &#x3D; 10 - x$是一个线性函数，但是Ceres仍然可以应用。</p>
<h2 id="导数"><a href="#导数" class="headerlink" title="导数"></a>导数</h2><p>像大多数优化软件包一样，Ceres求解器的求解基于其能够在任意参数值下评估目标函数中每个项的值和导数。 正确而高效地做到这一点对于取得优秀的运算结果至关重要。Ceres提供了一系列解决方案，其中一个就是在Hello World中用到的Automatic Differentiation (自动微分算法)。这一部分我们将探讨另外两种可能性，即解析法（Analytic）和数值法（Numeric ）求导。</p>
<h3 id="数值法求导（Numeric-Derivatives"><a href="#数值法求导（Numeric-Derivatives" class="headerlink" title="数值法求导（Numeric Derivatives)"></a>数值法求导（Numeric Derivatives)</h3><p>在某些情况下，像在Hello World中一样定义一个代价函数是不可能的。比如在求解残差值（residual）的时候调用了一个库函数，而这个库函数的内部算法你根本无法干预。在这种情况下数值微分算法就派上用场了。用户定义一个CostFunctor来计算残差值，并且构建一个<font face ="黑体" font color = red>NumericDiffCostFunction</font>数值微分代价函数。比如对于$f(x) &#x3D; 10 - x$对应函数体如下：</p>
<pre><code>struct NumericDiffCostFunctor &#123;
    bool operator()(const double* const x, double* residual) const &#123;
        residual[0] = 10.0 - x[0];
        return true;
    &#125;
&#125;;
</code></pre>
<p>然后继续添加<font face ="黑体" font color = red>Problem</font></p>
<pre><code>CostFunction* cost_function =
    new NumericDiffCostFunction&lt;NumericDiffCostFunctor, ceres::CENTRAL, 1, 1&gt;(
        new NumericDiffCostFunctor);
problem.AddResidualBlock(cost_function, NULL, &amp;x);
</code></pre>
<p>这里我们引用一下Hello World中模板类函数以及自动微分算法（automatic)的代码进行比对：  </p>
<pre><code>//模板类函数
struct CostFunctor &#123;
    template &lt;typename T&gt;
    bool operator()(const T* const x, T* residual) const &#123;
        residual[0] = T(10.0) - x[0];
        return true;
    &#125;
&#125;;
//自动微分算法（automatic）
CostFunction* cost_function =
    new AutoDiffCostFunction&lt;CostFunctor, 1, 1&gt;(new CostFunctor);
problem.AddResidualBlock(cost_function, NULL, &amp;x);
</code></pre>
<p>可以发现两种算法在构建Problem时候基本差不多。但是在用Nummeric算法时需要额外给定一个参数<font face ="黑体" font color = red>ceres::CENTRAL</font>。这个参数告诉计算机如何计算导数。更多具体介绍可以参看NumericDiffCostFunction的Doc文档。</p>
<p>Ceres官方更加推荐自动微分算法，因为C++模板类使自动算法有更高的效率。数值微分算法通常来说计算更复杂，收敛更缓慢。</p>
<h3 id="解析法求导（Analytic-Derivatives）"><a href="#解析法求导（Analytic-Derivatives）" class="headerlink" title="解析法求导（Analytic Derivatives）"></a>解析法求导（Analytic Derivatives）</h3><p>有些时候，应用自动求解算法时不可能的。比如在某些情况下，计算导数的时候，使用闭合解（closed form，也被称为解析解）会比使用自动微分算法中的链式法则（chain rule）更有效率。这里辨析一下解析解和数值解：</p>
<blockquote>
<p>在解组件特性相关的方程式时，大多数的时候都要去解偏微分或积分式，才能求得其正确的解。依照求解方法的不同，可以分成以下两类：解析解和数值解。  </p>
</blockquote>
<blockquote>
<ul>
<li><strong>解析解(analytical solution)：</strong><br>就是一些严格的公式,给出任意的自变量就可以求出其因变量,也就是问题的解。他人可以利用这些公式计算各自的问题。所谓的解析解是一种包含：分式、三角函数、指数、对数甚至无限级数等基本函数的解的形式。用来求得解析解的方法称为解析法〈analytic techniques、analytic methods〉，解析法即是常见的微积分技巧，例如分离变量法等。解析解为一封闭形式〈closed-form〉的函数，因此对任一独立变量，我们皆可将其带入解析函数求得正确的相依变量。因此，解析解也被称为闭式解（closed-form solution）。</li>
<li><strong>数值解(numerical solution)：</strong><br>是采用某种计算方法,如有限元的方法, 数值逼近,插值的方法, 得到的解。别人只能利用数值计算的结果, 而不能随意给出自变量并求出计算值。当无法藉由微积分技巧求得解析解时，这时便只能利用数值分析的方式来求得其数值解了。数值方法变成了求解过程重要的媒介。在数值分析的过程中，首先会将原方程式加以简化，以利后来的数值分析。例如，会先将微分符号（连续）改为差分符号（离散）等。然后再用传统的代数方法将原方程式改写成另一方便求解的形式。这时的求解步骤就是将一独立变量带入，求得相依变量的近似解。因此利用此方法所求得的相依变量为一个个分离的数值〈discrete values〉，不似解析解为一连续的分布，而且因为经过上述简化的动作，所以可以想见正确性将不如解析法来的好。</li>
</ul>
</blockquote>
<p>在这种情况下，你就可以自己编写残差计算代码和雅可比行列式的计算代码了。还是用Hello world中的$f(x) &#x3D; 10 - x$为例：  </p>
<pre><code>class QuadraticCostFunction : public ceres::SizedCostFunction&lt;1, 1&gt; &#123;
 public:
  virtual ~QuadraticCostFunction() &#123;&#125;
  virtual bool Evaluate(double const* const* parameters,
                        double* residuals,
                        double** jacobians) const &#123;
    const double x = parameters[0][0];
    residuals[0] = 10 - x;

    // Compute the Jacobian if asked for.
    if (jacobians != nullptr &amp;&amp; jacobians[0] != nullptr) &#123;
    jacobians[0][0] = -1;
    &#125;
    return true;
  &#125;
&#125;;
</code></pre>
<p><font face ="黑体" font color = red>Evaluate</font>函数的参数包括：参数的输入数组、残差的输出数组以及雅可比矩阵的输出数组。其中雅可比矩阵是可选的，<font face ="黑体" font color = red>Evaluate</font>会在它非空时进行检查，并且如果是非空则用残差的导数值进行填充。这种情况下残差函数是线性的，雅可比行列式是常数。</p>
<p>从上述代码片段可以看出，实现“CostFunction““其实有点乏味。所以除非有什么特殊原因需要自行构建雅可比的计算，否则最好还是直接使用自动微分法或者数值微分法来创建残差块。</p>
<h3 id="其他导数计算方法"><a href="#其他导数计算方法" class="headerlink" title="其他导数计算方法"></a>其他导数计算方法</h3><p>到目前为止，计算导数其实是Ceres最复杂的部分了。根据需要，用户有时候还需要更复杂的导数计算算法。这一节仅仅是大体介绍了如何使用Ceres进行导数计算最浅显的部分。对Numeric和Auto方法都很熟悉之后，还可以深入研究一下<font face ="黑体" font color = red>DynamicAutoDiffCostFunction</font> , <font face ="黑体" font color = red>CostFunctionToFunctor</font>, <font face ="黑体" font color = red>NumericDiffFunctor</font> 和<font face ="黑体" font color = red>ConditionedCostFunction</font>，从而实现更高级的代价函数的计算方法。</p>
<h2 id="鲍威尔方程"><a href="#鲍威尔方程" class="headerlink" title="鲍威尔方程"></a>鲍威尔方程</h2><p>在这一节我们使用一个复杂一些的例子——求解鲍威尔方程的最小值。我们定义参数块$x &#x3D; [x_1,x_2,x_3,x_4]$，以及代价函数如下：<br>$$<br>\begin{aligned}<br>&amp;f_1(x) &#x3D; x_1 + 10x_2  \<br>&amp;f_2(x) &#x3D; \sqrt{5}(x_3 - x_4) \<br>&amp;f_3(x) &#x3D; (x_2 - 2x_3)^2 \<br>&amp;f_4(x) &#x3D; \sqrt{10}(x_1 - x_4)^2 \<br>&amp;F(x) &#x3D; [f_1(x),f_2(x),f_3(x),f_4(x)]<br>\end{aligned}<br>$$</p>
<p>$F(x)$是关于上面四个残差值得方程。我们希望找到一组$x$，使得$\frac{1}{2}\left |F(x)  \right |^2$取得最小值。</p>
<p>同样的，第一步仍然是定义残差方程。对于每一行方程都可以定义一个对应的结构体，如对于$f_4(x_1,x_4)$：</p>
<pre><code>struct F4 &#123;
    template &lt;typename T&gt;
    bool operator()(const T* const x1, const T* const x4, T* residual) const &#123;
        residual[0] = T(sqrt(10.0)) * (x1[0] - x4[0]) * (x1[0] - x4[0]);
        return true;
    &#125;
&#125;;
</code></pre>
<p>类似的我们也可以实现$f_1$,$f_2$和$f_3$得代码。之后就可以通过下列代码，把各个残差块加入到<font face ="黑体" font color = red>Problem</font>中。</p>
<pre><code>double x1 =  3.0; double x2 = -1.0; double x3 =  0.0; double x4 = 1.0;

Problem problem;

// Add residual terms to the problem using the using the autodiff
// wrapper to get the derivatives automatically.
problem.AddResidualBlock(
    new AutoDiffCostFunction&lt;F1, 1, 1, 1&gt;(new F1), nullptr, &amp;x1, &amp;x2);
problem.AddResidualBlock(
    new AutoDiffCostFunction&lt;F2, 1, 1, 1&gt;(new F2), nullptr, &amp;x3, &amp;x4);
problem.AddResidualBlock(
    new AutoDiffCostFunction&lt;F3, 1, 1, 1&gt;(new F3), nullptr, &amp;x2, &amp;x3)
problem.AddResidualBlock(
    new AutoDiffCostFunction&lt;F4, 1, 1, 1&gt;(new F4), nullptr, &amp;x1, &amp;x4);
</code></pre>
<p>注意每个残差块只依赖与两个参数，而不是全部四个参数。运行结果如下：</p>
<pre><code>Initial x1 = 3, x2 = -1, x3 = 0, x4 = 1
iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time
  0  1.075000e+02    0.00e+00    1.55e+02   0.00e+00   0.00e+00  1.00e+04       0    4.95e-04    2.30e-03
  1  5.036190e+00    1.02e+02    2.00e+01   2.16e+00   9.53e-01  3.00e+04       1    4.39e-05    2.40e-03
  2  3.148168e-01    4.72e+00    2.50e+00   6.23e-01   9.37e-01  9.00e+04       1    9.06e-06    2.43e-03
  3  1.967760e-02    2.95e-01    3.13e-01   3.08e-01   9.37e-01  2.70e+05       1    8.11e-06    2.45e-03
  4  1.229900e-03    1.84e-02    3.91e-02   1.54e-01   9.37e-01  8.10e+05       1    6.91e-06    2.48e-03
  5  7.687123e-05    1.15e-03    4.89e-03   7.69e-02   9.37e-01  2.43e+06       1    7.87e-06    2.50e-03
  6  4.804625e-06    7.21e-05    6.11e-04   3.85e-02   9.37e-01  7.29e+06       1    5.96e-06    2.52e-03
  7  3.003028e-07    4.50e-06    7.64e-05   1.92e-02   9.37e-01  2.19e+07       1    5.96e-06    2.55e-03
  8  1.877006e-08    2.82e-07    9.54e-06   9.62e-03   9.37e-01  6.56e+07       1    5.96e-06    2.57e-03
  9  1.173223e-09    1.76e-08    1.19e-06   4.81e-03   9.37e-01  1.97e+08       1    7.87e-06    2.60e-03
 10  7.333425e-11    1.10e-09    1.49e-07   2.40e-03   9.37e-01  5.90e+08       1    6.20e-06    2.63e-03
 11  4.584044e-12    6.88e-11    1.86e-08   1.20e-03   9.37e-01  1.77e+09       1    6.91e-06    2.65e-03
 12  2.865573e-13    4.30e-12    2.33e-09   6.02e-04   9.37e-01  5.31e+09       1    5.96e-06    2.67e-03
 13  1.791438e-14    2.69e-13    2.91e-10   3.01e-04   9.37e-01  1.59e+10       1    7.15e-06    2.69e-03

Ceres Solver v1.12.0 Solve Report
----------------------------------
                                        Original                  Reduced
Parameter blocks                            4                        4
Parameters                                  4                        4
Residual blocks                             4                        4
Residual                                    4                        4

Minimizer                        TRUST_REGION

Dense linear algebra library            EIGEN
Trust region strategy     LEVENBERG_MARQUARDT

                                        Given                     Used
Linear solver                        DENSE_QR                 DENSE_QR
Threads                                     1                        1
Linear solver threads                       1                        1

Cost:
Initial                          1.075000e+02
Final                            1.791438e-14
Change                           1.075000e+02

Minimizer iterations                       14
Successful steps                           14
Unsuccessful steps                          0

Time (in seconds):
Preprocessor                            0.002

Residual evaluation                     0.000
Jacobian evaluation                     0.000
Linear solver                           0.000
Minimizer                               0.001

Postprocessor                           0.000
Total                                   0.005

Termination:                      CONVERGENCE (Gradient tolerance reached. Gradient max norm: 3.642190e-11 &lt;= 1.000000e-10)

Final x1 = 0.000292189, x2 = -2.92189e-05, x3 = 4.79511e-05, x4 = 4.79511e-05
</code></pre>
<h2 id="曲线拟合（Curve-Fitting"><a href="#曲线拟合（Curve-Fitting" class="headerlink" title="曲线拟合（Curve Fitting)"></a>曲线拟合（Curve Fitting)</h2><p>最小二乘法和非线性最小二乘分析得本来目的就是对一组数据进行曲线拟合。本节将介绍曲线拟合得问题。本节所用的采样点根据$y &#x3D; e^{0.3x + 0.1}$生成，并且加入标准差为$\sigma &#x3D; 0.2$高斯噪声。这$2n$个数据，存入<font face ="黑体" font color = red>data[]</font>中。下面我们用下列带未知参数的方程来拟合这些采样点：<br>$$y &#x3D; e^{mx+c}$$<br>同样的，我们定义一个用来计算残差的结构体。注意，对应每个采样点（观测点）都要计算一个残差。</p>
<pre><code>struct ExponentialResidual &#123;
    ExponentialResidual(double x, double y)
        : x_(x), y_(y) &#123;&#125;

template &lt;typename T&gt;
bool operator()(const T* const m, const T* const c, T* residual) const &#123;
    residual[0] = y_ - exp(m[0] * x_ + c[0]);
    return true;
&#125;

private:
// Observations for a sample.
const double x_;
const double y_;
&#125;;
</code></pre>
<p>下面构造<font face ="黑体" font color = red>Problem</font></p>
<pre><code>double m = 0.0;
double c = 0.0;

Problem problem;
for (int i = 0; i &lt; kNumObservations; ++i) &#123;
    CostFunction* cost_function =
        new AutoDiffCostFunction&lt;ExponentialResidual, 1, 1, 1&gt;(
            new ExponentialResidual(data[2 * i], data[2 * i + 1]));
    problem.AddResidualBlock(cost_function, nullptr, &amp;m, &amp;c);
&#125;
</code></pre>
<p>这里我们再次和Hello World进行对比：</p>
<pre><code>struct CostFunctor &#123;
    template &lt;typename T&gt;
    bool operator()(const T* const x, T* residual) const &#123;
        residual[0] = T(10.0) - x[0];
        return true;
    &#125;
&#125;;

CostFunction* cost_function =
    new AutoDiffCostFunction&lt;CostFunctor, 1, 1&gt;(new CostFunctor);
problem.AddResidualBlock(cost_function, NULL, &amp;x);
</code></pre>
<p>通过对比，可以发现。在Hello World中，CostFunctor中是没有（显式）构造函数的，也就同样没有了初始值。所以在构造对象时，可以直接<font face = "黑体" font color = red>New CostFuntor</font>。而在本节的曲线拟合例子中，构造对象时还要加上初始值<font face = "黑体" font color = red>new ExponentialResidual(data[2 * i], data[2 * i + 1]))</font>。在方括号中的参数分别对应残差函数名<font face = "黑体" font color = red>&#60;ExponentialResidual&#62;</font>，以及输出值（residual）的维度<font face = "黑体" font color = red>1</font>，还有残差函数各个输入值（m,c）维度<font face = "黑体" font color = red>&#60;1，1&#62;</font>。所以在本例中一共有三个1，而在Hello World中，只有两个1，即residual和x的维度。注意先是残差，后是输入参数，而且一一对应。</p>
<p>最后一点就是在把残差块加入problem的过程中，要把输入变量一一带入。比如&amp;m，&amp;c，&amp;x等。以上就是在构建Problem的时候需要顾及到的三个方面。再就是在使用Numeric算法时，还要在方括号中指定计算机如何计算导数，如<font face = "黑体" font color = red>ceres::CENTRAL</font>。</p>
<p>运行程序，得到下列结果：  </p>
<pre><code>iter      cost      cost_change  |gradient|   |step|    tr_ratio  tr_radius  ls_iter  iter_time  total_time
 0  1.211734e+02    0.00e+00    3.61e+02   0.00e+00   0.00e+00    1.00e+04       0    5.34e-04    2.56e-03
 1  1.211734e+02   -2.21e+03    0.00e+00   7.52e-01  -1.87e+01    5.00e+03       1    4.29e-05    3.25e-03
 2  1.211734e+02   -2.21e+03    0.00e+00   7.51e-01  -1.86e+01    1.25e+03       1    1.10e-05    3.28e-03
 3  1.211734e+02   -2.19e+03    0.00e+00   7.48e-01  -1.85e+01    1.56e+02       1    1.41e-05    3.31e-03
 4  1.211734e+02   -2.02e+03    0.00e+00   7.22e-01  -1.70e+01    9.77e+00       1    1.00e-05    3.34e-03
 5  1.211734e+02   -7.34e+02    0.00e+00   5.78e-01  -6.32e+00    3.05e-01       1    1.00e-05    3.36e-03
 6  3.306595e+01    8.81e+01    4.10e+02   3.18e-01   1.37e+00    9.16e-01       1    2.79e-05    3.41e-03
 7  6.426770e+00    2.66e+01    1.81e+02   1.29e-01   1.10e+00    2.75e+00       1    2.10e-05    3.45e-03
 8  3.344546e+00    3.08e+00    5.51e+01   3.05e-02   1.03e+00    8.24e+00       1    2.10e-05    3.48e-03
 9  1.987485e+00    1.36e+00    2.33e+01   8.87e-02   9.94e-01    2.47e+01       1    2.10e-05    3.52e-03
10  1.211585e+00    7.76e-01    8.22e+00   1.05e-01   9.89e-01    7.42e+01       1    2.10e-05    3.56e-03
11  1.063265e+00    1.48e-01    1.44e+00   6.06e-02   9.97e-01    2.22e+02       1    2.60e-05    3.61e-03
12  1.056795e+00    6.47e-03    1.18e-01   1.47e-02   1.00e+00    6.67e+02       1    2.10e-05    3.64e-03
13  1.056751e+00    4.39e-05    3.79e-03   1.28e-03   1.00e+00    2.00e+03       1    2.10e-05    3.68e-03
Ceres Solver Report: Iterations: 13, Initial cost: 1.211734e+02, Final cost: 1.056751e+00, Termination: CONVERGENCE
Initial m: 0 c: 0
Final   m: 0.291861 c: 0.131439
</code></pre>
<p>最终经过计算，结果是m&#x3D;0.291861,c&#x3D;0.131439。这个值和一开始的设定值（m&#x3D;0.3,c&#x3D;0.1）略有偏差。因为额外加入了高斯噪声，所以这个偏差的存在是合理的。拟合结果如下图所示，红圈即为拟合出的曲线。</p>
<p><img src="/pic/1.png" alt="曲线拟合效果"></p>
<h2 id="鲁棒的曲线拟合（Robust-Curve-Fitting）"><a href="#鲁棒的曲线拟合（Robust-Curve-Fitting）" class="headerlink" title="鲁棒的曲线拟合（Robust Curve Fitting）"></a>鲁棒的曲线拟合（Robust Curve Fitting）</h2><p>如果我们在数据集合中加入几个非常夸张的外围点Outliers，那么拟合结果会受到这几个点的明显影响。在这个时候需要应用损失函数（Loss function）来对异常数据进行过滤。比如在上文的例子中，我们对代码进行以下修改：</p>
<pre><code>problem.AddResidualBlock(cost_function, NULL , &amp;m, &amp;c);
</code></pre>
<p>改为：  </p>
<pre><code>problem.AddResidualBlock(cost_function, new CauchyLoss(0.5) , &amp;m, &amp;c);
</code></pre>
<p>CauchyLoss是Ceres Solver附带的损失函数之一。 参数0.5指定了损失函数的规模。通过对下面两个图的对比，我们可以明显的发现损失函数的作用。</p>
<p><img src="/pic/non_robust_least_squares_fit.png" alt="非鲁棒性的拟合效果"></p>
<p><img src="/pic/robust_least_squares_fit.png" alt="鲁棒性的拟合效果"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/06/14/Ceres%20Solvel%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/06/14/Ceres%20Solvel%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%A3%E8%AF%BB/" class="post-title-link" itemprop="url">Ceres Solvel库函数的解读</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-06-14 14:47:31" itemprop="dateCreated datePublished" datetime="2020-06-14T14:47:31+08:00">2020-06-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:59:24" itemprop="dateModified" datetime="2024-04-26T10:59:24+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ceres-Solvel/" itemprop="url" rel="index"><span itemprop="name">Ceres Solvel</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Ceres-Solvel/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E4%BC%98%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">最小二乘优化</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="关于微分计算（On-Derivatives"><a href="#关于微分计算（On-Derivatives" class="headerlink" title="关于微分计算（On Derivatives)"></a>关于微分计算（On Derivatives)</h1><p>与所有基于梯度的优化算法一样，Ceres Solver也是基于评估域中任意点的目标函数及其导数。事实上，Ceres的核心就是确定目标函数机器雅可比行列式。雅可比行列式求解的正确性和效率是评判算法优劣的关键指标。用户可以灵活的从一下三种微分算法中选择：</p>
<blockquote>
<ul>
<li>解析微分算法（<font face="黑体">Analytic Derivatives</font>）：用户自己手动或者借助Maple或者Mathematica等工具求解导数，然后写到<font color=red font face="黑体">CostFunction</font>里面。</li>
<li>数值微分算法（Numeric Derivatives）：Ceres用有限差分数值计算导数</li>
<li>自动微分算法（Automatic Dericatives）：Ceres用C++模板和操作符重载自动分析计算微分。</li>
</ul>
</blockquote>
<p>应该使用这三种方法中的哪一种（单独或组合）取决于用户愿意做出的情况和权衡。官方给出了一个简单粗暴的建议：<br>优先选用自动微分算法，某些情况可能需要用到解析微分算法，尽量避免数值微分算法。</p>
<h2 id="Spivak标记"><a href="#Spivak标记" class="headerlink" title="Spivak标记"></a>Spivak标记</h2><p>为了简化阅读和推理，引入Spivak标记。</p>
<p>对于单自变量函数$f$,$f(a)$表示它在$a$处的函数值。$Df$表示它的一阶导数，那么$Df(a)$就是函数在$a$处的一阶导数。即，</p>
<p>$$Df(a) &#x3D; \frac{d}{dx}f(x)|_{x&#x3D;a}$$</p>
<p>$D^kf$表示$f$的第$k$阶导数。</p>
<p>对于双自变量函数$g(x,y)$，$D_1g$和$D_2g$分别表示关于$g$的两个偏微分。即，</p>
<p>$$D_1g &#x3D; \frac{\partial}{\partial x}g(x,y)andD_2g &#x3D; \frac{\partial}{\partial y}g(x,y)$$</p>
<p>$D_g$表示$g$的雅可比矩阵</p>
<blockquote>
<p>雅可比矩阵即</p>
</blockquote>
<p>$$<br>\begin{bmatrix}<br>  \frac{\partial y_1}{\partial x_1}&amp; \cdots &amp; \frac{\partial y_1}{\partial x_n}\<br> \vdots &amp; \ddots &amp; \vdots\<br>  \frac{\partial y_m}{\partial x_1}&amp; \cdots &amp; \frac{\partial y_m}{\partial x_n}<br>\end{bmatrix}<br>$$</p>
<p>这里的$y_1$即$g$，其他的行不存在，因为只存在一个因变量$g$。即雅可比矩阵是一个一行两列的矩阵。即，</p>
<p>$$Dg &#x3D; \begin{bmatrix}<br>  D_1g&amp; D_2g<br>\end{bmatrix}$$</p>
<p>更一般的，如果$g:\mathbb{R}^{n} \longrightarrow \mathbb{R}^{m}$，那么$Dg$表示的就是一个$m \times n$的雅可比矩阵。</p>
<h2 id="自动微分法（Automatic-Derivatices）"><a href="#自动微分法（Automatic-Derivatices）" class="headerlink" title="自动微分法（Automatic Derivatices）"></a>自动微分法（Automatic Derivatices）</h2><p>我们来思考一个相对复杂的曲线拟合问题。待确定参数方程如下：</p>
<p>$$ y &#x3D; \frac{b_1}{(1+e^{b_2 - b_3x})^{1&#x2F;b_4}}$$</p>
<p>现在给定一系列的对应数据点$\left{x_i,y_i\right },\forall i&#x3D;1,\cdots,n$。我们面临的问题就是求解$b_1,b_2,b_3,b_4$使下列表达式的取值最小：</p>
<p>$$ \begin{aligned}<br>E\left(b_{1}, b_{2}, b_{3}, b_{4}\right) &amp;&#x3D;\sum_{i} f^{2}\left(b_{1}, b_{2}, b_{3}, b_{4} ; x_{i}, y_{i}\right) \<br>&amp;&#x3D;\sum_{i}\left(\frac{b_{1}}{\left(1+e^{b_{2}-b_3x_i}\right)^{1 &#x2F; b_{4}}}-y_{i}\right)^{2}<br>\end{aligned}$$</p>
<p>下面我们使用自动微分算法，它是一种可以快速计算精确导数的算法。下面的代码片段实现了上述问题的<font color=red font face="黑体">CostFunction</font>。</p>
<pre><code>struct Rat43CostFunctor &#123;
    Rat43CostFunctor(const double x, const double y) : x_(x), y_(y) &#123;&#125;

template &lt;typename T&gt;  
bool operator()(const T* parameters, T* residuals) const &#123;
    const T b1 = parameters[0];
    const T b2 = parameters[1];
    const T b3 = parameters[2];
    const T b4 = parameters[3];
    residuals[0] = b1 * pow(1.0 + exp(b2 -  b3 * x_), -1.0 / b4) - y_;
    return true;
&#125;

private:
    const double x_;
    const double y_;
&#125;;

CostFunction* cost_function =
    new AutoDiffCostFunction&lt;Rat43CostFunctor, 1, 4&gt;(    
        new Rat43CostFunctor(x, y));
</code></pre>
<p>接下来我们对自动微分算法的原理进行研究。为了研究其工作原理，必须要学习 <strong>二元数（Dual number)</strong> 和 **射流(Jet)**。</p>
<h3 id="二元数和射流"><a href="#二元数和射流" class="headerlink" title="二元数和射流"></a>二元数和射流</h3><p><strong>二元数(Dual number)</strong> 是实数的一个延伸，类似于复数。复数则通过引入虚数来增加实数，比如$i$，二元数引入了一个极小二元数单位，比如$\epsilon$，且$\epsilon^2 &#x3D; 0$（平方后太小可以忽略）。一个二元数$a+\upsilon\epsilon$包含两个分量，实分量$a$和极小分量$\upsilon$。令人惊喜的是，这个简单的变化带来了一种方便的计算精确导数的方法，而不需要考虑复杂的符号表达式。</p>
<p>例如，考虑函数</p>
<p>$$ f(x) &#x3D; x^2$$</p>
<p>然后<br>$$ \begin{aligned}<br>f(10+\epsilon) &amp;&#x3D;(10+\epsilon)^{2} \<br>&amp;&#x3D;100+20 \epsilon+\epsilon^{2} \<br>&amp;&#x3D;100+20 \epsilon<br>\end{aligned}$$</p>
<p>观察$\epsilon$的系数，我们发现$Df(10) &#x3D; 20$。事实上，这个规律可以推广到不是多项式的函数。考虑一个任意可微函数$f(x)$，然后我们计算$f(x+ \epsilon)$，通过在$x$附近做泰勒展开，这就得到了无穷级数</p>
<p>$$<br>\begin{array}{l}<br>f(x+\epsilon)&#x3D;f(x)+D f(x) \epsilon+D^{2} f(x) \frac{\epsilon^{2}}{2}+D^{3} f(x) \frac{\epsilon^{3}}{6}+\cdots \<br>f(x+\epsilon)&#x3D;f(x)+D f(x) \epsilon<br>\end{array}<br>$$</p>
<p>记住，$\epsilon^2 &#x3D; 0$。</p>
<p><strong>射流(Jet)</strong> 是一个$n$维二元数。我们定义$n$个极小单位$\epsilon_i,i&#x3D;1,\cdots,n$。并且存在性质$\forall i,j:\epsilon_i\epsilon_j&#x3D;0$。射流数由实数$a$和$n$维极小分量组成。</p>
<p>$$x &#x3D; a + \sum_j \upsilon_j \epsilon_j$$</p>
<p>为了简化我们改写为这种形式</p>
<p>$$x &#x3D; a + \mathbf{v}$$</p>
<p>然后使用泰勒级数展开，我们可以看到：</p>
<p>$$f(a+\mathbf{v}) &#x3D; f(a) +Df(a)\mathbf{v} $$</p>
<p>对多变量函数$f : \mathbb{R^n} \longrightarrow \mathbb{R^m} $相似。对于自变量$x_i &#x3D; a_i + \mathbf{v}_i, \forall i &#x3D; 1,\cdots,n :$</p>
<p>$$f(x_1,\cdots,x_n) &#x3D; f(a_1,\cdots,a_n) + \sum_i D_if(a_1,\cdots,a_n)\mathbf{v}_i $$</p>
<p>如果每个选取的极小量$\mathbf{v}_i &#x3D; e_i $是$i^{th}$标准基向量，那么上面的表达式就可以简化为</p>
<p>$$<br>f(x_1,\cdots,x_n) &#x3D; f(a_1,\cdots,a_n) + \sum_i D_if(a_1,\cdots,a_n) \epsilon_i<br>$$</p>
<p>我们可以查找$\epsilon_i$的系数来提取雅可比矩阵的坐标。</p>
<h3 id="实现射流（Jet"><a href="#实现射流（Jet" class="headerlink" title="实现射流（Jet)"></a>实现射流（Jet)</h3><p>为了让上面学到的内容在实践中发挥作用，我们需要能够计算函数$f$的值，不仅在自变量是实数的时候，也需要在自变量是二元数的情况下适用。但是通常我们并非通过泰勒展开式来求函数值。这也就是为什么我们需要用到C++模板和操作符重载。下面的代码段实现了<font color = red font face = "黑体">Jet</font>类以及对该类的一些操作和函数。</p>
<pre><code>template&lt;int N&gt; struct Jet &#123;
    double a;
    Eigen::Matrix&lt;double, 1, N&gt; v;
&#125;;

template&lt;int N&gt; Jet&lt;N&gt; operator+(const Jet&lt;N&gt;&amp; f, const Jet&lt;N&gt;&amp; g) &#123;
    return Jet&lt;N&gt;(f.a + g.a, f.v + g.v);
&#125;

template&lt;int N&gt; Jet&lt;N&gt; operator-(const Jet&lt;N&gt;&amp; f, const Jet&lt;N&gt;&amp; g) &#123;
    return Jet&lt;N&gt;(f.a - g.a, f.v - g.v);
&#125;

template&lt;int N&gt; Jet&lt;N&gt; operator*(const Jet&lt;N&gt;&amp; f, const Jet&lt;N&gt;&amp; g) &#123;
    return Jet&lt;N&gt;(f.a * g.a, f.a * g.v + f.v * g.a);
&#125;

template&lt;int N&gt; Jet&lt;N&gt; operator/(const Jet&lt;N&gt;&amp; f, const Jet&lt;N&gt;&amp; g) &#123;
    return Jet&lt;N&gt;(f.a / g.a, f.v / g.a - f.a * g.v / (g.a * g.a));
&#125;

template &lt;int N&gt; Jet&lt;N&gt; exp(const Jet&lt;N&gt;&amp; f) &#123;
    return Jet&lt;T, N&gt;(exp(f.a), exp(f.a) * f.v);
&#125;

// This is a simple implementation for illustration purposes, the
// actual implementation of pow requires careful handling of a number
// of corner cases.
template &lt;int N&gt;  Jet&lt;N&gt; pow(const Jet&lt;N&gt;&amp; f, const Jet&lt;N&gt;&amp; g) &#123;
    return Jet&lt;N&gt;(pow(f.a, g.a),
            g.a * pow(f.a, g.a - 1.0) * f.v +
            pow(f.a, g.a) * log(f.a); * g.v);
&#125;
</code></pre>
<p>有了这些重载的函数，我们现在可以用一个<font color = red font face = "黑体">Jets</font>数组来调用<font color = red font face = "黑体">Rat43CostFunctor</font>，而不是<font color = red font face = "黑体">double</font>双精度类型。将其与初始化的<font color = red font face = "黑体">Jets</font>结合起来，我们就可以计算雅可比矩阵了：</p>
<pre><code>class Rat43Automatic : public ceres::SizedCostFunction&lt;1,4&gt; &#123;
    public:
      Rat43Automatic(const Rat43CostFunctor* functor) : functor_(functor) &#123;&#125;
      virtual ~Rat43Automatic() &#123;&#125;
      virtual bool Evaluate(double const* const* parameters,
                    double* residuals,
                    double** jacobians) const &#123;
    // Just evaluate the residuals if Jacobians are not required.
    if (!jacobians) return (*functor_)(parameters[0], residuals);

    // 初始化Jets，四个待求参数
    ceres::Jet&lt;4&gt; jets[4];
    for (int i = 0; i &lt; 4; ++i) &#123;
        jets[i].a = parameters[0][i];
        jets[i].v.setZero();
        jets[i].v[i] = 1.0;
    &#125;

    ceres::Jet&lt;4&gt; result;
    (*functor_)(jets, &amp;result);

    // 把Jet的值（前面提到的，极小单位分量的系数）复制出啦.
    residuals[0] = result.a;
    for (int i = 0; i &lt; 4; ++i) &#123;
        jacobians[0][i] = result.v[i];
    &#125;
    return true;
&#125;

private:
    std::unique_ptr&lt;const Rat43CostFunctor&gt; functor_;
&#125;;
</code></pre>
<p>这就是<font face = "黑体" font color = red>AutoDiffCostFunction</font>的核心工作原理。</p>
<h3 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h3><p>自动微分使用户不必计算和推理Jacobians的符号表达式，但是这个捷径是有代价的。例如，考虑以下简单的函数：</p>
<pre><code>struct Functor &#123;
    template &lt;typename T&gt; bool operator()(const T* x, T* residual) const &#123;
        residual[0] = 1.0 - sqrt(x[0] * x[0] + x[1] * x[1]);
        return true;
    &#125;
&#125;;
</code></pre>
<p>查看计算残差的代码，没有人预见到任何问题。但是，如果我们看一下雅可比矩阵的解析表达式：</p>
<p>$$<br>\begin{aligned}<br>y &amp;&#x3D;1-\sqrt{x_{0}^{2}+x_{1}^{2}} \<br>D_{1} y &amp;&#x3D;-\frac{x_{0}}{\sqrt{x_{0}^{2}+x_{1}^{2}}}, D_{2} y&#x3D;-\frac{x_{1}}{\sqrt{x_{0}^{2}+x_{1}^{2}}}<br>\end{aligned}<br>$$</p>
<p>我们发现它在$x_0 &#x3D; 0,x_1 &#x3D; 0$处是不确定的。</p>
<p>这个问题没有完美的解决方案。在某些情况下，我们需要明确地指出可能出现的不确定的点，并使用使用<font face = "黑体" font color = blue>L’Hopital rule</font>（这里要去Ceres Solvel官网的rotation.h文件中的转换例程），在其他情况下，可能需要对表达式进行正则化，以消除这些点。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/01/02/new-future/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/01/02/new-future/" class="post-title-link" itemprop="url">new future</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-02 14:18:06" itemprop="dateCreated datePublished" datetime="2020-01-02T14:18:06+08:00">2020-01-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:54:44" itemprop="dateModified" datetime="2024-04-26T10:54:44+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%9C%AD%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">札记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>While we were so young</p>
<p>我梦到当时 我们翻过墙</p>
<p>曼陀罗花 沿途绽放</p>
<p>我们光脚越过人间荒唐</p>
<p>We’re stupid but strong</p>
<p>放学的屋顶 像万人广场</p>
<p>从不多想 只是信仰</p>
<p>少年回头望 笑我还不快跟上</p>
<p>那路的起点谁能忘</p>
<p>那路的尽头谁在唱</p>
<p>谁成名在望 谁曾失望</p>
<p>却更多 的谁在盼望</p>
<p>那黑的终点可有光</p>
<p>那夜的尽头天将亮</p>
<p>那成名在望 无关真相</p>
<p>如果你 心始终信仰 谁又能怎样</p>
<p>谁又能怎样 你就能飞翔</p>
<p>你就能飞翔 你就能飞翔</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/16/Windows-10-%E5%AE%89%E8%A3%85PyTorch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/09/16/Windows-10-%E5%AE%89%E8%A3%85PyTorch/" class="post-title-link" itemprop="url">Windows 10 安装PyTorch</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-16 20:33:06" itemprop="dateCreated datePublished" datetime="2019-09-16T20:33:06+08:00">2019-09-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:56:20" itemprop="dateModified" datetime="2024-04-26T10:56:20+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/PyTorch/" itemprop="url" rel="index"><span itemprop="name">PyTorch</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><p>今天比较有时间，正好看完了CVPR-2018年的论文&lt;**Single Image Reﬂection Separation with Perceptual Losses**&gt;，这里不多介绍这篇论文相关的东西了。因为跑这个数据的话，自己的电脑当时在Windows下装的Tensorflow，但是作者给的运行策略是Ubuntu下，所以问了一下学长，他说可以在Windows下安装PyTorch来跑。下面就记录一下自己安装PyTorch的过程。</p>
<p>1.由于之前安装了Anaconda3，所以可以采用conda安装的方式，但是之前安装Tensorflow的时候Python版本的问题就一直有点疑问，所以查了一下发现如果只是想利用Pycharm运行PyTorch的话，其实直接用pip方式安装就可以</p>
<p>2.那么需要到PyTorch官网去查看自己所需的代码 <a target="_blank" rel="noopener" href="https://pytorch.org/">PyTorch官网连接</a>，相应的选择自己电脑的配置，注意如果用pip安装的话，要选择Pip选项。然后下面就会给出你所需的命令。还要注意的一点是我的电脑由于是A卡的，所以在CUDA这个部分我选择的是None，也就是所说的CPU版本的PyTorch。本人的命令如下：</p>
<pre><code>pip3 install torch==1.2.0+cpu torchvision==0.4.0+cpu -f https://download.pytorch.org/whl/torch_stable.html
</code></pre>
<p>3.安装成功后，一定要记得看一下自己所安装的<em><strong>文件夹地址</strong></em></p>
<p>4.打开Pycharm，按ctrl+alt+s，打开Project Interpreter进行配置，点击右上角的设置符号，选择Add，在下面点选Existing environment，然后在右边的…处找到自己刚才安装的<em><strong>文件夹地址</strong></em>，拉到最下面找到python.exe文件一路点击<strong>ok</strong>。</p>
<p>5.在pycharm中新建项目，输入以下代码：</p>
<pre><code>from __future__ import print_function
import torch
x=torch.rand(5,3)
print(x)
</code></pre>
<p>查看输出，如果输出为：</p>
<pre><code>tensor([[0.9072, 0.3848, 0.9203],
        [0.1643, 0.7447, 0.1730],
        [0.4379, 0.2974, 0.1283],
        [0.4563, 0.5322, 0.9924],
        [0.4715, 0.9287, 0.7176]])

Process finished with exit code 0
</code></pre>
<p>证明PyTorch安装成功！</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%206/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%206/" class="post-title-link" itemprop="url">软件构造知识点总结 - 6</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-20T00:00:00+08:00">2019-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:47:18" itemprop="dateModified" datetime="2024-04-26T10:47:18+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/" itemprop="url" rel="index"><span itemprop="name">软件构造</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><hr>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p><strong>并发（concurrency）</strong></p>
<ul>
<li>定义：指的是多线程场景下对共享资源的争夺运行</li>
<li>并发的应用背景：<ul>
<li>网络上的多台计算机</li>
<li>一台计算机上的多个应用</li>
<li>一个CPU上的多核处理器</li>
</ul>
</li>
<li>为什么要有并发：<ul>
<li>摩尔定律失效、“核”变得越来越多</li>
<li>为了充分利用多核和多处理器需要将程序转化为并行执行</li>
</ul>
</li>
<li>并发编程的两种模式：<ul>
<li>共享内存：在内存中读写共享数据</li>
<li>信息传递（Message Passing）：通过channel交换消息</li>
</ul>
</li>
</ul>
<p><strong>共享内存</strong></p>
<ul>
<li>共享内存这种方式比较常见，我们经常会设置一个共享变量，然后多个线程去操作同一个共享变量。从而达到线程通讯的目的。</li>
<li>例子：<ul>
<li>两个处理器，共享内存</li>
<li>同一台机器上的两个程序，共享文件系统</li>
<li>同一个Java程序内的两个线程，共享Java对象</li>
</ul>
</li>
</ul>
<p><strong>信息传递</strong></p>
<ul>
<li>消息传递方式采取的是线程之间的直接通信，不同的线程之间通过显式的发送消息来达到交互目的</li>
<li>接收方将收到的消息形成队列逐一处理，消息发送者继续发送（异步方式）</li>
<li>消息传递机制也无法解决竞争条件问题</li>
<li>仍然存在消息传递时间上的交错</li>
<li>例子：<ul>
<li>网络上的两台计算机，通过网络连接通讯</li>
<li>浏览器和Web服务器，A请求页面，B发送页面数据给A</li>
<li>即时通讯软件的客户端和服务器</li>
<li>同一台计算机上的两个程序，通过管道连接进行通讯</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">并发模型</th>
<th align="center">通信机制</th>
<th align="center">同步机制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">共享内存</td>
<td align="center">线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。</td>
<td align="center">同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</td>
</tr>
<tr>
<td align="center">消息传递</td>
<td align="center">线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</td>
<td align="center">由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</td>
</tr>
</tbody></table>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><em>进程和线程</em></h3><ul>
<li>进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。<ul>
<li>程序运行时在内存中分配自己独立的运行空间</li>
<li>进程拥有整台计算机的资源</li>
<li>多进程之间不共享内存</li>
<li>进程之间通过消息传递进行协作</li>
<li>一般来说，进程<code>==</code>程序<code>==</code>应用（但一个应用中可能包含多个进程）</li>
<li>OS支持的IPC机制(pipe&#x2F;socket)支持进程间通信（IPC不仅是本机的多个进程之间， 也可以是不同机器的多个进程之间）</li>
<li>JVM通常运行单一进程，但也可以创建新的进程。</li>
</ul>
</li>
<li>线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。<ul>
<li>线程有自己的堆栈和局部变量，但是多个线程共享内存空间</li>
<li>进程&#x3D;虚拟机；线程&#x3D;虚拟CPU</li>
<li>程序共享、资源共享，都隶属于进程</li>
<li>很难获得线程私有的内存空间</li>
<li>线程需要同步：在改变对象时要保持lock状态</li>
<li>清理线程是不安全的</li>
</ul>
</li>
<li>进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。</li>
<li>一个进程中至少应该有一个线程。</li>
<li>主线程可以创建其他的线程。</li>
</ul>
<h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a><em>线程的创建和启动</em></h3><p><strong>方式1：继承<code>Thread</code>类</strong></p>
<ul>
<li>方法：用<code>Thread</code>类实现了<code>Runnable</code>接口，但它其中的<code>run</code>方法什么都没做，所以用一个类做<code>Thread</code>的子类，提供它自己实现的<code>run</code>方法。用<code>Thread.start()</code>来开始一个新的线程。</li>
<li>创建：<code>A a = new A()</code>;</li>
<li>启动：<code>a.start()</code>;</li>
<li>步骤:<ul>
<li>定义一个类A继承于<code>java.lang.Thread</code>类.</li>
<li>在<code>A</code>类中覆盖<code>Thread</code>类中的<code>run</code>方法.</li>
<li>我们在<code>run</code>方法中编写需要执行的操作：<code>run</code>方法里的代码,线程执行体.</li>
<li>在<code>main</code>方法(线程)中,创建线程对象,并启动线程.</li>
</ul>
</li>
<li><em><strong>examples</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1):定义一个类A继承于java.lang.Thread类.  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;  </span><br><span class="line">     <span class="comment">//2):在A类中覆盖Thread类中的run方法.  </span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">          <span class="comment">//3):在run方法中编写需要执行的操作  </span></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i ++)&#123;  </span><br><span class="line">              System.out.println(<span class="string">&quot;播放音乐&quot;</span>+i);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsThreadDemo</span> &#123;  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;             </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">50</span>; j ++)&#123;  </span><br><span class="line">             System.out.println(<span class="string">&quot;运行游戏&quot;</span>+j);  </span><br><span class="line">             <span class="keyword">if</span>(j == <span class="number">10</span>)&#123;  </span><br><span class="line">                 <span class="comment">//4):在main方法(线程)中,创建线程对象,并启动线程.  </span></span><br><span class="line">                 <span class="type">MusicThread</span> <span class="variable">music</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicThread</span>();  </span><br><span class="line">                 music.start();  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>方式2：实现Runable接口</strong></p>
<ul>
<li><strong>创建</strong>：<code>Thread  t = new Thread(new  A())</code>;</li>
<li><strong>调用</strong>：<code>t.start()</code>;</li>
<li>步骤<ul>
<li>定义一个类A实现于<code>java.lang.Runnable</code>接口,注意A类不是线程类.</li>
<li>在A类中覆盖<code>Runnable</code>接口中的<code>run</code>方法.</li>
<li>我们在<code>run</code>方法中编写需要执行的操作：<code>run</code>方法里的,线程执行体.</li>
<li>在<code>main</code>方法(线程)中,创建线程对象,并启动线程.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1):定义一个类A实现于java.lang.Runnable接口,注意A类不是线程类.  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicImplements</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="comment">//2):在A类中覆盖Runnable接口中的run方法.  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">//3):在run方法中编写需要执行的操作  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i ++)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;播放音乐&quot;</span>+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementsRunnableDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">50</span>; j ++)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;运行游戏&quot;</span>+j);  </span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">10</span>)&#123;  </span><br><span class="line">                <span class="comment">//4):在main方法(线程)中,创建线程对象,并启动线程  </span></span><br><span class="line">                <span class="type">MusicImplements</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicImplements</span>();  </span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mi);  </span><br><span class="line">                t.start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>实现<code>Runnable</code>接口相比继承<code>Thread</code>类有如下好处：</p>
<ul>
<li>避免点继承的局限，一个类可以继承多个接口。</li>
<li>适合于资源的共享</li>
</ul>
</li>
<li><p>创建并运行一个线程所犯的常见错误是调用线程的<code>run()</code>方法而非<code>start()</code>方法，如下所示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">newThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(MyRunnable());</span><br><span class="line">newThread.run();  <span class="comment">//should be start();</span></span><br></pre></td></tr></table></figure>

<p>　　起初并不会感觉到有什么不妥，因为<code>run()</code>方法的确如你所愿的被调用了。但是，事实上，<code>run()</code>方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行<code>run()</code>方法，必须调用新线程的<code>start()</code>方法。</p>
<h3 id="时间分片、交错执行、竞争条件"><a href="#时间分片、交错执行、竞争条件" class="headerlink" title="时间分片、交错执行、竞争条件"></a><em>时间分片、交错执行、竞争条件</em></h3><p> <strong>时间分片</strong></p>
<ul>
<li>虽然有多线程，但只有一个核，每个时刻只能执行一个线程。<ul>
<li>通过时间分片，再多个线程&#x2F;进程之间共享处理器</li>
</ul>
</li>
<li>即使是多核CPU，进程&#x2F;线程的数目也往往大于核的数目</li>
<li>通过时间分片，在多个进程&#x2F;线程之间共享处理器。（时间分片是由OS自动调度的）</li>
<li>当线程数多于处理器数量时，并发性通过时间片来模拟，处理器切换处理不同的线程</li>
</ul>
<p> <strong>交错执行</strong></p>
<p>　　顾名思义，就是说在线程运行的过程中，多个线程同时运行相互交错。而且，由于线程运行一般不是连续的，那么就会导致线程间的交错。可以说，所有线程安全问题的本质都是线程交错的问题。</p>
<p> <strong>竞争条件</strong></p>
<p>　　竞争是发生在线程交错的基础上的。当多个线程对同一对象进行读写访问时，就可能会导致竞争的问题。程序中可能出现的一种问题就是，读写数据发生了不同步。例如，我要用一个数据，在该数据修改还没写回内存中时就读取出来了，那么就会导致程序出现问题。</p>
<p>　　程序运行时有一种情况，就是程序如果要正确运行，必须保证A线程在B线程之前完成（正确性意味着程序运行满足其规约）。当发生这种情况时，就可以说A与B发生竞争关系。</p>
<ul>
<li>计算机运行过程中，并发、无序、大量的进程在使用有限、独占、不可抢占的资源，由于进程无限，资源有限，产生矛盾，这种矛盾称为竞争（Race）。</li>
<li>由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题，这叫做竞争条件（Race Condition）。</li>
<li>竞争条件分为两类:<br>-Mutex（互斥）：两个或多个进程彼此之间没有内在的制约关系，但是由于要抢占使用某个临界资源（不能被多个进程同时使用的资源，如打印机，变量）而产生制约关系。<br>-Synchronization（同步）：两个或多个进程彼此之间存在内在的制约关系（前一个进程执行完，其他的进程才能执行），如严格轮转法。</li>
<li>解决互斥方法：<br>Busy Waiting(忙等待)：等着但是不停的检查测试，不睡觉，知道能进行为止<br>Sleep and Wakeup(睡眠与唤醒)：引入Semapgore(信号量，包含整数和等待队列,为进程睡觉而设置)，唤醒由其他进程引发。</li>
<li>临界区（Critical Region）：<ul>
<li>一段访问临界资源的代码。</li>
<li>为了避免出现竞争条件，进入临界区要遵循四条原则： <ul>
<li>任何两个进程不能同时进入访问同一临界资源的临界区</li>
<li>进程的个数，CPU个数性能等都是无序的，随机的</li>
<li>临界区之外的进程不得阻塞其他进程进入临界区</li>
<li>任何进程都不应被长期阻塞在临界区之外</li>
</ul>
</li>
</ul>
</li>
<li>解决互斥的方法:<br>• 禁用中断 Disabling interrupts<br>• 锁变量 Lock variables （no）<br>• 严格轮转 Strict alternation (no)<br>• Peterson’s solution (yes)<br>• The TSL instruction (yes)</li>
</ul>
<h3 id="线程的休眠、中断"><a href="#线程的休眠、中断" class="headerlink" title="线程的休眠、中断"></a><em>线程的休眠、中断</em></h3><p> <strong><code>Thread.sleep</code></strong></p>
<ul>
<li>在线程中允许一个线程进行暂时的休眠，直接使用<code>Thread.sleep()</code>方法即可。 <ul>
<li>将某个线程休眠，意味着其他线程得到更多的执行机会</li>
<li>进入休眠的线程不会失去对现有monitor或锁的所有权</li>
</ul>
</li>
<li>sleep定义格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> milis,<span class="type">int</span> nanos)</span></span><br><span class="line">       <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<p>　　首先，**<code>static</code>，说明可以由<code>Thread</code>类名称调用<strong>，其次</strong><code>throws</code>表示如果有异常要在调用此方法处处理异常**。</p>
<p><strong>所以<code>sleep()</code>方法要有<code>InterruptedException</code>异常处理，而且<code>sleep()</code>调用方法通常为<code>Thread.sleep(500);</code>形式。</strong></p>
<p><strong><code>Thread.interrupt</code></strong> </p>
<ul>
<li><p>一个线程可以被另一个线程中断其操作的状态，使用<code>interrupt()</code>方法完成。</p>
<ul>
<li>通过线程的实例来调用<code>interrupt()</code>函数，向线程发出中断信号</li>
<li><code>t.interrupt()</code>：在其他线程里向<code>t</code>发出中断信号</li>
<li><code>t.isInterrupted()</code>：检查<code>t</code>是否已在中断状态中</li>
</ul>
</li>
<li><p>当某个线程被中断后，一般来说应停止其<code>run()</code>中的执行，取决于程序员在<code>run()</code>中处理</p>
<ul>
<li>一般来说，线程在收到中断信号时应该中断，直接终止</li>
<li>但是，线程收到其他线程发出来的中断信号，并不意味着一定要“停止”</li>
</ul>
</li>
<li><p>实例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Thread1;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;    <span class="comment">// 实现Runnable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;    <span class="comment">// 覆写run()方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1、进入run()方法&quot;</span>) ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>) ;    <span class="comment">// 线程休眠10秒</span></span><br><span class="line">                System.out.println(<span class="string">&quot;2、已经完成了休眠&quot;</span>) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3、休眠被终止&quot;</span>) ;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">// 返回调用处</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;4、run()方法正常结束&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;    <span class="comment">// 实例化Runnable子类对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mt,<span class="string">&quot;线程&quot;</span>);        <span class="comment">// 实例化Thread对象</span></span><br><span class="line">        t.start() ;    <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>) ;    <span class="comment">// 线程休眠2秒</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3、休眠被终止&quot;</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt() ;    <span class="comment">// 中断线程执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、进入run()方法</span><br><span class="line">3、休眠被终止</span><br></pre></td></tr></table></figure>

<h3 id="线程安全的四个策略"><a href="#线程安全的四个策略" class="headerlink" title="线程安全的四个策略"></a><em>线程安全的四个策略</em></h3><ul>
<li>线程安全的定义：ADT或方法在多线程中要执行正确，即无论如何执行，不许调度者做额外的协作，都能满足正确性</li>
<li>四种线程安全的策略：<ul>
<li>Confinement 限制数据共享</li>
<li>Immutability 共享不可变数据</li>
<li>Threadsafe data type 共享线程安全的可变数据</li>
<li>Synchronization 同步机制共享共享线程不安全的可变数据，对外即为线程安全的ADT.</li>
</ul>
</li>
</ul>
<p><strong>Confinement限制数据共享</strong></p>
<ul>
<li>核心思想：线程之间不共享mutable数据类型<ul>
<li>将可变数据限制在单一线程内部，避免竞争</li>
<li>不允许任何县城直接读写该数据</li>
</ul>
</li>
<li>在多线程环境中，取消全局变量，尽量避免使用不安全的静态变量。<ul>
<li>限制数据共享主要是在线程内部使用局部变量，因为局部变量在每个函数的栈内，每个函数都有自己的栈结构，互不影响，这样局部变量之间也互不影响。</li>
<li>如果局部变量是一个指向对象的引用，那么就需要检查该对象是否被限制住，如果没有被限制住（即可以被其他线程所访问），那么就没有限制住数据，因此也就不能用这种方法来保证线程安全</li>
</ul>
</li>
<li><em><strong>examples</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes n! and prints it on standard output.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n must be &gt;= 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">computeFact</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;working on fact &quot;</span> + n);</span><br><span class="line">            result = result.multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;fact(&quot;</span> + n + <span class="string">&quot;) = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">// create a thread using an</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;     <span class="comment">// anonymous Runnable</span></span><br><span class="line">                computeFact(<span class="number">99</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        computeFact(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 解释：主函数开启了两个线程，调用的是相同函数。因为线程共享局部变量的类型，但每个函数调用有不同的栈，因此有不同的<code>i, n, result</code>。由于每个函数都有自己的局部变量，那么每个函数就可以独立运行，更新它们自己的函数值，线程之间不影响结果。</p>
<p><strong>Immutability共享不可变数据</strong> </p>
<p>不可变数据类型，指那些在整个程序运行过程中，指向内存的引用是一直不变的，通常使用<code>final</code>来修饰。不可变数据类型通常来讲是线程安全的，但也可能发生意外。</p>
<p>但是，程序在运行过程中，有时为了优化程序结构，默默地将这个引用更改了。此时，客户端程序员是不知道它被更改了，对于客户端而言，这个引用还是不可变的，但其实已经被悄悄更改了。这时就会发生一些线程安全问题。</p>
<p>解决方案就是给这些不可变数据类型再增加一些限制：</p>
<ul>
<li>所有的方法和属性都是私有的。</li>
<li>不提供可变的方法，即不对外开放可以更改内部属性的方法。</li>
<li>没有数据的泄露，即返回值而不是引用。</li>
<li>不在其中存储可变数据对象。</li>
</ul>
<p>这样就可以保证线程的安全了。</p>
<p><strong>Threadsafe data type（共享线程安全的可变数据）</strong></p>
<ul>
<li>方法：如果必须要用mutable的数据类型在多线程之间共享数据，要使用线程安全的数据类型。（在JDK中的类，文档中明确指明了是否threadsafe）</li>
<li>一般来说，JDK同时提供两个相同功能的类，一个是threadsafe，另一个不是。原因：threadsafe的类一般性能上受影响。</li>
<li><code>List、Set、Map</code>这些集合类都是线程不安全的，Java API为这些集合类提供了进一步的decorator</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Boolean&gt; cache = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; SortedSet&lt;T&gt; <span class="title function_">synchronizedSortedSet</span><span class="params">(SortedSet&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; SortedMap&lt;K,V&gt; <span class="title function_">synchronizedSortedMap</span><span class="params">(SortedMap&lt;K,V&gt; m)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用<code>synchronizedMap(hashMap)</code>之后，不要再把参数<code>hashMap</code>共享给其他线程，不要保留别名，一定要彻底销毁.（可以用<code>private static Map cache = Collections.synchronizedMap(new HashMap&lt;&gt;())</code>;的方式实例化集合类）</li>
<li>即使在线程安全的集合类上，使用<code>iterator</code>也是不安全的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Type&gt; c = Collections.synchronizedList(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">ArrayList</span>&lt;Type&gt;());</span><br><span class="line"><span class="keyword">synchronized</span>(c) &#123; <span class="comment">// to be introduced later (the 4-th threadsafe way)</span></span><br><span class="line">    <span class="keyword">for</span> (Type e : c)</span><br><span class="line">        foo(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意用java提供的包装类包装集合后，只是将集合的每个操作都看成了原子操作，也就保证了每个操作内部的正确性，但是在两个操作之间不能保证集合类不被修改，因此需要用lock机制，例如</li>
</ul>
<p>　　如果在<code>isEmpty</code>和<code>get</code>中间，将元素移除，也就产生了竞争。</p>
<p><strong>前三种策略的核心思想：避免共享$\to$即使共享，也只能读&#x2F;不可写(immutable)$\to$即使可写(mutable)，共享的可写数据应自己具备在多线程之间协调的能力，即“使用线程安全的mutable ADT”</strong></p>
<p> <strong>Synchronization同步与锁</strong></p>
<ul>
<li><p>为什么要同步</p>
<ul>
<li>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）</li>
<li>将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用</li>
<li>保证了该变量的唯一性和准确性</li>
</ul>
</li>
<li><p>同步方法</p>
<ul>
<li><p>即有<code>synchronized</code>关键字修饰的方法。</p>
</li>
<li><p>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。</p>
</li>
<li><p>在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><pre><code>注：`synchronized`关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类
</code></pre>
</li>
</ul>
</li>
<li><p>同步代码块</p>
</li>
</ul>
<pre><code>-   在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

-   被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。

-   代码如：

    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123;...&#125;</span><br></pre></td></tr></table></figure>

-   注：同步是一种高开销的操作，因此应该尽量减少同步的内容。
</code></pre>
<ul>
<li><p>使用锁机制，获得对数据的独家mutation权，其他线程被阻塞，不得访问</p>
</li>
<li><p>Lock是Java语言提供的内嵌机制，每个object都有相关联的lock</p>
</li>
<li><p>任何共享的mutable变量&#x2F;对象必须被lock所保护</p>
</li>
<li><p>涉及到多个mutable变量的时候，它们必须被同一个lock所保护</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><em>死锁</em></h3><ul>
<li><p><strong>定义</strong>：两个或多个线程相互等待对方释放锁，则会出现死锁现象。</p>
</li>
<li><p>java虚拟机没有检测，也没有采用措施来处理死锁情况，所以多线程编程是应该采取措施避免死锁的出现。一旦出现死锁，整个程序即不会发生任何异常，也不会给出任何提示，只是所有线程都处于堵塞状态。</p>
</li>
<li><p><strong>形成死锁的条件：</strong></p>
<ul>
<li>互斥条件：线程使用的资源必须至少有一个是不能共享的（至少有锁）；</li>
<li>请求与保持条件：至少有一个线程必须持有一个资源并且正在等待获取一个当前被其它线程持有的资源（至少两个线程持有不同锁，又在等待对方持有锁）；</li>
<li>非剥夺条件：分配资源不能从相应的线程中被强制剥夺（不能强行获取被其他线程持有锁）；</li>
<li>循环等待条件：第一个线程等待其它线程，后者又在等待第一个线程（线程$A$等线程$B$；线程$B$等线程$C$; $\cdots$ ;线程$N$等线程$A$。如此形成环路）。</li>
</ul>
</li>
<li><p>防止死锁的方法：</p>
<ul>
<li><strong>加锁顺序：</strong>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。这种方式是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的</li>
</ul>
</li>
<li><ul>
<li><p>使用粗粒度的锁，用单个锁来监控多个对象</p>
<ul>
<li>对整个社交网 络设置 一个锁 ，并且对其任何组成部分的所有操作都在该锁上进行同步。</li>
<li>例如：所有的Wizards都属于一个Castle,  可使用 castle 实例的锁</li>
</ul>
<p>　　缺点：性能损失大；</p>
<ul>
<li>如果用一个锁保护大量的可变数据，那么久放弃了同时访问这些数据的能力；</li>
<li>在最糟糕的情况下，程序可能基本上是顺序执行的，丧失了并发性</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>加锁时限</strong>：在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁。</li>
<li>用 jstack 等工具进行死锁检测</li>
</ul>
</li>
</ul>
<h3 id="以注释的形式撰写线程安全策略"><a href="#以注释的形式撰写线程安全策略" class="headerlink" title="以注释的形式撰写线程安全策略"></a><em>以注释的形式撰写线程安全策略</em></h3><ul>
<li><p>在代码中以注释的形式添加说明：该ADT采取了什么设计决策来保证线程安全</p>
</li>
<li><p>阐述如何使rep线程安全；</p>
</li>
<li><p>写入表示不变性的说明中，以便代码维护者知道你是如何为类设计线程安全性的。</p>
</li>
<li><p>需要对安全性进行这种仔细的论证，阐述使用了哪种技术，使用threadsafe data types, or synchronization时，需要论证所有对数据的访问都是具有原子性的</p>
</li>
<li><p>字符串是不可变的并且是线程安全的; 但是指向该字符串的rep，特别是文本变量，并不是不可变的；</p>
</li>
<li><p>文本不是最终变量，因为我们需要数据类型来支持插入和删除操作；</p>
</li>
<li><p>因此读取和写入文本变量本身不是线程安全的。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/01/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%205/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/07/01/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%205/" class="post-title-link" itemprop="url">软件构造知识点总结 - 5</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-01 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-01T00:00:00+08:00">2019-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:47:21" itemprop="dateModified" datetime="2024-04-26T10:47:21+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/" itemprop="url" rel="index"><span itemprop="name">软件构造</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="第一节-软件构造性能的度量原理"><a href="#第一节-软件构造性能的度量原理" class="headerlink" title="第一节 软件构造性能的度量原理"></a>第一节 软件构造性能的度量原理</h2><h3 id="性能度量指标"><a href="#性能度量指标" class="headerlink" title="性能度量指标"></a><em>性能度量指标</em></h3><ul>
<li>时间性能<ul>
<li>每条指令、每个控制 结构、整个程序的执行时间</li>
<li>不同语句或控制结构执行时间的分布情况</li>
<li>时间瓶颈在哪里</li>
</ul>
</li>
<li>空间性能<ul>
<li>每个变量、每个复杂结构、整个程序的内存消耗</li>
<li>不同变量&#x2F;数据结构的相对消耗</li>
<li>空间瓶颈在哪里</li>
<li>随时间的变化情况</li>
</ul>
</li>
</ul>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a><em>内存管理</em></h3><p><strong>对象管理模型</strong></p>
<ul>
<li><p>三者的差异在于：如何与何时在程序对象与内存对象之间建立联系</p>
</li>
<li><p>静态</p>
<ul>
<li><strong>定义</strong>：静态内存是指在程序开始运行时由编译器分配的内存，它的分配是在程序开始编译时完成的，不占用CPU资源。</li>
<li>程序中的各种变量，在编译时系统已经为其分配了所需的内存空间，当该变量在作用域内使用完毕时，系统会自动释放所占用的内存空间；</li>
<li>不支持递归，不支持动态创建可变长的复杂数据类型；</li>
<li>在程序执行期内实体至多关联一个运行时对象</li>
<li>eg: 基本类型，数组</li>
</ul>
</li>
<li><p>动态-基于栈</p>
<ul>
<li>栈定义：方法调用和局部变量的存储位置，保存基本类型<ul>
<li>如果一个方法被调用，它的栈帧被放到调用栈的顶部</li>
<li>栈帧保存方法的状态，包括执行哪行代码以及所有局部变量的值</li>
<li>栈顶始终是当前运行方法</li>
</ul>
</li>
<li>一个实体可以在运行时连续地连接到多个对象，并且运行时机制以堆栈中的<strong>后进先出</strong>顺序分配和释放这些对象</li>
<li>栈无法支持复杂数据结构</li>
</ul>
</li>
<li><p>动态-基于堆</p>
<ul>
<li><strong>堆定义</strong>：在一块内存里分为多个小块，每块包含 一个对象，或者未被占用</li>
<li>自由模式的内存管理，动态分配，可管理复杂的动态数据结构</li>
<li>代码中的一个变量可以在不同时间被关联到不同的内存对象上，无法在编译阶段确定。内存对象也可以进一步指向其他对象</li>
</ul>
</li>
</ul>
<h3 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a><em>Java垃圾回收机制</em></h3><p><strong>内存回收的三种方式</strong></p>
<p>​    ①静态模式下的内存回收：在静态内存分配模式下，无需进行内存回收：所有都是已确定的。</p>
<p>​    ②在栈模式下的内存回收：按block（某个方法）整体进行</p>
<p>​    ③在堆模式下的内存回收：在heap上进行内存空间回收，最复杂——无法提前预知某个object是否已经变得无用。</p>
<p> <strong>动态垃圾回收相关概念</strong></p>
<ul>
<li>GC（Garbage Collection）：识别垃圾并释放其占用的内存<ul>
<li>垃圾回收器根据对象的“活性”(从root的可达性)来决定是否回收该对象的内存，”死“的对象是需要回收的垃圾</li>
</ul>
</li>
<li>Root<ul>
<li>根集合由root对象和局部对象构成</li>
<li>root对象：<code>Class</code>（不能被回收）、<code>Thread</code>、Java方法&#x2F;接口的本地变量或参数、全局接口引用等</li>
</ul>
</li>
<li>可达&#x2F;不可达对象（Reachable&#x2F;Unreachable）：free模式<ul>
<li>从根可以直接或间接到达的对象为可达的，否则为不可达的</li>
<li>从根开始，不断将指向的对象加入活动集，剩下的是垃圾</li>
</ul>
</li>
<li>活动&#x2F;死亡对象（Live&#x2F;dead）：<ul>
<li>在stack和free的结合模式下，对象的引用被视为有向图，可以从根访问的对象为活动对象，否则为死亡对象。</li>
</ul>
</li>
</ul>
<p><strong>GC的四种算法</strong></p>
<ul>
<li><p>引用计数</p>
<ul>
<li><strong>基本思想</strong>：为每个object存储一个计数RC，当有其他 reference指向它时，RC++；当其他reference与其断开时，RC–；如 果RC&#x3D;&#x3D;0，则回收它。</li>
<li><strong>优点</strong>：简单、计算代价分散，“幽灵时间”短 为0</li>
<li><strong>缺点</strong>：不全面（容易漏掉循环引用的对象）、并发支 持较弱、占用额外内存空间、等</li>
</ul>
</li>
<li><p>Mark-Sweep（标记-清除）算法</p>
<ul>
<li><strong>基本思想</strong>：为每个object设定状态位(live&#x2F;dead)并记录，即mark阶段；将标记为dead的对象进行清理，即sweep可阶段。</li>
<li><strong>优点：</strong>可以处理循环调用，指针操作无开销，对象不变</li>
<li><strong>缺点</strong>：复杂度为O(heap),高　堆的占用比高时影响性能，容易造成碎片，需要找到root</li>
</ul>
</li>
<li><p>Copying（复制）算法</p>
<ul>
<li><strong>基本思想</strong>：为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。</li>
<li><strong>优势</strong>：运行高效、不易产生内存碎片</li>
<li><strong>缺点</strong>：复制花费大量的时间，牺牲内存空间</li>
</ul>
</li>
<li><p>Mark-Compact（标记-整理）算法</p>
<ul>
<li>基本思想：为了解决Copying算法的缺陷，充分利用内存空间，提出了Mark-Compact算法。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。</li>
</ul>
</li>
</ul>
<h3 id="JVM中的GC"><a href="#JVM中的GC" class="headerlink" title="JVM中的GC"></a><em>JVM中的GC</em></h3><p>Java GC将堆分为不同的区域，各区域采用不同的GC策略，以提高GC的效率</p>
<ul>
<li><p>Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。</p>
</li>
<li><p>对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）</p>
</li>
<li><p>年轻代：</p>
<ul>
<li>对象被创建时，内存的分配首先发生在年轻代（大对象可以直接 被创建在年老代）</li>
<li>大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消 亡的）</li>
<li>为减少GC代价，<strong>使用copying算法</strong></li>
<li>具体过程<ol>
<li>绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</li>
<li>当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；</li>
<li>此后，每次Eden区满了，就执行一次Minor GC，并将剩余的对象都添加到Survivor0；</li>
<li>当Survivor0也满的时候，将其中仍然活着的对象直接复制到Survivor1，以后Eden区执行Minor GC后，就将剩余的对象添加Survivor1（此时，Survivor0是空白的）。</li>
<li>当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</li>
</ol>
</li>
</ul>
</li>
<li><p>年老代：</p>
<ul>
<li>对象如果在年轻代存活了足够长的时间而没有被清理掉，则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。</li>
<li>使用Mark-Sweep或Mark-Compact算法；</li>
<li>Minor GC和full GC独立进行，减小代价；</li>
<li>当perm generation满了之后，无法存储更多的元数据，也启动full GC。</li>
</ul>
</li>
</ul>
<h3 id="GVM-GC性能调优"><a href="#GVM-GC性能调优" class="headerlink" title="GVM GC性能调优"></a><em>GVM GC性能调优</em></h3><ul>
<li>尽可能减少GC时间，一般不超过程序执行时间的5%</li>
<li>一旦初始分配给程序的内存满了，就抛出内存溢出异常，</li>
<li>在启动程序时，可为其配置内存分配的具体大小</li>
<li>堆的大小决定着VM将会以何种频度进行GC、每次GC的时间多长。<ul>
<li>这两个指标具体取值多少为“优”，需要针对特定应用进行分析。</li>
<li>较大的heap会导致较少发生GC，但每次GC时间很长</li>
<li>如果根据程序需要来设置heap大小，则需要频繁GC，但每次GC的时间较短</li>
</ul>
</li>
<li>设定堆的大小的具体方法</li>
</ul>
<pre><code>-   `Xmx/-Xms`：指定年轻代和老年代空间的初始值和最大值；`Xms`小于`Xmx`时，年轻代和老年代所消耗的空间量可以根据应用程序的需求增长或收缩；Java堆的增长不会比`Xms`大，也不会比`Xmx`小
-   `XX: NewSize=&lt;n&gt;[g|m|k]`：年轻代空间的初始和最小尺寸，`&lt;n&gt;`是大小，`[g | m | k]`指示大小是否应解释为千兆字节，兆字节或千字节
-   `XX: MaxNewSize=&lt;n&gt;[g|m|k]`：年轻代空间的最大值
-   `Xmn&lt;n&gt;[g|m|k]`：将年轻代的初始值、最小值、最大值设为同一值
</code></pre>
<ul>
<li><p>GC模式选择</p>
<ul>
<li>增长或收缩年轻代或老年代的空间时需要Full GC</li>
<li>Full GC可能会降低吞吐量并导致超出期望的延迟</li>
<li>串行收集器（-XX:+UseSerialGC）：使用单个线程执行所有垃圾收集工作</li>
<li>并行收集器（-XX:+UseParallelGC）：并行执行Minor GC，显著减少垃圾收集开销</li>
<li>并发低暂停收集器（-XX:+UseConcMarkSweepGC）：收集持久代，与执行应用程序同时执行大部分收集，在收集期间会暂停一小段时间</li>
<li>增量低暂停收集器（-XX:+UseTrainGC）：收集每个Minor的部分老年代，并尽量减少Major的大停顿</li>
<li>-verbose:gc：打印GC信息</li>
</ul>
</li>
<li><p>堆设置<br>-Xms：初始堆大小<br>-Xmx：最大堆大小<br>-XX:NewSize&#x3D;n：设置年轻代大小<br>-XX:NewRatio&#x3D;n：设置年轻代和年老代的比值。如：为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4<br>-XX:SurvivorRatio&#x3D;n：年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor&#x3D;3:2，一个Survivor区占整个年轻代的1&#x2F;5<br>-XX:MaxPermSize&#x3D;n：设置持久代大小</p>
</li>
<li><p>收集器设置<br>-XX:+UseSerialGC：设置串行收集器<br>-XX:+UseParallelGC：设置并行收集器<br>-XX:+UseParalledlOldGC：设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC：设置并发收集器</p>
</li>
<li><p>垃圾回收统计信息<br>-XX：+PrintGC<br>-XX：+PrintGCDetails<br>-XX：+PrintGCTimeStamps<br>-Xloggc：filename</p>
</li>
<li><p>并行收集器设置<br>-XX:ParallelGCThreads&#x3D;n：设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis&#x3D;n：设置并行收集最大暂停时间<br>-XX:GCTimeRatio&#x3D;n：设置垃圾回收时间占程序运行时间的百分比。公式为$\frac{1}{1+n}$</p>
</li>
<li><p>并发收集器设置<br>-XX:+CMSIncrementalMode：设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads&#x3D;n：设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
</li>
</ul>
<h2 id="第二节-动态程序分析方法与工具"><a href="#第二节-动态程序分析方法与工具" class="headerlink" title="第二节 动态程序分析方法与工具"></a>第二节 动态程序分析方法与工具</h2><ul>
<li>Jstat：获取JVM的Heap使用和GC的性能统计数据，命令如-gcutil</li>
<li>Jmap：输出内存中的对象分布情况  如：jmap -clstats</li>
<li>Jhat：导出heap dump，浏览&#x2F;查询其中的对象分布情况</li>
<li>jstack：获取Java线程的stack trace 具体用途如下：<ul>
<li>定位线程出现长时间停顿的原因，如多线程间死锁、死循环、请求外部资源 导致的长时间等待等。</li>
<li>线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没 有响应的线程到底在后台做什么事情，或者等待什么资源。</li>
</ul>
</li>
<li>Visual VM：提供了一个可视化界面，用于查看Java应用程序在JVM上运行时的详细信息，使用各种技术，包括jvmstat，JMX，Serviceability Agent（SA）和Attach API等</li>
<li>MAT：内存堆导出文件的分析工具，生成饼状图等，能够对问题发生时刻的系统内存状态获取一个整体印象，找到最有可能导致内存泄露的对象，进一步查看其是否有异常行为。</li>
</ul>
<h3 id="Memory-Dump（堆转储文件）"><a href="#Memory-Dump（堆转储文件）" class="headerlink" title="Memory Dump（堆转储文件）"></a><em>Memory Dump（堆转储文件）</em></h3><p>正如Thread Dump文件记录了当时JVM中线程运行的情况一样，Heap Dump记录了JVM中堆内存运行的情况，可使用jmap或JConsole命令生成，jhat分析。</p>
<p><strong>使用 jmap 命令生成</strong></p>
<p><strong>使用JConsole生成</strong></p>
<p><strong>使用jhat分析</strong> </p>
<h3 id="Stack-Trace"><a href="#Stack-Trace" class="headerlink" title="Stack Trace"></a><em>Stack Trace</em></h3><p>　　可使用jstack查看，定位线程出现长时间停顿的原因。</p>
<h2 id="第三节-代码调优的设计模式和I-O"><a href="#第三节-代码调优的设计模式和I-O" class="headerlink" title="第三节 代码调优的设计模式和I&#x2F;O"></a>第三节 代码调优的设计模式和I&#x2F;O</h2><h2 id="代码调优"><a href="#代码调优" class="headerlink" title="代码调优"></a>代码调优</h2><p><strong>代码调优的概念</strong></p>
<ul>
<li>代码调优：代码调优不是为了修复bug，而是对正确的代码进行修改以提高其性能，其常常是小规模的变化<ul>
<li>调优不会减少代码行数</li>
<li>不要猜原因，而应有明确的优化目标</li>
<li>不要边写程序边调优</li>
<li>不是性能优化的第一选择</li>
<li>代码行数与性能之间无必然的联系</li>
<li>代码调优建立在对程序性能的精确度量基础之上（profiling）</li>
<li>当程序做过某些调整之后，要重新profiling并重新了解需要优化的性能瓶颈，微小的变化能导致优化方向大不相同</li>
</ul>
</li>
<li>性能从不是追求的第一目标，正确性比性能更重要</li>
</ul>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1338.html">单例模式</a>（Singleton Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1371.html">享元模式</a>（Flyweight Pattern）</strong></p>
<p><strong><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1343.html">原型模式</a>（Prototype Pattern）</strong></p>
<p><strong>对象池模式（Object Pool Pattern）</strong></p>
<h3 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I&#x2F;O"></a><em>Java I&#x2F;O</em></h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/06/28/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%204/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/06/28/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%204/" class="post-title-link" itemprop="url">软件构造知识点总结 - 4</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-28 00:00:00" itemprop="dateCreated datePublished" datetime="2019-06-28T00:00:00+08:00">2019-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:47:23" itemprop="dateModified" datetime="2024-04-26T10:47:23+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/" itemprop="url" rel="index"><span itemprop="name">软件构造</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="第一节-健壮性和正确性的区别"><a href="#第一节-健壮性和正确性的区别" class="headerlink" title="第一节  健壮性和正确性的区别"></a>第一节  健壮性和正确性的区别</h2><h3 id="健壮性-Robustness-和正确性-correctness"><a href="#健壮性-Robustness-和正确性-correctness" class="headerlink" title="健壮性(Robustness)和正确性(correctness)"></a><em>健壮性(Robustness)和正确性(correctness)</em></h3><p><strong>健壮性</strong></p>
<ul>
<li>定义：系统在不 正常输入或不正常外部环境下仍能够表现正常的程度</li>
<li>面向健壮性编程：<ul>
<li>处理未期望的行为和错误终止</li>
<li>即使终止执行，也要准确&#x2F;无歧义的向用户展示全面的错误信息</li>
<li>错误信息有助于进行debug</li>
</ul>
</li>
<li>健壮性原则：<ul>
<li>Paranoia (偏执狂)：总是假定用户恶意、假定自己的代码可能失败</li>
<li>把用户想象成白痴，可能输入任何东西（返回给用户的错误提示信息要详细、准确、无歧义）</li>
<li>对别人宽容点，对自己狠一点（对自己的代码要保守，对用户的行为要开放）</li>
</ul>
</li>
<li>面向健壮性编程的原则：<ul>
<li>封闭实现细节，限定用户的恶意行为</li>
<li>考虑极端情况，没有“不可能”</li>
</ul>
</li>
</ul>
<p><strong>正确性</strong></p>
<ul>
<li>含义：程序按照spec加以执行的能力，是最重要的质量指标。</li>
<li>对比健壮性和正确性：<ul>
<li>正确性：永不给用户错误的结果； 让开发者变得更容易：用户输入错误，直接结束（不满足precondition调用）。</li>
<li>健壮性：尽可能保持软件运行而不是总是退出； 让用户变得更容易：出错也可以容忍，程序内部已有容错机制。</li>
<li>正确性倾向于直接报错(error)，健壮性则倾向于容错(fault-tolerance)；</li>
<li>对外的接口，倾向于健壮性；对内的实现，倾向于正确性。</li>
<li>Reliability（可靠性） &#x3D; Robustness + correctness</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Problem</th>
<th align="center">健壮性</th>
<th align="center">正确性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">浏览器发出包含空格的URL</td>
<td align="center">剥离空白，正常处理请求。</td>
<td align="center">将HTTP 400错误请求错误状态返回给客户端。</td>
</tr>
<tr>
<td align="center">视频文件有坏帧</td>
<td align="center">跳过腐败区域到下一个可播放部分。</td>
<td align="center">停止播放，引发“损坏的视频文件”错误</td>
</tr>
<tr>
<td align="center">配置文件使用了非法字符</td>
<td align="center">在内部识别最常见的评论前缀，忽略它们。</td>
<td align="center">终止启动时出现“配置错误”错误</td>
</tr>
<tr>
<td align="center">奇怪格式的日期输入</td>
<td align="center">尝试针对多种不同的日期格式解析字符串。将正确的格式呈现给用户。</td>
<td align="center">日期错误无效</td>
</tr>
</tbody></table>
<h3 id="如何测量健壮性和正确性"><a href="#如何测量健壮性和正确性" class="headerlink" title="如何测量健壮性和正确性"></a><em>如何测量健壮性和正确性</em></h3><ul>
<li>外部观察角度：<ul>
<li>Mean time between failures (MTBF，平均失效间隔时间)：描述了可修复系统的两次故障之间的预期时间，而平均故障时间（MTTF）表示不可修复系统的预期故障时间。</li>
</ul>
</li>
<li>内部观察角度：<ul>
<li>残余缺陷率：每千行代码中遗留的bug的数量</li>
</ul>
</li>
</ul>
<h2 id="第二节-错误与异常处理"><a href="#第二节-错误与异常处理" class="headerlink" title="第二节 错误与异常处理"></a>第二节 错误与异常处理</h2><h3 id="Java中的错误和异常"><a href="#Java中的错误和异常" class="headerlink" title="Java中的错误和异常"></a><em>Java中的错误和异常</em></h3><p><strong>Throwable</strong></p>
<ul>
<li>Java.lang.throwable <ul>
<li>Throwable 类是 Java 语言中所有错误或异常的超类。</li>
<li>继承的类：extends Object。</li>
<li>实现的接口：implements Serializable。</li>
<li>直接已知子类：Error, Exception（直接已知子类：IOException、RuntimeException）。</li>
</ul>
</li>
</ul>
<p><strong>Error</strong></p>
<ul>
<li>Error类描述很少发生的Java运行时系统内部的系统错误和资源耗尽情况（例如，VirtualMachineError，LinkageError）。</li>
<li>对于内部错误：程序员通常无能为力，一旦发生，想办法让程序优雅的结束</li>
<li>Error的类型：<ul>
<li>用户输入错误<ul>
<li>例如：用户要求连接到语法错误的URL，网络层会投诉。</li>
</ul>
</li>
<li>设备错误<ul>
<li>硬件并不总是做你想做的。</li>
<li>输出器被关闭</li>
</ul>
</li>
<li>物理限制<ul>
<li>磁盘可以填满</li>
<li>可能耗尽了可用内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="异常（Exception）"><a href="#异常（Exception）" class="headerlink" title="异常（Exception）"></a><em>异常（Exception）</em></h3><ul>
<li>异常：程序执行中的非正常事件，程序无法再按预想的流程执行。</li>
<li>异常处理：<ul>
<li>将错误信息传递给上层调用者，并报告“案发现场”的信息。</li>
<li><code>return</code>之外的第二种退出途径：若找不到异常处理程序，整个系统完全退出</li>
</ul>
</li>
</ul>
<p><strong>【异常按结构层次的分类】</strong></p>
<ul>
<li>运行时异常：由程序员处理不当造成，如空指针、数组越界、类型转换</li>
<li>其他异常：程序员无法完全控制的外在问题所导致的，通常为IOE异常，即找不到文件路径等</li>
</ul>
<p><strong>【异常按处理机制角度的分类】</strong></p>
<ul>
<li><p>为什么区分checked 和 unchecked：原因其实很简单，编译器将检查你是否为所有的已检查异常提供了异常处理机制，比如说我们使用<code>Class.forName()</code>来查找给定的字符串的<code>class</code>对象的时候，如果没有为这个方法提供异常处理，编译是无法通过的。 </p>
</li>
<li><p>Checked exception：</p>
<ul>
<li>编译器可帮助检查你的程序是否已抛出或处理了可能的异常</li>
<li>异常的向上抛出机制进行处理，如果子类可能产生A异常，那么在父类中也必须<code>throws A</code>异常。可能导致的问题：代码效率低，耦合度过高。</li>
<li>checked exception是需要强制catch的异常，你在调用这个方法的时候，你如果不catch这个异常，那么编译器就会报错，比如说我们读写文件的时候会<code>catch IOException</code>，执行数据库操作会有<code>SQLException</code>等。</li>
<li>对checked Exception处理机制　　　　<ul>
<li>抛出：声明是<code>throws</code>，抛出时<code>throw</code>　　　</li>
<li>捕获（<code>try</code>&#x2F;<code>catch</code>）：<code>try</code>出现异常，忽略后面代码直接进入<code>catch</code>；无异常不进入<code>catch</code>；若<code>catch</code>中没有匹配的异常处理，程序退出；若子类重写了父类方法，父类方法没有抛出异常，子类应自己处理全部异常而不再传播；子类从父类继承的方法不能增加或更改异常</li>
<li>处理：不能代替简单的测试，尽量苛刻、不过分细化、将正常处理与异常处理分开、利用好层次结构、早抛出晚捕获、避免不必要的检查</li>
<li>清理现场、释放资源（<code>finally</code>）：<code>finally</code>中语句不论有无异常都执行</li>
</ul>
</li>
</ul>
</li>
<li><p>unchecked exception：</p>
<ul>
<li>程序猿对此不做任何事情，不得不重写你的代码（不需要在编译时使用<code>try-catch</code>等机制处理）</li>
<li>这类异常都是<code>RuntimeException</code>的子类，它们不能通过client code来试图解决</li>
<li>这种异常不是必须需要<code>catch</code>的，你是无法预料的，比如说在调用一个<code>list.size()</code>时，如果<code>list</code>为<code>null</code>，那么就会报<code>NullPointerException</code>，而这个异常就是 <code>RuntimeException</code>，也就是<code>UncheckedException</code></li>
<li>常见的unchecked exception：JVM抛出，如空指针、数组越界、数据格式、不合法的参数、不合法的状态、找不到类等</li>
</ul>
</li>
</ul>
<p><strong>checked和unchecked总结</strong></p>
<ul>
<li>当要决定是采用checked exception还是Unchecked exception的时候，问一个问题： “如果这种异常一旦抛出，client会做怎样的补救？”<ul>
<li>如果客户端可以通过其他的方法恢复异常，那么采用checked exception；</li>
<li>如果客户端对出现的这种异常无能为力，那么采用unchecked exception；</li>
<li>异常出现的时候，要做一些试图恢复它的动作而不要仅仅的打印它的信息。</li>
</ul>
</li>
<li>尽量使用unchecked exception来处理编程错误：因为uncheckedexception不用使客户端代码显式的处理它们，它们自己会在出现的地方挂起程序并打印出异常信息。</li>
<li>如果client端对某种异常无能为力，可以把它转变为一个unchecked exception，程序被挂起并返回客户端异常信息</li>
</ul>
<p> <strong>Checked exception应该让客户端从中得到丰富的信息。</strong> </p>
<p><strong>要想让代码更加易读，倾向于用unchecked exception来处理程序中的错误</strong></p>
<h3 id="checked异常的处理机制"><a href="#checked异常的处理机制" class="headerlink" title="checked异常的处理机制"></a><em>checked异常的处理机制</em></h3><p> <strong>异常中的LSP原则</strong></p>
<ul>
<li>如果子类型中<code>override</code>了父类型中的函数，那么子类型中方法抛出的异常不能比父类型抛出的异常类型更广泛</li>
<li>子类型方法可以抛出更具体的异常，也可以不抛出任何异常</li>
<li>如果父类型的方法未抛出异常，那么子类型的方法也不能抛出异常。</li>
<li>其他的参考第五章第二节的LSP</li>
</ul>
<p><strong>利用<code>throws</code>进行声明</strong></p>
<ul>
<li>使用<code>throws</code>声明异常：此时需要告知你的client需要处理这些异常，如果client没有handler来处理被抛出的checked exception，程序就终止执行。</li>
<li>程序员必须在方法的spec中明确写清本方法会抛出的所有checked exception，以便于调用该方法的client加以处理</li>
<li>在使用throws时，方法要在定义和spec中明确声明所抛出的全部checked exception，没有抛出checked异常，编译出错，Unchecked异常和Error可以不用处理。</li>
</ul>
<p><strong>利用<code>throw</code>抛出一个异常</strong></p>
<ul>
<li>步骤：<ul>
<li>找到一个能表达错误的<code>Exception</code>类&#x2F;或者构造一个新的<code>Exception</code>类</li>
<li>构造<code>Exception</code>类的实例，将错误信息写入</li>
<li>抛出它</li>
</ul>
</li>
<li>一旦抛出异常，方法不会再将控制权返回给调用它的client，因此也无需考虑返回错误代码</li>
</ul>
<p> <strong><code>try-catch</code>语句</strong></p>
<ul>
<li>使用<code>try</code>和<code>catch</code>关键字可以捕获异常。<code>try</code>&#x2F;<code>catch</code>代码块放在异常可能发生的地方。</li>
<li><code>try</code>&#x2F;<code>catch</code>代码块中的代码称为保护代码，</li>
<li><code>catch</code>语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，<code>try</code>后面的<code>catch</code>块就会被检查。</li>
<li>如果发生的异常包含在<code>catch</code>块中，异常会被传递到该<code>catch</code>块，这和传递一个参数到方法是一样。</li>
</ul>
<p><strong><code>finally</code>语句</strong></p>
<ul>
<li>场景：当异常抛出时，方法中正常执行的代码被终止；但如果异常发生前曾申请过某些资源，那么异常发生后这些资源要被恰当的清理，所以需要用<code>finally</code>语句。</li>
<li><code>finally</code> 关键字用来创建在 try 代码块后面执行的代码块。</li>
<li>无论是否发生异常，<code>finally</code> 代码块中的代码总会被执行。</li>
<li>在 <code>finally</code> 代码块中，可以运行清理类型等收尾善后性质的语句。</li>
<li><code>finally</code> 代码块出现在<code>catch</code>代码块最后：</li>
<li>注意下面事项：<ul>
<li><code>catch</code>不能独立于<code>try</code>存在。</li>
<li>在<code>try</code>&#x2F;<code>catch</code>后面添加 <code>finally</code> 块并非强制性要求的。</li>
<li><code>try</code>代码后不能既没<code>catch</code>块也没 <code>finally</code>块。</li>
<li><code>try, catch, finally</code>块之间不能添加任何代码。</li>
</ul>
</li>
</ul>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a><em>自定义异常</em></h3><ul>
<li>如果JDK提供的exception类无法充分描述你的程序发生的错误，可以创建自己的异常类。<ul>
<li>如果希望写一个检查性异常类，则需要继承<code>Exception</code>类。</li>
<li>如果你想写一个运行时异常类，那么需要继承<code>RuntimeException</code>类。</li>
</ul>
</li>
</ul>
<h2 id="第三节-断言和防御性编程"><a href="#第三节-断言和防御性编程" class="headerlink" title="第三节 断言和防御性编程"></a>第三节 断言和防御性编程</h2><h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a><em>断言</em></h3><p><strong>什么是断言</strong></p>
<ul>
<li><strong>作用：</strong>允许程序在运行时检查自己，测试有关程序逻辑的假设，如前置条件、后置条件、内部不变量、表示不变量、控制流不变量等</li>
<li><strong>目的</strong>： 为了在开发阶段调试程序、尽快避免错误</li>
<li>使用阶段：<ul>
<li>断言主要用于开发阶段，避免引入和帮助发现bug</li>
<li>实际运行阶段， 不再使用断言</li>
<li>软件发布阶段，禁用断言避免影响性能。</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>输入参数或输出参数的取值处于预期范围</li>
<li>子程序开始执行（结束）时，文件或流处于打开（关闭）状态</li>
<li>子程序开始执行（结束）时，文件或流的读写位置处于开头（结尾）</li>
<li>文件或流已打开</li>
<li>输入变量的值没有被子程序修改</li>
<li>指针非空</li>
<li>传入子程序的数组至少能容纳X个元素</li>
<li>表已初始化，存储着真实的数据</li>
<li>子程序开始（结束）时，容器空（满）</li>
<li>一个高度优化过的子程序与一个缓慢的子程序，结果一致</li>
<li>断言只在开发阶段被编译到目标代码中，而在生成代码时不编译进去。使用断言的指导建议：</li>
<li>用错误处理代码来处理预期会发生的状况，断言不行</li>
<li>避免把需要执行的代码放入断言中（如果未编译断言呢？）</li>
<li>用断言来注解并验证前条件和后条件</li>
<li>对于高健壮性的代码，应该先用断言，再处理错误</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>编译时加入-ea(enable assertion)选项运行断言，-da(disable assertion)关闭断言</li>
<li>条件语句或开关没有涵盖所有可能的情况，最好使用断言来阻止非法事件</li>
<li>可以在预计正常情况下程序不会到达的地方放置断言：<code>assert false</code></li>
<li>断言有代价，需慎用，一般用于验证正确性，处理绝不应该发生的情况</li>
<li>不能作为公共方法的检查，也不能有边界效应</li>
</ul>
<p> <strong>断言和异常的对比</strong></p>
<ul>
<li>用异常处理技术来处理你“希望发生”的不正常情况</li>
<li>用断言来处理“不希望发生”的情况；断言的方式处理一定是发生了错误</li>
<li>不要把业务逻辑（执行代码）放到断言里面去处理</li>
<li>参数检查通常是方法发布的规范（或契约）的一部分，无论断言是启用还是禁用，都必须遵守这些规范。<ul>
<li>如果参数来自于外部（不受自己控制），使用异常处理</li>
<li>如果来自于自己所写的其他代码，可以使用断言来帮助发现错误（例如postcondition就需要）</li>
</ul>
</li>
</ul>
<h2 id="第四节-调试"><a href="#第四节-调试" class="headerlink" title="第四节 调试"></a>第四节 调试</h2><h3 id="什么是bug"><a href="#什么是bug" class="headerlink" title="什么是bug"></a><em>什么是bug</em></h3><ul>
<li>bug即程序中的错误，导致程序以非预期或未预料到的方式执行。</li>
<li>一个包含大量bug和&#x2F;或严重干扰其功能的bug的程序被称为buggy。</li>
<li>报告程序中的bug通常被称为bug报告、故障报告、问题报告、故障报告、缺陷报告等</li>
</ul>
<p><strong>bug产生的原因</strong></p>
<ul>
<li>代码错误</li>
<li>未完成的要求或不够详细</li>
<li>误解用户需求</li>
<li>设计文档中的逻辑错误</li>
<li>缺乏文件</li>
<li>没有足够的测试</li>
</ul>
<p><strong>bug的常见类型</strong></p>
<ul>
<li>数学bug：例如 零除法，算术溢出</li>
<li>逻辑bug：例如 无线循环和无限递归</li>
<li>源头bug：例如 使用了为被定义的变量、资源泄漏，其中有限的系统资源如内存或文件句柄通过重复分配耗尽而不释放。缓冲区溢出，其中程序试图将数据存储在分配存储的末尾。</li>
<li>团队工程bug：例如 评论过时或者评论错误、文件与实际产品的区别</li>
</ul>
<h3 id="调试的基本过程"><a href="#调试的基本过程" class="headerlink" title="调试的基本过程"></a><em>调试的基本过程</em></h3><ul>
<li>Debug是测试的后续步骤：测试发现问题，debug消除问题；当防御式编程和测试都无法挡住bug时，我们就必须进行debug了；</li>
<li>Debug的目的：寻求错误的根源并消除它；（Debug占用了大量的时间）</li>
</ul>
<p><strong>调试的过程</strong></p>
<ul>
<li><strong>常用方法：假设-检验</strong></li>
<li>重现（Reproduce）$\to$诊断（Diagnose&#x2F;Locating）$\to$修复（Fix）$\to$反思（Reflect）</li>
<li>重现（Reproduce）：寻找一个可靠、方便得在线需求问题的方法。<ul>
<li>从最小的测试用例开始复现错误（保持复现bug的前提下降低输入规模）</li>
<li>消除因版本、环境、配置等不同引起的差异（通过构建软件实现），确定bug出现的环境（通过程序模拟硬件平台的细节，实现不同的操作系统环境）</li>
<li>利用逆向设计推断导致错误的输入</li>
<li>若无法重现，则无法观察以证明分析和修补的正确性</li>
</ul>
</li>
<li>诊断（Diagnose&#x2F;Locating）：构建假设，并通过执行实验来测试它们，直到您确信已识别错误的根本原因。<ul>
<li>从假设开始，构造实验，证明它是对的或者错的</li>
<li>从不符合理论的观察结果开始，修正理论</li>
<li>查看导致错误的测试输入，以及错误的结果，失败的断言以及由此导致的堆栈跟踪</li>
<li>提出一个与所有数据一致的假设，说明错误发生的位置或错误发生的位置，设计实验测试假设</li>
<li>收集实验数据，减少错误可能出现的范围，做出新的假设</li>
<li>设计不同的实验：检查内部状态、修改运行方式、改变本身逻辑 </li>
<li>每次只做一个修改、做好记录、不忽略细节、运行不同的测试用例、设置断点、用可实现相同功能并且被证实无问题的组件替代当前组件</li>
</ul>
</li>
<li>修复（Fix）：设计和实施解决问题的变化，避免引入回归，并保持或提高软件的整体质量。<ul>
<li>确保从干净的源代码树开始</li>
<li>运行现有的测试，并证明它们通过</li>
<li>添加一个或多个新测试，或修复现有测试，以演示错误</li>
<li>修复错误、发现可改进之处</li>
<li>证明你的修复工作正常且没有引入回归（以前通过的测试现在失败）</li>
<li>如果引入回归，通过回顾以前的版本来找出确切的变化</li>
</ul>
</li>
<li>反思（Reflect）：思考需求、设计、测试、结构（库、编译器等）</li>
</ul>
<h3 id="调试的技术和工具"><a href="#调试的技术和工具" class="headerlink" title="调试的技术和工具"></a><em>调试的技术和工具</em></h3><p><strong>调试技术</strong></p>
<ul>
<li>暴力调试（Brute Force Attack）<ul>
<li>蛮力方法可以分为至少三类：<ul>
<li>看内存导出文件</li>
<li>根据“在整个程序中分散打印语句”的常见建议进行调试。</li>
<li>自动化调试工具</li>
</ul>
</li>
</ul>
</li>
<li>递归调试（Induction）</li>
<li>演绎调试（Decution）</li>
<li>回溯调试（Backtracking）</li>
<li>测试调试（Testing）</li>
</ul>
<p><strong>调试工具</strong></p>
<ul>
<li>语法和逻辑检查（本课程未涵盖）</li>
<li>源代码比较器(Source-code comparator)</li>
<li>内存堆转储（Memory heap dump）</li>
<li>打印调试&#x2F;日志记录(Print debugging &#x2F; logging)</li>
<li>堆栈跟踪(Stack trace)</li>
<li>编译器警告消息(Compiler Warning Messages)</li>
<li>调试器(Debugger)</li>
<li>执行分析器(Execution Profiler)</li>
<li>测试框架(Test Framework）</li>
</ul>
<h2 id="第五节-测试与测试优先编程"><a href="#第五节-测试与测试优先编程" class="headerlink" title="第五节 测试与测试优先编程"></a>第五节 测试与测试优先编程</h2><h3 id="测试和测试优先编程"><a href="#测试和测试优先编程" class="headerlink" title="测试和测试优先编程"></a><em>测试和测试优先编程</em></h3><p><strong>测试的定义</strong></p>
<ul>
<li>测试：发现程序中的错误 提高程序正确性的信心</li>
<li>程序正确确认的基本方法:<ul>
<li>形式化推理</li>
<li>代码评审</li>
<li>测试</li>
</ul>
</li>
<li>测试是提高软件质量的重要手段<ul>
<li>确认是否可达到可用的级别</li>
<li>关注系统某一侧面的质量特性</li>
<li>是否满足需求</li>
<li>是否正确响应所有需求</li>
<li>性能是否可接受</li>
<li>是否可用</li>
<li>可否正确部署安装</li>
<li>是否达到期望</li>
</ul>
</li>
</ul>
<p> <strong>测试的分类</strong></p>
<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>系统测试</li>
<li>回归测试</li>
<li>验收测试</li>
</ul>
<h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a><em>黑盒测试</em></h3><ul>
<li><p>白盒测试:对程序内部代码结构的测试 只关注代码内部的问题</p>
</li>
<li><p>黑盒测试:对程序外部表现出来的行为的测试 采用两个方法</p>
<ul>
<li><p>等价划分</p>
<p>  将程序可能的输入进行分类 划分为不同集合 包括不合法数据</p>
<ul>
<li>等价类划分可有两种不同的情况：有效等价类和无效等价类。</li>
<li>若一组对象自反、对称、传递，则为等价类</li>
<li>可产生相似结果的输入集合中的一个可代替整个集合</li>
<li>同理，对输出也可以划分等价类</li>
<li>极端：每个分区只有一个测试用例，覆盖所有分区</li>
</ul>
</li>
<li><p>边界值分析方法</p>
<p>  边界值分析法是对输入输出的边界值进行测试一种黑盒测试方法，是对等价类分析法的补充。</p>
<ul>
<li>错误通常隐藏在边界中，如一位偏移、边界值需单独处理等</li>
<li>找到有效数据和无效数据的分界点（最大值、最小值），对该分界点以及两边的值分别单独进行测试。</li>
<li>等价类划分法可以挑选等价类范围内任意一个数据作为代表，而边界值分析法要求每个边界值都要作为测试条件。</li>
</ul>
</li>
</ul>
</li>
<li><p>测试困难</p>
<ul>
<li>软件行为在离散输入空间中差异巨大 <ul>
<li>大多数正确，少数错误</li>
<li>bug出现不遵循特定概率分布</li>
</ul>
</li>
<li>无统计规律可循</li>
</ul>
</li>
</ul>
<h3 id="代码覆盖度"><a href="#代码覆盖度" class="headerlink" title="代码覆盖度"></a><em>代码覆盖度</em></h3><ul>
<li>定义：已有的测试用例有多大程度覆盖了被测程序；</li>
<li>代码覆盖度越低，测试越不充分；但要做到很高的代码覆盖度，需要更多的测试用例，测试代价高；</li>
<li>代码覆盖率高的程序在测试期间执行了更多的源代码，与低代码覆盖率的程序相比，包含未检测到的软件错误的可能性较低</li>
<li>基本覆盖标准：函数覆盖；语句覆盖、分支覆盖、条件覆盖、路径覆盖</li>
<li>测试效果：路径 &gt; 分支 &gt; 语句</li>
<li>测试难度：路径 &gt; 分支 &gt; 语句</li>
</ul>
<h3 id="以注释的形式撰写测试策略"><a href="#以注释的形式撰写测试策略" class="headerlink" title="以注释的形式撰写测试策略"></a><em>以注释的形式撰写测试策略</em></h3><ul>
<li>“测试策略”通俗来讲就是6个字：“测什么”和“怎么测”。测试策略非常重要，需要在程序中显性记录下来。</li>
<li>目的：在代码评审过程中，其他人能够理解你的测试，并评判测试是否充分</li>
<li>在测试类的顶端写策略</li>
<li><img src="https://i.imgur.com/5tn5eZi.png"></li>
<li>在每个测试方法前说明测试用例是如何选择的</li>
<li><img src="https://i.imgur.com/iq0sHgU.png"></li>
</ul>
<h3 id="JUnit-测试用例写法"><a href="#JUnit-测试用例写法" class="headerlink" title="JUnit 测试用例写法"></a><em>JUnit 测试用例写法</em></h3><ul>
<li>JUnit单元测试是依据 注释中<code>@Test</code>之前的方法编写的</li>
<li>JUnit测试经常调用多次方法，使用<code>assertEqual || assertTrue || assertFalse</code>来检查结果</li>
<li><code>@Before</code>：准备测试、完成初始化，每个测试方法前执行一次</li>
<li><code>@After</code>：清理现场，每个测试方法后执行一次</li>
<li><code>@Test</code>：表明测试方法，内含assert语句<ul>
<li>第一个参数是预期结果、第二个参数实施及结果；</li>
<li>如果断言失败，该测试方法直接返回，JUnit记录该测试的失败；</li>
<li>一个测试方法失败，其他测试方法仍运行</li>
<li><code>@Test(expected = *.class)</code>：对错误的测试，expected的属性值是一个异常</li>
<li><code>@Test(timeout = xxx)</code>：测试方法在制定的时间之内没有运行完则失败</li>
</ul>
</li>
<li><code>@ignore</code>：忽略测试方法</li>
<li><em><strong>examples</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evaluate</span><span class="params">(String expression)</span> &#123;</span><br><span class="line">    	<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String summand: expression.split(<span class="string">&quot;\\+&quot;</span>))</span><br><span class="line">            sum += Integer.valueOf(summand);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculatorTest</span> &#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evaluatesExpression</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Calculator</span> <span class="variable">calculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Calculator</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> calculator.evaluate(<span class="string">&quot;1+2+3&quot;</span>);</span><br><span class="line">        assertEquals(<span class="number">6</span>, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180619224136881-874452125.png" alt="img"></p>
<hr>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gaotf</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
