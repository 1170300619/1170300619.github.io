<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="热爱技术，笔耕不辍">
<meta property="og:type" content="website">
<meta property="og:title" content="漱石斋笔谈">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="漱石斋笔谈">
<meta property="og:description" content="热爱技术，笔耕不辍">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="gaotf">
<meta property="article:tag" content="PostgreSQL">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>漱石斋笔谈</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">漱石斋笔谈</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">gaotf 的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gaotf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">gaotf</p>
  <div class="site-description" itemprop="description">热爱技术，笔耕不辍</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/1170300619" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1170300619" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3469205806@qq.com" title="E-Mail → 3469205806@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/13/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0shared-ptr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/13/%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0shared-ptr/" class="post-title-link" itemprop="url">从零实现shared_ptr</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-13 15:38:42" itemprop="dateCreated datePublished" datetime="2022-08-13T15:38:42+08:00">2022-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-20 17:08:28" itemprop="dateModified" datetime="2022-10-20T17:08:28+08:00">2022-10-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="本文结构"><a href="#本文结构" class="headerlink" title="本文结构"></a>本文结构</h1><ul>
<li>基础构造函数</li>
<li>复制语义</li>
<li>移动语义</li>
<li>一些工具函数</li>
<li>析构函数</li>
</ul>
<h2 id="1-基础构造函数"><a href="#1-基础构造函数" class="headerlink" title="1.基础构造函数"></a>1.基础构造函数</h2><p>面试中如果要求实现一个shared_ptr，我们可以从最简单的结构写起：</p>
<pre><code>template&lt;class T&gt;
class my_shared_ptr&#123;
private:
    T* m_ptr = nullptr;
    unsigned int * m_ref_count = nullptr;
    //默认构造函数
public:   
    my_shared_ptr(): m_ptr(nullptr), m_ref_count(nullptr)&#123; &#125;
    my_shared_ptr(T* ptr): m_ptr(ptr), m_ref_count(new unsigned int(1))&#123; &#125;
&#125;;
</code></pre>
<p><strong>1.为什么m_ref_count这个引用计数要用指针来表示？</strong><br>因为shared_ptr会被复制来复制去的，对于同一个被引用的对象，其引用计数需要同时更新和共享，使用指针的话就会比较方便。<br><strong>2.shared_ptr的引用计数是线程安全的吗？</strong><br>在其源代码中，是线程安全的，因为最后使用了_Atomic_word类型来计数，表明其是一个原子操作，保证了线程安全。<br><strong>3.shared_ptr储存的指针是线程安全的吗？</strong><br>并不是，源代码中指针类型是element_type*，其为用户使用时自定义的指针类型，没有保证原子操作。</p>
<h2 id="2-拷贝构造部分"><a href="#2-拷贝构造部分" class="headerlink" title="2.拷贝构造部分"></a>2.拷贝构造部分</h2><pre><code>//拷贝构造函数
my_shared_ptr(const my_shared_ptr &amp; obj)&#123;
    m_ptr = obj.m_ptr;
    m_ref_count = obj.m_ref_count;
    if(m_ref_count != nullptr)&#123;
        (*m_ref_count)++;
    &#125;
&#125;

//拷贝重载=运算符
my_shared_ptr&amp; operator=(const my_shared_ptr &amp; obj)&#123;
    if(obj.m_ptr == m_ptr)&#123;
        return *this;
    &#125;
    
    //先处理原有的指针和引用计数
    if(m_ref_count != nullptr)&#123;
        (*m_ref_count)--;
        if(*m_ref_count == 0)&#123;
            delete m_ptr;
            delete m_ref_count;
        &#125;
    &#125;
    
    m_ptr = obj.m_ptr;
    m_ref_count = obj.m_ref_count;
    
    if(m_ref_count != nullptr)&#123;
        (*m_ref_count)++;
    &#125;
    return *this;
&#125;
</code></pre>
<p><strong>1.为什么拷贝构造的参数是const my_shared_ptr&amp;，而不是const my_shared_ptr</strong><br>因为我们写的是拷贝构造函数，如果参数为后者，相当于要调用一次拷贝构造，就会无限递归下去。<br><strong>2.为什么重载&#x3D;运算符的返回值是my_shared_ptr&amp;，能不能返回void</strong><br>理论上是可以的，但是为了支持连等a &#x3D; b &#x3D; c，还是要返回my_shared_ptr&amp;</p>
<h2 id="3-移动构造部分"><a href="#3-移动构造部分" class="headerlink" title="3.移动构造部分"></a>3.移动构造部分</h2><pre><code>//移动语义
//移动构造
my_shared_ptr(my_shared_ptr &amp;&amp; dying_obj): m_ptr(nullptr), m_ref_count(nullptr)&#123;
    //初始化后交换指针和引用计数，相当于清除了dying_obj的内容
    dying_obj.swap(*this);
&#125;
//移动赋值
my_shared_ptr &amp; operator=(my_shared_ptr &amp;&amp; dying_obj)&#123;

    //my_shared_ptr(std::move(dying_obj))用移动构造函数创建出一个新的shared_ptr(此时原shared_ptr的内容被清除了)
    //再和this交换指针和引用计数
    //因为this的内容被交换到了当前的临时创建的my_shared_ptr里，原this指向的引用计数-1

    my_shared_ptr(std::move(dying_obj)).swap(*this);
    return *this;
&#125;

void swap(my_shared_ptr &amp; other)&#123;
    std::swap(m_ptr, other.m_ptr);
    std::swap(m_ref_count, other.m_ref_count);
&#125;
</code></pre>
<h2 id="4-一些工具函数"><a href="#4-一些工具函数" class="headerlink" title="4.一些工具函数"></a>4.一些工具函数</h2><p>指针相关的运算符重载和获取引用计数的函数</p>
<pre><code>//重载指针运算符
T* operator-&gt;() const&#123;
    return m_ptr;
&#125;

//重载解引用运算符
T* operator*() const&#123;
    return *m_ptr;
&#125;

T* get() const&#123;
    return m_ptr;
&#125;

unsigned int use_count() const&#123;
    return *m_ref_count;
&#125;
</code></pre>
<h2 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5.析构函数"></a>5.析构函数</h2><pre><code>//析构函数
~my_shared_ptr()&#123;
    if(m_ref_count == nullptr)&#123;
        return;
    &#125;
    (*m_ref_count)--;
    if(*m_ref_count &gt; 0)&#123;
        return;
    &#125;
    
    if(m_ptr != nullptr)&#123;
        delete m_ptr;
    &#125;
    delete m_ref_count;
&#125;
</code></pre>
<h2 id="6-make-shared函数"><a href="#6-make-shared函数" class="headerlink" title="6.make_shared函数"></a>6.make_shared函数</h2><p>1.为什么会推荐使用std::make_shared，而不是直接构造std::shared_ptr<br>如果直接构造shared_ptr，那么是先分配一块内存给实例化对象，再分配一块内存给引用计数模块（引用计数，删除器等），但是std::make_shared可以一次性分配一整块内存给引用计数模块和实例化对象，这样有两部分优点：</p>
<ul>
<li><p>优点一：异常安全<br>在C++17之前，在某种情况下构造一个std::shared_ptr不一定是安全的，看下面的案例：</p>
<p>  void F(const std::shared_ptr<Lhs> &amp;lhs, const std::shared_ptr<Rhs> &amp;rhs) { &#x2F;* … *&#x2F; }</p>
<p>  F(std::shared_ptr<Lhs>(new Lhs(“foo”)),<br>  std::shared_ptr<Rhs>(new Rhs(“bar”)));</p>
</li>
</ul>
<p>一个可能的执行顺序是</p>
<pre><code>1.new Lhs(&quot;foo&quot;)
2.new Rhs(&quot;bar&quot;)
3.std::shared_ptr&lt;Lhs&gt;
4.std::shared_ptr&lt;Rhs&gt;
</code></pre>
<p>假设在第2步出现了一个异常（比如内存耗尽或者构造函数的异常），那么第一步分配的内存地址就没有保存在任何地方，所以这块内存永远回收不了，导致内存泄露。使用std::make_shared就可以避免这种问题。</p>
<ul>
<li>优点二：减少开销<br>一次性分配一整块内存来使用可以减少碎片化内存，减少使用临时变量，也减少了和内核的交流。</li>
</ul>
<p>2.有没有什么情况下没法使用std::make_shared</p>
<ul>
<li><p>有时候我们把构造函数定义为私有，就可以强制用户使用工厂模式A::Create创建shared_ptr，这样可以避免用户直接创建实例或者使用生指针进而管理不善导致内存泄漏。</p>
<pre><code>  #include &lt;iostream&gt;
  #include &lt;memory&gt;

  class A
  &#123;
      public:
      static std::shared_ptr&lt;A&gt; Create()&#123; return std::shared_ptr&lt;A&gt;(new A(100)); &#125;

      int GetId()&#123; return m_i; &#125;

      private:
      int m_i;
      A(int i): m_i(i)&#123;std::cout&lt;&lt;&quot;private ctor called&quot;&lt;&lt;std::endl;&#125;;
  &#125;;

  int main()
  &#123;
      std::shared_ptr&lt;A&gt; s_ptr = A::Create();
      std::cout&lt;&lt;s_ptr-&gt;GetId()&lt;&lt;std::endl;

      //A * p = new A(300);  //make_shared无法访问私有构造函数
      return 0;
  &#125;
</code></pre>
</li>
</ul>
<p>在这种情况下，std::make_shared进行placement new操作的时候，会直接调用构造函数，但因为我们的构造函数都是私有的，这时候就会报错。而我们在工厂模式里直接new出来的实例是通过成员函数new操作符operator new访问的私有构造函数，所以没有问题。</p>
<ul>
<li>还有一种情况，make_shared 只分配一次内存, 这看起来很好. 减少了内存分配的开销. 问题来了, weak_ptr 会保持控制块(强引用, 以及弱引用的信息)的生命周期, 而因此连带着保持了对象分配的内存, 只有最后一个 weak_ptr 离开作用域时, 内存才会被释放. 原本强引用减为 0 时就可以释放的内存, 现在变为了强引用, 弱引用都减为 0 时才能释放, 意外的延迟了内存释放的时间. 这对于内存要求高的场景来说, 是一个需要注意的问题。</li>
</ul>
<h1 id="稳定排序和不稳定排序"><a href="#稳定排序和不稳定排序" class="headerlink" title="稳定排序和不稳定排序"></a>稳定排序和不稳定排序</h1>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">操作系统知识笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-27 23:15:17" itemprop="dateCreated datePublished" datetime="2022-07-27T23:15:17+08:00">2022-07-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-16 23:34:28" itemprop="dateModified" datetime="2022-11-16T23:34:28+08:00">2022-11-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.Linux 中一个进程的虚拟内存分布长什么样？内核空间+用户空间（6 种不同的内存段）<br>代码段：存放程序代码，运行前就已经确定（编译时确定）<br>常量区：存放const定义的全局变量，define定义的常量和字符串常量等<br>数据段：存放已经初始化的全局变量<br>bss段：存放没有初始化的全局变量或默认为0的全局变量，执行期间会将这一段的内容全部设为0<br>栈：存放函数参数和局部变量，由系统进行申请和释放，空间较小，先进先出<br>堆：存放动态分配的内存，由用户自己申请和释放（比如malloc和free）</p>
<p>2.为什么要使用虚拟内存<br>如果没有虚拟地址，cpu访问的都是真实的物理地址，那么会产生：程序直接访问真实内存，没有顺序没有规则，很容易导致错误的产生，并且无法同时运行多个程序。<br>有了虚拟地址以后：</p>
<ul>
<li>程序可以用一系列相邻的虚拟地址访问实际物理内存中不相邻的大内存缓冲区</li>
<li>程序可以使用虚拟地址访问大于可用物理地址的内存缓冲区</li>
<li>不同进程之间的虚拟地址分隔开，不同进程不会操作同一个物理地址，防止程序崩溃</li>
</ul>
<h1 id="中断问题"><a href="#中断问题" class="headerlink" title="中断问题"></a>中断问题</h1><p>Linux将中断问题分为上下两部分</p>
<ul>
<li>上半部分对应硬件，硬中断，用来快速处理中断，把网卡的数据读到内存中，更新一下硬件寄存器的状态</li>
<li>下半部分对应内核，软中断，通常耗时比较长，例如从内存中读取数据，根据协议栈对网络数据进行逐层解析和处理，最终交给应用程序</li>
</ul>
<h1 id="cpu写入问题"><a href="#cpu写入问题" class="headerlink" title="cpu写入问题"></a>cpu写入问题</h1><ol>
<li>写直达：同时把数据写入Cache和内存</li>
</ol>
<ul>
<li>如果Cache中有该数据，先将数据更新，再写入到内存中</li>
<li>如果Cache中没有该数据，则直接写入到内存中</li>
</ul>
<ol start="2">
<li>写回：当写数据时，新的数据被写入到Cache中，只有当修改过的Cache Block被替换时才写入到内存中<br>这种情况下，只有当缓存不命中，且对应的Cache Block是脏的情况下，才会将该脏的数据写入内存中，然后将要写入的数据，先从内存读入到Cache Block中，然后再把当前要写入的数据写入到Cache Block中，并标记为脏的</li>
</ol>
<h1 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h1><p>如果有多个CPU核心操作缓存数据，按照写回原则，则会出错，因为当没有发生缓存不命中且对应数据为脏时，缓存中的数据不会写回到内存中，此时其他核心从内存中读取的数据就是错的。为了解决，需要写传播和事务的串行化</p>
<ul>
<li>写传播：当某个CPU核心更新了Cache中的数据，需要广播到其他核心中，使用总线嗅探技术</li>
<li>事务的串行化：基于总线嗅探技术实现的MESI方法，解决了上述两个问题</li>
</ul>
<h1 id="malloc申请内存的方式"><a href="#malloc申请内存的方式" class="headerlink" title="malloc申请内存的方式"></a>malloc申请内存的方式</h1><p>1.brk()函数从堆申请内存，具体为将指针从堆的低地址向高地址移动，小于128KB<br>2.mmap()函数从文件映射区分配内存，大于128KB<br>malloc分配的是虚拟地址，如果该虚拟地址没有被访问，则不会映射到真实物理地址，如果操作系统访问虚拟地址，通过页表查询发现虚拟地址对应的页没有在物理内存中，就会发生缺页中断，然后才会建立虚拟地址和物理内存之间的映射<br>不能都使用mmap函数，因为其会发生运行态的切换，而且mmap申请的内存总是会被释放掉，从而每次访问都会缺页中断，导致CPU消耗过大<br>也不能都使用brk函数，因为其堆指针连续向上增长，会产生内存碎片问题，导致内存泄露</p>
<h1 id="free释放内存的问题"><a href="#free释放内存的问题" class="headerlink" title="free释放内存的问题"></a>free释放内存的问题</h1><p>1.如果是malloc使用brk()函数申请的内存，则不会释放掉<br>2.如果是mmap()函数申请的内存，则会释放掉<br>其中malloc返回给用户的数据会有一个16字节的信息头，其中保存了该内存块的大小，这样free释放的时候就知道要释放多大的内存块了</p>
<h1 id="内存分配的过程"><a href="#内存分配的过程" class="headerlink" title="内存分配的过程"></a>内存分配的过程</h1><p>应用程序通过 malloc 函数申请内存的时候，实际上申请的是虚拟内存，此时并不会分配物理内存。当应用程序读写了这块虚拟内存，CPU 就会去访问这个虚拟内存， 这时会发现这个虚拟内存没有映射到物理内存，CPU 就会产生缺页中断，进程会从用户态切换到内核态，并将缺页中断交给内核的缺页中断函数处理。缺页中断处理函数会看是否有空闲的物理内存，如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系。<br>如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，回收的方式主要是两种：直接内存回收和后台内存回收。</p>
<ul>
<li>后台内存回收（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程异步的，不会阻塞进程的执行。</li>
<li>直接内存回收（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是同步的，会阻塞进程的执行。</li>
<li>如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了 ——触发 OOM （Out of Memory）机制。OOM Killer 机制会根据算法选择一个占用物理内存较高的进程，然后将其杀死，以便释放内存资源，如果物理内存依然不足，OOM Killer 会继续杀死占用物理内存较高的进程，直到释放足够的内存位置。</li>
</ul>
<h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><p>1.先来先服务<br>2.最短作业：优先选择运行时间最短的<br>3.高响应比优先调度算法：等待时间 + 要求服务时间&#x2F; 要求服务时间（无法实现）<br>4.时间片轮转算法：每个进程被分配一个时间片<br>5.最高优先级调度算法：静态和动态优先级<br>6.多级反馈队列：多个队列，每个队列优先级从高到低，新来的任务先加入第一级的队尾，按照先来先服务运行，如果没有运行完则加入第二级的队尾，如果来了一个优先级高的，则先去运行优先级高的任务队列，此时将原任务加入当前队列的队尾</p>
<h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p>1.匿名管道：通过fork父进程的文件描述符来建立连接，先进先出<br>2.命名管道：在不相关的进程间也能进行通信，其创建了一个类型为管道的设备文件<br>3.消息队列：在内核中，不适合比较大的文件传输，同时会带来用户态与内核态之间的数据拷贝开销<br>4.共享内存：一个虚拟内存，映射到同一块真实物理内存<br>5.信号量：P操作-1，如果小于0，则阻塞 V操作：如果小于等于0则有进程阻塞，唤醒它，如果大于0，则没有进程阻塞</p>
<ul>
<li>1：互斥信号量</li>
<li>0：同步信号量：需要先执行的只需要V操作，需要后执行的只需要P操作<br>6.信号：异常状态下的通信<br>7.Socket：跨网络和不同的主机间进程通信</li>
</ul>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>1.死锁的四个条件</p>
<ul>
<li>互斥</li>
<li>忙等待</li>
<li>不可剥夺</li>
<li>环路等待</li>
</ul>
<p>2.如何避免</p>
<ul>
<li>资源有序分配法来打破环路等待：如果两个进程需要的资源相同，那么就按照同样的顺序去获取资源</li>
</ul>
<h1 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h1><p>1.互斥锁：获取不到资源时，将CPU释放，去执行其他进程<br>2.自旋锁：获取不到资源时，线程会忙等待，直到拿到锁<br>3.读写锁：当写锁没有被线程持有，那么多个线程可以持有读锁，如果线程持有了读锁，那么其他线程的读锁和写锁都会被阻塞</p>
<ul>
<li>读优先锁：写锁被阻塞，且后来的读锁也会先与写锁被执行</li>
<li>写优先锁：读锁会阻塞写锁，但是后面的线程无法再持有读锁，那么写线程就会接着被执行</li>
<li>比较公平的方法：把所有锁加入一个队列，先来先执行<br>4.以上都是悲观锁，还有乐观锁：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。</li>
</ul>
<h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p>1.先进先出：选择在内存中保留时间最长的页面<br>2.最近最久未使用：LRU<br>3.最不常用：选择访问次数最少的<br>4.时钟页面：所有页面保存在环形列表中，表针指向最老的页面，如果发生缺页就检查访问位置：如果是0则淘汰，并插入当前页面，如果是1，则置为0，表针向前一个走</p>
<h1 id="如果系统中具有快表后，那么地址的转换过程变成什么样了？"><a href="#如果系统中具有快表后，那么地址的转换过程变成什么样了？" class="headerlink" title="如果系统中具有快表后，那么地址的转换过程变成什么样了？"></a>如果系统中具有快表后，那么地址的转换过程变成什么样了？</h1><ul>
<li>CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。</li>
<li>如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可。</li>
<li>如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此,若快表未命中，则访问某个逻辑地址需要两次访存(注意:在找到页表项后，应同时将其存入快表,以便后面可能的再次访问。但若快表已满，则必须按照-定的算法对旧的页表项进行替换)</li>
</ul>
<h1 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h1><p>1.首次适应算法：空闲分区以地址递增的次序排列，每次都从低地址开始查找空闲分区链或者空闲分区表，找到第一个能满足大小的空闲分区。<br>2.最佳适应算法：空闲分区按容量递增次序链接，每次分配内存时按顺序查找空闲分区表，找到大小能满足要求的第一个空闲分区。<br>3.最坏适应算法：空闲分区按容量递减次序链接，每次分配内存时按顺序查找空闲分区表，找到大小能满足要求的第一个空闲分区。<br>4.邻近适应算法：空闲分区以地址递增的顺序排列（可排成一个循环链表），每次分配内存时从上次查找结束的位置开始查找空闲分区链，找到大小能满足要求的第一个空闲分区。</p>
<h1 id="静态链接和动态链接"><a href="#静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接</h1><p>1.静态链接：函数和数据被编译进一个二进制文件，链接时，链接器从库中复制这些函数和数据，并把他们和应用程序的其他模块组合起来创建最终的可执行文件。</p>
<ul>
<li>空间浪费：每个可执行文件中对所有需要的目标文件都要有一个副本</li>
<li>更新困难：每当库函数代码发生变化，就需要重新编译链接形成可执行程序</li>
<li>优点：运行速度快<br>2.动态链接：把程序按照模块拆分成各个相对独立的部分，在程序运行时才将他们链接到一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。</li>
<li>共享库：即使每个程序都依赖一个库，但是该库不会像静态链接那样在内存中存在多个副本，而是多个程序在执行时共享同一个副本。</li>
<li>更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再链接一遍。</li>
<li>性能损耗：每次程序运行都需要进行链接，性能会有一定损失。</li>
</ul>
<h1 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h1><p>问题描述：允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<pre><code>typedef int semaphore;
semaphore count_mutex = 1;
semaphore data_mutex = 1;
int count = 0;

void reader() &#123;
    while(TRUE) &#123;
        down(&amp;count_mutex);
        count++;
        if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问
        up(&amp;count_mutex);

        read();  

        down(&amp;count_mutex);
        count--;
        if(count == 0) up(&amp;data_mutex);//最后一个读者要对数据进行解锁，防止写进程无法访问
        up(&amp;count_mutex);
    &#125;
&#125;

void writer() &#123;
    while(TRUE) &#123;
        down(&amp;data_mutex);

        write();

        up(&amp;data_mutex);
    &#125;
&#125;
</code></pre>
<h1 id="中断和异常的区别"><a href="#中断和异常的区别" class="headerlink" title="中断和异常的区别"></a>中断和异常的区别</h1><p>1.中断是硬件产生的，通过中断控制器发给CPU，CPU判断其来自哪个硬件设备，最后发送给内核，由内核进行处理<br>2.异常由CPU产生，例如缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常等。其会发送给内核，由内核来进行异常处理。</p>
<h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><p>1.用户态：用户可以操作和访问的空间，这个空间通常存放我们用户自己的数据等<br>2.内核态：是系统内核来操作的一块空间，用来存放系统内核的函数，接口等<br>3.二者之间的最大区别就是特权级不同：用户态拥有最低的特权级，内核态拥有较高的特权级<br>4.为什么要分为内核态和用户态：为了安全性。在CPU的一些指令中，有些指令如果用错，将导致整个系统崩溃。分开之后，如果用户需要某些操作，内核为其提供了API，可以通过系统调用陷入内核，让内核去执行操作。<br>5.什么样的功能应该在内核态下实现：</p>
<ul>
<li>CPU的管理和内存管理：更为安全</li>
<li>诊断和测试程序：因为需要访问计算机的所有资源</li>
<li>文件系统：用户数据的管理可以放在用户态下，而对于文件系统本身的管理，需要放在内核态中。</li>
<li>IO管理：因为要访问各种设备和底层数据结构，所以也要放在内核态实现。<br>6.如何辨别当前处于哪个态：CPU中有一个状态字，标识了当前的状态，用户态为3，内核态为0</li>
</ul>
<h1 id="用户态和内核态的切换"><a href="#用户态和内核态的切换" class="headerlink" title="用户态和内核态的切换"></a>用户态和内核态的切换</h1><p>1.系统调用：其机制核心还是通过操作系统为用户特别开放的一个中断来实现，表现为一个正常的异常（软中断）。</p>
<ul>
<li>进程调用：exit和fork</li>
<li>文件系统访问：chmod和chown</li>
<li>设备调用：read和write</li>
<li>信息读取：读取设备信息</li>
<li>通信：pipe和mmap<br>2.中断：当外围设备完成用户请求的操作之后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条将要执行的指令，转而去执行中断信号的处理程序，如果先执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了有<br>用户态到内核态的切换。<br>3.异常：当CPU在执行用户态的程序时，发现某些异常情况，就会触发由当前进程切换到异常的内核相关程序中，比如缺页异常。</li>
</ul>
<h1 id="申请的虚拟内存大小超过了物理内存的大小"><a href="#申请的虚拟内存大小超过了物理内存的大小" class="headerlink" title="申请的虚拟内存大小超过了物理内存的大小"></a>申请的虚拟内存大小超过了物理内存的大小</h1><p>1.应用程序使用malloc申请的内存实际上是虚拟内存，此时并不会分配物理内存，只有当应用程序读取了虚拟内存，CPU会去访问这块虚拟内存，发现并没有映射到物理内存上，CPU就会产生缺页中断，用户态切换到内核态，由缺页中断处理函数去处理</p>
<ul>
<li>如果有空闲物理内存，就会直接分配，并且建立虚拟内存和物理内存的映射</li>
<li>如果没有，内核就会开始内存回收的任务，如果空闲的物理内存大小不够，就会触发OOM<br>2.在32位机器上，最大可申请的虚拟内存大小是3G<br>3.在64位机器上，最大可申请的虚拟内存大小是128T，即使物理内存只有2G，我们也可以申请4G或者8G的虚拟内存，此时分为两种情况：</li>
<li>没有开启Swap分区：此时由于物理内存不够，最终会触发OOM（内存溢出）</li>
<li>开启了Swap分区，此时进程可以正常运行（Swap机制会将不常用的内存先写到磁盘中，然后释放这些内存，再次访问这些内存时，从磁盘读入即可）</li>
</ul>
<h1 id="Swap机制触发的条件"><a href="#Swap机制触发的条件" class="headerlink" title="Swap机制触发的条件"></a>Swap机制触发的条件</h1><p>1.内存不足：当系统需要的内存超过了可用的物理内存时，内核会将内存中不常使用的内存页交换到磁盘上为当前进程让出内存，保证正在执行的进程的可用性，这个内存回收的过程是强制的直接内存回收（Direct Page Reclaim）。直接内存回收是同步的过程，会阻塞当前申请内存的进程。<br>2.内存闲置：应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程（kSwapd），我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程。</p>
<h1 id="协程是什么"><a href="#协程是什么" class="headerlink" title="协程是什么"></a>协程是什么</h1><p>1.用户态的轻量级线程，是线程内部调度的基本单位，只在用户态内进行切换<br>2.先将寄存器上下文和栈保存，等切换回来的时候再进行恢复<br>3.同一时间只能执行一个协程，而其他协程处于休眠状态，适合对任务进行分时处理<br>4.基本没有到内核态切换的开销，可以不加锁的访问全局变量，所以上下文切换的非常快<br>5.其通信方式是共享队列和消息队列</p>
<h1 id="一般需要几级页表"><a href="#一般需要几级页表" class="headerlink" title="一般需要几级页表"></a>一般需要几级页表</h1><p>32位系统下，一个页大小是4KB，虚拟地址4GB，那么可以分为100万个页，一个页表项4B，那么4B * 2 * 2^20 &#x3D; 4MB，这对应的是一个进程，而多个进程就会有多个页表，导致页表会及其庞大<br>32位系统两级分页就足够了，64位的系统是4级分页</p>
<h1 id="中断的作用"><a href="#中断的作用" class="headerlink" title="中断的作用"></a>中断的作用</h1><p>一方面，有了中断功能，PC系统就可以使CPU和外设同时工作，使系统可以及时地响应外部事件。而且有了中断功能，CPU可允许多个外设同时工作。这样就大大提高了CPU的利用率，也提高了数据输入、输出的速度。 另一方面，有了中断功能，就可以使CPU及时处理各种软硬件故障。计算机在运行过程中，往往会出现事先预料不到的情况或出现一些故障，如电源掉电、存储出错，运算溢出等等。计算机可以利用中断系统自行处理，而不必停机或报告工作人员。</p>
<h1 id="CPU-Cache的数据结构和读取过程"><a href="#CPU-Cache的数据结构和读取过程" class="headerlink" title="CPU Cache的数据结构和读取过程"></a>CPU Cache的数据结构和读取过程</h1><p>1.存储结构：Cache Line组成，包括头标记和数据块，每次载入数据都是按照Cache Line整个读取<br>2.访问和存储：索引 + 有效位 + 组标记 + 偏移量，访问步骤如下：</p>
<ul>
<li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Cache Line 的地址；</li>
<li>找到对应 CPU Cache Line 后，判断 CPU Cache Line 中的有效位，确认 CPU Cache Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行；</li>
<li>对比内存地址中组标记和 CPU Cache Line 中的组标记，确认 CPU Cache Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行；</li>
<li>根据内存地址中偏移量信息，从 CPU Cache Line 的数据块中，读取对应的字。</li>
</ul>
<h1 id="关于伪共享的问题"><a href="#关于伪共享的问题" class="headerlink" title="关于伪共享的问题"></a>关于伪共享的问题</h1><p>1.如果两个变量属于同一个Cache Line块，而恰好两个CPU核心需要分别修改这两个变量，则会发生Cache Line没有起到缓存的作用，降低了代码执行的速度<br>2.避免伪共享的方法<br>将变量设置为内存对齐，用空间换取时间</p>
<h1 id="CPU选择线程的问题"><a href="#CPU选择线程的问题" class="headerlink" title="CPU选择线程的问题"></a>CPU选择线程的问题</h1><p>1.三个运行队列：</p>
<ul>
<li>Deadline运行队列</li>
<li>实时任务运行队列</li>
<li>CFS运行队列：完全公平调度，优先选择虚拟运行时间少的任务，虚拟运行时间 +&#x3D; 实际运行时间 &#x2F; 权重</li>
</ul>
<h1 id="硬中断和软中断"><a href="#硬中断和软中断" class="headerlink" title="硬中断和软中断"></a>硬中断和软中断</h1><p>Linux 将中断处理程序分为上半部和下半部：<br>上半部，对应硬中断，由硬件触发中断，用来快速处理中断；<br>下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作，Linux 中的软中断包括网络收发、定时、调度、RCU 锁等各种类型</p>
<h1 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h1><p>1.切换内容：用户空间的虚拟内存，栈，全局变量等；内核空间的堆栈、寄存器等<br>2.何时发生切换：CPU时间片用完；内存不足，则进程也会被挂起，当有优先级更高的进程运行，当前进程也会被挂起；发生硬件中断的时候也会发生进程的切换</p>
<h1 id="互斥锁和自旋锁"><a href="#互斥锁和自旋锁" class="headerlink" title="互斥锁和自旋锁"></a>互斥锁和自旋锁</h1><p>互斥锁加锁失败会发生线程的上下文切换，需要消耗一定的时间，自旋锁是用户态完成加锁和解锁操作，不会主动产生线程上下文切换，运行时间更快，自旋锁通过 CPU 提供的 CAS 函数实现，包含两个步骤：</p>
<ul>
<li>第一步，查看锁的状态，如果锁是空闲的，则执行第二步；</li>
<li>第二步，将锁设置为当前线程持有；<br>CAS 函数就把这两个步骤合并成一条硬件级指令，形成原子指令，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">计算机网络面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-09 12:38:22" itemprop="dateCreated datePublished" datetime="2022-07-09T12:38:22+08:00">2022-07-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-20 21:18:06" itemprop="dateModified" datetime="2022-10-20T21:18:06+08:00">2022-10-20</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="ping命令的工作原理"><a href="#ping命令的工作原理" class="headerlink" title="ping命令的工作原理"></a>ping命令的工作原理</h1><p>1.ping发送一个ICMP（Internet Control Messages Protocol），即因特网信报控制协议；接收端回声消息给目的地并报告是否收到所希望的应答。它的原理是：利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，通过对方回复的数据包来确定两台网络机器是否连接相通，时延是多少。<br>2.ping是应用层直接使用网络层ICMP的一个例子，它没有通过运输层的TCP或UDP。所以ICMP属于网络层协议。<br>3.对于ping命令，我们需要的到达的效果是检查是否联通。那么只需要我们的请求方带上数字标识8（回送请求），如果对方回送的数值是0，那么证明两者是联通的。<br>4.一个例子：</p>
<ul>
<li>执行 ping 192.168.0.5：此时ping命令会构建一个固定格式的ICMP请求数据包</li>
<li>IP层协议将以地址“192.168.0.5”作为目的地址，本机IP地址作为源地址，加上一些其他的控制信息，构建一个IP数据包发往192.168.0.5。 </li>
<li>目的主机相关操作：接收后检查该数据帧，将IP数据包从帧中提取出来，交给本机的IP层协议。IP层检查后，将有用的信息提取后交给ICMP协议。ICMP协议后者处理后，马上构建一个ICMP应答包，发送给主机A。</li>
</ul>
<h1 id="IPV4每个部分的含义"><a href="#IPV4每个部分的含义" class="headerlink" title="IPV4每个部分的含义"></a>IPV4每个部分的含义</h1><p>1.版本：4位，表示是IPV4还是IPV6<br>2.首部长度：默认20B<br>3.总长度：首部+数据和的长度，最大65535B，而MTU为1500B<br>4.标识：用于分片后进行重装<br>5.标志：MF &#x3D; 1表示后面还有分片，MF &#x3D; 0表示是最后一个分片，DF &#x3D; 0表示允许分片<br>6.TTL：生存时间，报文经过每个路由器都将减一，当为0时，丢弃该报文<br>7.协议：6表示TCP，17表示UDP<br>8.首部校验和：只检验数据报首部<br>9.源地址和目的地址</p>
<h1 id="epoll如何知道数据已经被完整读取"><a href="#epoll如何知道数据已经被完整读取" class="headerlink" title="epoll如何知道数据已经被完整读取"></a>epoll如何知道数据已经被完整读取</h1><p>用epoll + ET模式读取数据，当检查到监听的socket可以读取数据时，使用recv函数读取上面的数据，当该函数返回-1且errno是EAGAIN或EWOULDBLOCK的时候，表示数据已经全部读取完毕。</p>
<h1 id="epoll的ET模式时-如果数据只读了一半-也就是缓冲区的数据只读了一点-然后又来新事件了怎么办？"><a href="#epoll的ET模式时-如果数据只读了一半-也就是缓冲区的数据只读了一点-然后又来新事件了怎么办？" class="headerlink" title="epoll的ET模式时,如果数据只读了一半,也就是缓冲区的数据只读了一点,然后又来新事件了怎么办？"></a>epoll的ET模式时,如果数据只读了一半,也就是缓冲区的数据只读了一点,然后又来新事件了怎么办？</h1><p>这里我使用通过epoll_ctl对该文件描述符注册epolloneshot事件，一个线程处理socket时，其他线程将无法处理，当该线程处理完后，需要通过epoll_ctl重置epolloneshot事件</p>
<h1 id="http断点续传"><a href="#http断点续传" class="headerlink" title="http断点续传"></a>http断点续传</h1><p>1.http 1.1中定义了断点续传的相关Range和Content-Range字段。</p>
<ul>
<li>客户端：Range字段，指定第一个字节的位置和最后一个字节的位置，有多种格式，可以具体的指示需要哪些字节，甚至可以指定多个范围值</li>
<li>服务端：Content-Range字段，返回当前接受的范围和文件总大小，响应完成后，返回的响应头内容也不一样，例如200 OK表示不使用断点续传的方式，206则表示使用断点续传的方式</li>
<li>增强校验：在实际场景中，会出现一种情况，即在终端发起续传请求时，URL 对应的文件内容在服务器端已经发生变化，此时续传的数据肯定是错误的。如何解决这个问题了？显然此时需要有一个标识文件唯一性的方法。在 RFC2616 中也有相应的定义，比如实现Last-Modified 来标识文件的最后修改时间，这样即可判断出续传文件时是否已经发生过改动。同时 FC2616 中还定义有一个 ETag 的头，可以使用 ETag 头来放置文件的唯一标识。<br>2.工作原理</li>
<li>第一次请求：客户端发起GET请求一个文件，服务器处理请求，返回文件内容以及相应的 Header，其中包括 Etag（例如：627-4d648041f6b80）（假设服务器支持 Etag 生成并已开启了 Etag）状态码为 200。</li>
<li>第二次请求（断点续传）：客户端发起 HTTP GET 请求一个文件，同时发送 If-Range（该头的内容就是第一次请求时服务器返回的 Etag：627-4d648041f6b80）。<br>服务器判断接收到的 Etag 和计算出来的 Etag 是否匹配，如果匹配，那么响应的状态码为 206；否则，状态码为 200。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/05/%E7%89%9B%E5%AE%A2c-%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/05/%E7%89%9B%E5%AE%A2c-%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">牛客c++面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-05 20:15:56" itemprop="dateCreated datePublished" datetime="2022-07-05T20:15:56+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-10-11 15:39:20" itemprop="dateModified" datetime="2022-10-11T15:39:20+08:00">2022-10-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一-C-部分"><a href="#一-C-部分" class="headerlink" title="一. C++部分"></a>一. C++部分</h1><h3 id="1-说一说指针和引用的区别"><a href="#1-说一说指针和引用的区别" class="headerlink" title="1.说一说指针和引用的区别"></a>1.说一说指针和引用的区别</h3><p>指针内部保存的是指向的对象的地址信息，而引用是变量的别名；<br>指针可以随时初始化，而引用被定义之后就要初始化，不可以为空<br>sizeof引用是被引用的对象的大小，而sizeof指针是指针类型的大小<br>指针既有顶层const（指针本身不能变），也有底层const（指针指向的对象不能变），而引用只有底层const，顶层const是无意义的。<br>二者的++操作不同，指针++表示指针运算，而引用++表示变量执行++。<br>引用只是C++的语法糖，可以看作是自动取地址解引用的常量指针。在汇编层面是一样的。</p>
<h3 id="2-struct和class的区别"><a href="#2-struct和class的区别" class="headerlink" title="2.struct和class的区别"></a>2.struct和class的区别</h3><p>默认的（继承）访问权限，class是private，struct默认是public<br>class可以实现模板类，而struct不可以<br>struct是值类型，而class是引用类型</p>
<h3 id="3-c-中多态"><a href="#3-c-中多态" class="headerlink" title="3.c++中多态"></a>3.c++中多态</h3><p>为了使代码重用性增加，使得代码可以模块化<br>静态多态：通过重载函数和泛型编程实现，通过基类指针指向的对象不同而调用不同的函数。是在编译器就完成的，编译器根据实参类型来确定。具有更好的类型安全性，因为编译阶段会对所有的绑定类型进行检查。<br>动态多态：通过虚函数和继承实现，运行时确定。虚函数表保存在只读数据段，编译器将类对象的前四个字节设置为指向虚函数表的指针。</p>
<h3 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4.面向对象"></a>4.面向对象</h3><p>面向对象的三大特征：封装、继承、多态。封装：将客观事物进行抽象，将其属性和方法合成为一个类，类封装了成员变量和成员函数，同时又实现对属性和方法的权限控制，降低与外界的耦合度 继承：子类继承父类的各种属性和方法，同时子类还可以在父类的基础上重新定义和扩展父类的属性和方法，使其具有不同的功能，继承提高了代码的复用性及可维护性 多态：同一调用语句在父类和子类间使用时具有不同的表现形式，可以使用同一段代码处理不行类型的对象，提高代码的复用性</p>
<h3 id="5-浅拷贝和深拷贝"><a href="#5-浅拷贝和深拷贝" class="headerlink" title="5.浅拷贝和深拷贝"></a>5.浅拷贝和深拷贝</h3><p>浅拷贝 (Shallow Copy) 只复制某个对象的指针, 而不复制对象本身, 新旧对象还是共享同一块内存。在对象析构后，容易产生指针访问一个不存在的对象，从而产生悬空指针。<br>深拷贝 (Deep Copy) 在拷贝的过程中会另外创造一个一模一样的对象. 新对象跟原对象不共享内存, 修改新对象不会改到原对象. </p>
<h3 id="6-STL容器的实现和查找时间复杂度"><a href="#6-STL容器的实现和查找时间复杂度" class="headerlink" title="6.STL容器的实现和查找时间复杂度"></a>6.STL容器的实现和查找时间复杂度</h3><ol>
<li>vector 采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为： 插入: O(N) 查看: O(1) 删除: O(N) 2. deque 采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为： 插入: O(N) 查看: O(1) 删除: O(N) 3. list 采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为： 插入: O(1) 查看: O(N) 删除: O(1) 4. map、set、multimap、multiset 上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为: 插入: O(logN) 查看: O(logN) 删除: O(logN) 5. unordered_map、unordered_set、unordered_multimap、 unordered_multiset 上述四种容器采用哈希表实现，不同操作的时间复杂度为： 插入: O(1)，最坏情况O(N) 查看: O(1)，最坏情况O(N) 删除: O(1)，最坏情况O(N) 注意：容器的时间复杂度取决于其底层实现方式。</li>
</ol>
<h3 id="7-STL-中容器的类型，每种分别有哪些容器"><a href="#7-STL-中容器的类型，每种分别有哪些容器" class="headerlink" title="7.STL 中容器的类型，每种分别有哪些容器"></a>7.STL 中容器的类型，每种分别有哪些容器</h3><ol>
<li>序列式容器 array、vector、deque、list、forward_list 2. 关联式容器 map、multimap、set、multiset 3. 无序关联式容器 unordered_map、unordered_multimap、unordered_set、unordered_multiset 4. 容器适配器 stack、queue、priority_queue</li>
</ol>
<h3 id="8-简述一下-C-的重载和重写"><a href="#8-简述一下-C-的重载和重写" class="headerlink" title="8.简述一下 C++ 的重载和重写"></a>8.简述一下 C++ 的重载和重写</h3><ol>
<li>重载<br>a. 重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同（参数列表不同）。调用的时候根据函数的参数来区别不同的函数，函数重载跟返回值无关。<br>b. 重载的规则 - 函数名相同 - 必须具有不同的参数列表 - 可以有不同的访问修饰符<br>c. 重载用来实现静态多态（函数名相同，功能不一样）。<br>d. 重载是多个函数或者同一个类中方法之间的关系，是平行关系。</li>
<li>重写<br>a. 重写（也叫覆盖）是指在派生类中重新对基类中的虚函数重新实现。即函数名和参数都一样，只是函数的实现体不一样。<br>b. 重写的规则： - 方法声明必须完全与父类中被重写的方法相同 - 访问修饰符的权限要大于或者等于父类中被重写的方法的访问修饰符 - 子类重写的方法可以加virtual，也可以不加<br>c. 重写用来实现动态多态（根据调用方法的对象的类型来执行不同的函数）。<br>d. 重写是父类和子类之间的关系，是垂直关系。</li>
</ol>
<p>隐藏的实质是：在函数查找时，名字查找先于类型检查。如果派生类中成员和基类中的成员同名，就隐藏掉。编译器首先在相应作用域中查找函数，如果找到名字一样的则停止查找。</p>
<h3 id="9-简述一下虚函数的实现原理"><a href="#9-简述一下虚函数的实现原理" class="headerlink" title="9.简述一下虚函数的实现原理"></a>9.简述一下虚函数的实现原理</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75172640">https://zhuanlan.zhihu.com/p/75172640</a></p>
<ol>
<li>C++ 中的虚函数的作用主要是实现了动态多态的机制。 2. 虚函数实现原理 编译器处理虚函数时，给每个对象添加一个隐藏的成员。隐藏的成员是一个指针类型的数据，指向的是函数地址数组，这个数组被称为虚函数表（virtual function table，vtbl）。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚函数表中保存的是派生类的虚函数地址，如果派生类没有重写基类中的虚函数，则派生类对象的虚函数表中保存的是父类的虚函数地址。使用虚函数时，对于内存和执行速度方面会有一定的成本： 1. 每个对象都会变大，变大的量为存储虚函数表指针； 2. 对于每个类，编译器都会创建一个虚函数表； 3. 对于每次调用虚函数，都需要额外执行一个操作，就是到表中查找虚函数地址。</li>
</ol>
<h3 id="10-为什么将析构函数设置成虚函数"><a href="#10-为什么将析构函数设置成虚函数" class="headerlink" title="10.为什么将析构函数设置成虚函数"></a>10.为什么将析构函数设置成虚函数</h3><p>虚析构函数的主要作用是为了防止遗漏资源的释放，防止内存泄露。如果基类中的析构函数没有声明为虚函数，基类指针指向派生类对象时，则当基类指针释放时不会调用派生类对象的析构函数，而是调用基类的析构函数，如果派生类析构函数中做了某些释放资源的操作，则这时就会造成内存泄露。</p>
<h3 id="11-哈希冲突的原因和影响因素，哈希冲突的解决方法"><a href="#11-哈希冲突的原因和影响因素，哈希冲突的解决方法" class="headerlink" title="11.哈希冲突的原因和影响因素，哈希冲突的解决方法"></a>11.哈希冲突的原因和影响因素，哈希冲突的解决方法</h3><ol>
<li>哈希冲突产生的原因 哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过哈希函数产生的哈希值是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的值，这时候就产生了哈希冲突。</li>
<li>产生哈希冲突的影响因素 装填因子（装填因子&#x3D;数据总数 &#x2F; 哈希表长）、哈希函数、处理冲突的方法 </li>
<li>哈希冲突的解决方法<br>a.开放地址方法：如果冲突，则根据冲突的值再建立一个值，如果还冲突就重复操作直到不再冲突<br>b.链式地址法：将所有冲突的都放入一个链表中<br>c.建立公共溢出区：基本表和溢出表<br>d.再哈希法：同时构建多个哈希函数，一个发生冲突就使用另一个</li>
</ol>
<h3 id="12-map，unordered-map-的区别"><a href="#12-map，unordered-map-的区别" class="headerlink" title="12.map，unordered_map 的区别"></a>12.map，unordered_map 的区别</h3><p>map：内部实现了一个红黑树，该结构具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素，因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了 map 的效率。<br>unordered_map：内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。</p>
<h3 id="13-红黑树的特性，为什么要有红黑树"><a href="#13-红黑树的特性，为什么要有红黑树" class="headerlink" title="13.红黑树的特性，为什么要有红黑树"></a>13.红黑树的特性，为什么要有红黑树</h3><p>在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树，红黑树具有如下特点：<br> 1、具有二叉查找树的特点；<br> 2、根节点是黑色的；<br> 3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；<br> 4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；<br> 5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。</p>
<h3 id="14-vector-的扩容机制，扩容以后，它的内存地址会变化吗？"><a href="#14-vector-的扩容机制，扩容以后，它的内存地址会变化吗？" class="headerlink" title="14.vector 的扩容机制，扩容以后，它的内存地址会变化吗？"></a>14.vector 的扩容机制，扩容以后，它的内存地址会变化吗？</h3><p> 当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步： 1. 完全弃用现有的内存空间，重新申请更大的内存空间； 2. 将旧内存空间中的数据，按原有顺序移动到新的内存空间中； 3. 最后将旧的内存空间释放。 因为 vector 扩容需要申请新的空间，所以扩容以后它的内存地址会发生改变。vector 扩容是非常耗时的，为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity&gt;&#x3D;size），以便后期使用。<br> vector底层使用三个指针来实现，分别是：顺序表头，顺序表的有效长度位置，顺序表末尾。<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51723227/article/details/121374795#:~:text=%E5%9C%A8%E6%A0%87%E5%87%86C%2B%2B%E4%B8%AD%2C,%2C%E8%BE%BE%E5%88%B0%E5%AD%98%E5%82%A8%E6%95%88%E6%9E%9C">https://blog.csdn.net/m0_51723227/article/details/121374795#:~:text=%E5%9C%A8%E6%A0%87%E5%87%86C%2B%2B%E4%B8%AD%2C,%2C%E8%BE%BE%E5%88%B0%E5%AD%98%E5%82%A8%E6%95%88%E6%9E%9C</a>.</p>
<h3 id="15-请你说说-map-实现原理，各操作的时间复杂度是多少"><a href="#15-请你说说-map-实现原理，各操作的时间复杂度是多少" class="headerlink" title="15.请你说说 map 实现原理，各操作的时间复杂度是多少"></a>15.请你说说 map 实现原理，各操作的时间复杂度是多少</h3><ol>
<li>map 实现原理 map 内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而 AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此 map 内部所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map 中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值，使用中序遍历可将键值按照从小到大遍历出来。 2. 各操作的时间复杂度 插入: O(logN) 查看: O(logN) 删除: O(logN)</li>
</ol>
<h3 id="16-shared-ptr-怎么知道跟它共享对象的指针释放了"><a href="#16-shared-ptr-怎么知道跟它共享对象的指针释放了" class="headerlink" title="16.shared_ptr 怎么知道跟它共享对象的指针释放了"></a>16.shared_ptr 怎么知道跟它共享对象的指针释放了</h3><p>shared_ptr基于”引用计数”模型实现，多个shared_ptr可指向同一个动态对象，并维护一个共享的引用计数器，记录了引用同一对象的shared_ptr实例的数量。当最后一个指向动态对象的shared_ptr销毁时，会自动销毁其所指对象(通过delete操作符)。</p>
<h3 id="17-请你说说左值、右值、左值引用、右值引用、右值引用的使用场景"><a href="#17-请你说说左值、右值、左值引用、右值引用、右值引用的使用场景" class="headerlink" title="17.请你说说左值、右值、左值引用、右值引用、右值引用的使用场景"></a>17.请你说说左值、右值、左值引用、右值引用、右值引用的使用场景</h3><ol>
<li>左值 在 C++ 中可以取地址的、有名字的就是左值 int a &#x3D; 10; &#x2F;&#x2F; 其中 a 就是左值 </li>
<li>右值 不能取地址的、没有名字的就是右值 int a &#x3D; 10; &#x2F;&#x2F; 其中 10 就是右值右值 </li>
<li>左值引用 左值引用就是对一个左值进行引用。传统的 C++ 引用（现在称为左值引用）使得标识符关联到左值。左值是一个表示数据的表达式（如变量名或解除引用的指针），程序可获取其地址。最初，左值可出现在赋值语句的左边，但修饰符 const 的出现使得可以声明这样的标识符，即不能给它赋值，但可获取其地址： int n; int * pt &#x3D; new int; const int b &#x3D; 101; int &amp; rn &#x3D; n; int &amp; rt &#x3D; *pt; const int &amp; rb &#x3D; b; const int &amp; rb &#x3D; 10; </li>
<li>右值引用 右值引用就是对一个右值进行引用。C++ 11 新增了右值引用（rvalue reference），这种引用可指向右值（即可出现在赋值表达式右边的值），但不能对其应用地址运算符。右值包括字面常量（C-风格字符串除外，它表示地址）、诸如 x + y 等表达式以及返回值的函数（条件是该函数返回的不是引用），右值引用使用 &amp;&amp; 声明： int x &#x3D; 10; int y &#x3D; 23; int &amp;&amp; r1 &#x3D; 13; int &amp;&amp; r2 &#x3D; x + y; double &amp;&amp; r3 &#x3D; std::sqrt(2.0); </li>
<li>右值引用的使用场景 右值引用可以实现移动语义、完美转发。</li>
</ol>
<h3 id="17-weak-ptr-如何解决-shared-ptr-的循环引用问题？"><a href="#17-weak-ptr-如何解决-shared-ptr-的循环引用问题？" class="headerlink" title="17.weak_ptr 如何解决 shared_ptr 的循环引用问题？"></a>17.weak_ptr 如何解决 shared_ptr 的循环引用问题？</h3><p>weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数，依此特性可以解决 shared_ptr 的循环引用问题。 weak_ptr 没有解引用 * 和获取指针 -&gt; 运算符，它只能通过 lock 成员函数去获取对应的 shared_ptr 智能指针对象，从而获取对应的地址和内容。 不论是否有 weak_ptr 指向，一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。</p>
<h3 id="18-请你说说虚函数可以是内联函数吗"><a href="#18-请你说说虚函数可以是内联函数吗" class="headerlink" title="18.请你说说虚函数可以是内联函数吗"></a>18.请你说说虚函数可以是内联函数吗</h3><p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可以内联。virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
<h3 id="19-请你说说迭代器失效原因，有哪些情况"><a href="#19-请你说说迭代器失效原因，有哪些情况" class="headerlink" title="19.请你说说迭代器失效原因，有哪些情况"></a>19.请你说说迭代器失效原因，有哪些情况</h3><p>STL 中某些容器调用了某些成员方法后会导致迭代器失效。例如 vector 容器，如果调用 reserve() 来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector 容器的元素可能已经被复制或移到了新的内存地址。 </p>
<ol>
<li>序列式容器迭代器失效 对于序列式容器，例如 vector、deque，由于序列式容器是组合式容器，当当前元素的迭代器被删除后，其后的所有元素的迭代器都会失效，这是因为 vector、deque都是连续存储的一段空间，所以当对其进行 erase 操作时，其后的每一个元素都会向前移一个位置。解决：erase 返回下一个有效的迭代器。 </li>
<li>关联式容器迭代器失效 对于关联容器，例如如 map、 set，删除当前的迭代器，仅仅会使当前的迭代器失效，只要在 erase 时，递增当前迭代器即可。这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个节点不会对其他点造成影响。erase 迭代器只是被删元素的迭代器失效，但是返回值为 void，所以要采用 erase(iter++) 自增方式删除迭代器。</li>
</ol>
<h3 id="20-请你说说-auto-和-decltype-如何使用"><a href="#20-请你说说-auto-和-decltype-如何使用" class="headerlink" title="20.请你说说 auto 和 decltype 如何使用"></a>20.请你说说 auto 和 decltype 如何使用</h3><p>auto 实现自动类型推断，要求进行显示初始化，让编译器能够将变量的类型设置为初始值的类型<br>decltype 将变量的类型声明为表达式指定的类型。decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型,而且decltype并不会对表达式进行求值。</p>
<h3 id="21-说说-C-中智能指针和指针的区别是什么？"><a href="#21-说说-C-中智能指针和指针的区别是什么？" class="headerlink" title="21.说说 C++ 中智能指针和指针的区别是什么？"></a>21.说说 C++ 中智能指针和指针的区别是什么？</h3><p>智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。指针是一种数据类型，用于保存内存地址，而智能指针是类模板。</p>
<h3 id="22-简述一下-C-中的四种类型转换"><a href="#22-简述一下-C-中的四种类型转换" class="headerlink" title="22.简述一下 C++ 中的四种类型转换"></a>22.简述一下 C++ 中的四种类型转换</h3><p>1.static_cast 静态转换 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换 - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的 - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的 用于基本数据类型之间的转换，如把 int 转换成 char，把 char 转换成 int。这种转换的安全性也要开发人员来保证<br>2.dynamic_cast 动态转换 dynamic_cast 主要用于类层次间的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的 在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全<br>3. const_cast 常量转换 该运算符用来修改类型的const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 常量引用被转换成非常量引用，并且仍然指向原来的对象 注意:不能直接对非指针和非引用的变量使用 const_cast 操作符<br>4. reinterpret_cast 重新解释转换 这是最不安全的一种转换机制，最有可能出问题 主要用于将一种数据类型从一种类型转换为另一种类型，它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针</p>
<h1 id="new-和-delete-是如何实现的"><a href="#new-和-delete-是如何实现的" class="headerlink" title="new 和 delete 是如何实现的"></a>new 和 delete 是如何实现的</h1><p>1.new的实现过程是：首先调用名为operator new 的标准库函数，分配足够大的内存来保存指定类型的一个对象，接下来运行该类型的构造函数，用于初始化该对象，最后返回该对象的指针。<br>2.delete的实现过程：对指针指向的对象运行适当的析构函数，然后调用operator delete的标准库函数释放该对象的内存</p>
<h1 id="指针占多少字节"><a href="#指针占多少字节" class="headerlink" title="指针占多少字节"></a>指针占多少字节</h1><p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。32位编译环境下为4字节，64位编译环境下为8字节</p>
<h1 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h1><p>1.顶层const可以表示任意的对象是常量，这一点对任何数据类型都使用，底层const则与指针和引用的复合类型有关<br>2.当执行对象的拷贝操作时，顶层const不受什么影响，但是底层const的限制不能被忽略。<br>3.对于重载，顶层const不构成重载，底层const构成重载</p>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><p>1.列不可再分<br>2.属性完全依赖于主键（一张表中包含了多种不同的属性，那么必须要分成多张表）<br>3.属性不依赖于其他非主属性（要求已经分好了多张表的话，一张表中只能有另一张表的ID，而不能有其他任何信息）</p>
<h1 id="类成员继承权限问题"><a href="#类成员继承权限问题" class="headerlink" title="类成员继承权限问题"></a>类成员继承权限问题</h1><p>1.若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；<br>2.若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；<br>3.若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</p>
<h1 id="禁止隐式转换"><a href="#禁止隐式转换" class="headerlink" title="禁止隐式转换"></a>禁止隐式转换</h1><p>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
<h1 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h1><p>1.数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)&#x2F;sizeof(数组元素数据类型)；<br>2.用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。<br>3.在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</p>
<h1 id="写一个比较大小的模板"><a href="#写一个比较大小的模板" class="headerlink" title="写一个比较大小的模板"></a>写一个比较大小的模板</h1><pre><code>template&lt;typename type1, typename type2&gt;

type1 max(type1 a, type2 b)&#123;
    return a &gt; b ? a : b;
&#125;

void main()&#123;
    cout &lt;&lt; max(5.5, &#39;a&#39;) &lt;&lt; endl;
&#125;
</code></pre>
<p>其实该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a &gt; b 这一步是会报错的。这个时候往往需要对于 &gt; 号进行重载，这代码量瞬间上来了。</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数，比如epoll中可以通过回调函数找到对应的红黑树节点。</p>
<h1 id="delete和delete-的区别"><a href="#delete和delete-的区别" class="headerlink" title="delete和delete[]的区别"></a>delete和delete[]的区别</h1><p>delete只会调用一次析构函数。<br>delete[]会调用数组中每个元素的析构函数</p>
<h1 id="类的对象存储空间"><a href="#类的对象存储空间" class="headerlink" title="类的对象存储空间"></a>类的对象存储空间</h1><p>1.非静态成员的数据类型大小之和。<br>2.编译器加入的额外成员变量（如指向虚函数表的指针）。<br>3.为了边缘对齐优化加入的padding。<br>4.空类(无非静态数据成员)的对象的size为1,这样可以保证每个实例均有独占的内存地址，当作为基类时, size为0，如果带有虚函数，则大小比1大，因为还需要包含一个虚函数表指针<br>5.成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。</p>
<h1 id="在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h1><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题</p>
<h1 id="如果在类的析构函数中调用delete-this，会发生什么？"><a href="#如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="如果在类的析构函数中调用delete this，会发生什么？"></a>如果在类的析构函数中调用delete this，会发生什么？</h1><p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h1 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a>auto和decltype的区别</h1><h1 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h1><p>1.利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；<br>2.每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。<br>3.lambda语法如下：</p>
<pre><code>[capture] （parameters） mutable -&gt;return-type &#123;statement&#125;;
</code></pre>
<p>4.lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p>
<h1 id="STL中hashtable的实现"><a href="#STL中hashtable的实现" class="headerlink" title="STL中hashtable的实现"></a>STL中hashtable的实现</h1><p>1.STL中的hashtable使用的是开链法解决hash冲突问题<br>2.hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p>
<h1 id="vector如何释放空间"><a href="#vector如何释放空间" class="headerlink" title="vector如何释放空间"></a>vector如何释放空间</h1><p>1.由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。<br>2.如果使用vector，可以用swap()来帮助你释放多余内存或者清空全部内存。</p>
<h1 id="容器内删除一个元素"><a href="#容器内删除一个元素" class="headerlink" title="容器内删除一个元素"></a>容器内删除一个元素</h1><p>1.顺序容器（序列式容器，比如vector、deque）<br>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</p>
<pre><code>it = c.erase(it);
</code></pre>
<p>2.关联容器(关联式容器，比如map、set、multimap、multiset等)<br>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</p>
<pre><code>c.erase(it++)
</code></pre>
<h1 id="STL每种容器对应的迭代器"><a href="#STL每种容器对应的迭代器" class="headerlink" title="STL每种容器对应的迭代器"></a>STL每种容器对应的迭代器</h1><p>1.vector和deque：随机访问迭代器<br>2.stack、queue、priority_queue：无<br>3.list、(multi)set&#x2F;map：双向迭代器<br>unordered_(multi)set&#x2F;map、forward_list：前向迭代器</p>
<h1 id="sizeof和strlen的区别"><a href="#sizeof和strlen的区别" class="headerlink" title="sizeof和strlen的区别"></a>sizeof和strlen的区别</h1><p>1、sizeof会将空字符\0计算在内，而strlen不会将空字符\0计算在内；<br>2、sizeof会计算到字符串最后一个空字符\0并结束，而strlen如果遇到第一个空字符\0的话就会停止并计算遇到的第一个空字符\0前面的长度。</p>
<pre><code>int main(void)
&#123;
    char str[100] = &quot;abcde&quot;;
    printf(&quot;sizeof(str) = %lu\n&quot;, sizeof(str));     //字节大小为100

    char str1[] = &quot;abcde&quot;;
    printf(&quot;sizeof(str1) = %lu\n&quot;, sizeof(str1));   //字节大小为6

    char str2[] = &quot;\0abcde&quot;;
    printf(&quot;sizeof(str2) = %lu\n&quot;, sizeof(str2));   //字节大小为7

    char str3[] = &quot;\0ab\0c de&quot;;
    printf(&quot;sizeof(str3) = %lu\n&quot;, sizeof(str3));   //字节大小为9

    char str4[] = &quot;abcde&quot;;
    printf(&quot;strlen(str4) = %lu\n&quot;, strlen(str4));   //字符串长度为5

    char str5[100] = &quot;abcde&quot;;
    printf(&quot;strlen(str5) = %lu\n&quot;, strlen(str5));   //字符串长度为5

    char str6[] = &quot;\0abcde&quot;;
    printf(&quot;strlen(str6) = %lu\n&quot;, strlen(str6));   //字符串长度为0

    char str7[] = &quot;ab cde&quot;;
    printf(&quot;strlen(str7) = %lu\n&quot;, strlen(str7));   //字符串长度为6

    return 0;
&#125;
</code></pre>
<h1 id="哪些函数不能是虚函数？把你知道的都说一说"><a href="#哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="哪些函数不能是虚函数？把你知道的都说一说"></a>哪些函数不能是虚函数？把你知道的都说一说</h1><p>1.构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造<br>2.内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；<br>3.静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。<br>4.友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。<br>5.普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p>
<h1 id="什么时候必须要自定义析构函数"><a href="#什么时候必须要自定义析构函数" class="headerlink" title="什么时候必须要自定义析构函数"></a>什么时候必须要自定义析构函数</h1><p>如果本类中一个成员变量是别的对象的指针，而且这个指针不是传进来的地址而是这个指针指向的对象，是在本类中(如果是栈里的定位分配，也不用考虑内存)在堆中开辟的空间创建的。并且该指针没有进行过delete操作，那么久需要在析构方法中进行delete操作，此时我们就必须自己写析构函数。</p>
<h1 id="析构函数的析构过程"><a href="#析构函数的析构过程" class="headerlink" title="析构函数的析构过程"></a>析构函数的析构过程</h1><p>析构函数首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁。注意析构函数本身不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，销毁类类型成员执行它自己的析构函数，销毁内置类型不需要做什么。</p>
<h1 id="何时会调用析构函数"><a href="#何时会调用析构函数" class="headerlink" title="何时会调用析构函数"></a>何时会调用析构函数</h1><ul>
<li>变量在离开其作用域时</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁</li>
<li>对于动态分配的对象，当指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<h1 id="什么时候需要自己重写拷贝构造函数"><a href="#什么时候需要自己重写拷贝构造函数" class="headerlink" title="什么时候需要自己重写拷贝构造函数"></a>什么时候需要自己重写拷贝构造函数</h1><p>根据三&#x2F;五法则，如果需要定义一个非空的析构函数，那么通常情况下也需要自定义一个拷贝构造函数。即包含动态分配成员或者包含指针成员的类都应该提供拷贝构造函数，并且考虑重载赋值运算符。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/04/%E4%B8%AD%E6%9C%9B%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/07/04/%E4%B8%AD%E6%9C%9B%E9%9D%A2%E7%BB%8F/" class="post-title-link" itemprop="url">中望面经</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-04 22:52:06" itemprop="dateCreated datePublished" datetime="2022-07-04T22:52:06+08:00">2022-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-07-15 19:15:57" itemprop="dateModified" datetime="2022-07-15T19:15:57+08:00">2022-07-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>1.多态，运行时多态（虚函数表和继承），静态多态（重载和模板编程）<br>2.如何实现对象只能分配在栈上：c++中，类的对象建立分为两种，</p>
<ul>
<li>静态建立:由编译器在栈上为对象开辟空间，直接调用类的构造函数。<br>  A a;</li>
<li>动态建立：由new关键字将对象建立在堆空间上，首先执行 operator new()函数，在堆上搜索合适的内存并分配，第二步是调用构造函数构造对象。即间接的调用类的构造函数。<br>  A a &#x3D; new A;<br>（1）只有使用new关键字才能在堆上建立对象，那么我们就可以将operator new()函数自行声明为私有函数即可，或者设置为delete。<br>  class A{<br>  private；<br>  void* operator new(size_t t){} &#x2F;&#x2F;设置为私有<br>  void operator delete(void *ptr){}<br>  public:<br>  A(){}<br>  ~A(){}<br>  }<br>（2）只在堆上分配新对象<br>即不能直接调用类的构造函数。首先要知道，当对象建立在栈上面时, 是由编译器分配内存空间的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间。实际上，编译器在为类对象分配栈空间时, 会检查类的析构函数的访问性(其他非静态函数也会检查)，如果类的析构函数是私有的，则编程器不会在栈空间上为类对象分配内存。因此,我们只需要将析构函数设为私有，类对象就无法建立在栈上了。<br>  class A{<br>  public:<br>  A(){}<br>  void destroy(delete this;)<br>  private:<br>  ~A(){}<br>  }<br>注意，由于new表达式会在分配内存以后调用构造函数，因此构造函数必须是公有的，同时由于delete此时无法访问私有的析构函数，因此必须提供一个destroy函数，来进行内存空间的释放。<br>3.c++11新特性<br>auto，智能指针，移动语义（右值引用），完美转发<br>4.内联函数和宏的区别</li>
<li>内联函数是函数，有参数类型检查，更为安全</li>
<li>内联函数由编译器进行处理，而宏定义由预处理器进行处理</li>
<li>内联函数处理时被插入到对应代码区域，而宏定义只是简单的文本替换</li>
</ul>
<p>5.多线程<br>半同步半反应线程池<br>主线程充当异步线程，负责监听所有socket上的事件，若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件，并将数据封装成请求对象插入到请求队列中；所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</p>
<p>6.Linux进程调度和内存管理<br>7.设计模式<br>工厂模式和单例模式，适配器模式和策略模式<br>8.lambda表达式<br>9.手撕strcpy（不用任何库函数)<br>10.快排的 算法原理+手撕代码。<br>11.读代码说输出结果：一个简单的子类继承父类的代码<br>子类析构时，首先执行子类析构函数体的代码，然后执行子类成员对象所在类的析构函数，最后按照子类继承各个父类的次序，倒序各个父类的析构函数<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/371322392">https://zhuanlan.zhihu.com/p/371322392</a></p>
<p>12.栈溢出的原因<br>内存中栈一般存放，函数地址、函数参数、局部变量等信息存储于栈内存；<br>1&gt;函数调用层次过深，每调用一次，函数的参数、局部变量等信息就压一次栈。<br>2&gt;局部变量体积太大</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/27/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/27/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95/" class="post-title-link" itemprop="url">字节面试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-06-27 21:45:55" itemprop="dateCreated datePublished" datetime="2022-06-27T21:45:55+08:00">2022-06-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-11-16 23:34:28" itemprop="dateModified" datetime="2022-11-16T23:34:28+08:00">2022-11-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>#1.面试的问题</p>
<p>1.1 <code>linux</code>常用吗，知道哪些命令<br><code>ls</code> 就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限、查看目录信息等等。比如ls -a<br><code>cd</code> 切换当前目录到指定目录，比如cd ~ 进入<code>home</code>目录，cd &#x2F;xx 进入该目录<br><code>mkdir</code> 命令用于创建文件夹。<br><code>rm</code> 删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。<br><code>cp</code> 命令 将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>
<p>1.2 进程和线程的区别<br>（1）同一个进程的线程是共享该进程的地址空间和资源，但是不同的进程之间是独立的地址空间和资源<br>（2）一个进程崩溃后，在保护模式下不会对其他的进程产生影响，当时一个线程崩溃了那么该进程就崩溃了，所以说多进程比多线程要健壮<br>（3）进程的切换消耗的资源比较大，所以涉及到频繁的切换，使用线程更好<br>（4）二者均可以并发执行<br>1.3 进程通信方式<br>（1）管道（无名的）<br>（2）FiFO（有名的）<br>（3）消息队列，可以实现消息的随机查询<br>（4）信号量：是一个计数器，用于进程间的互斥和同步，一般结合共享内存使用<br>（5）共享内存：给多个进程共享一个指定的存储区，通过信号量实现互斥和同步，来达到进程间的通信<br>1.4 线程的通信<br>（1）全局变量：最好声明为volatile，在多线程过程中保证原子性<br>（2）消息：线程可以拥有消息队列和消息循环，在不同线程间通信<br>（3）事件：线程可以监视处于有信号状态的事件，适当的时候就可以对事件进行操作<br>1.5 TCP&#x2F;IP分为几层？tcp属于哪一层？http属于哪一层？http基于tcp还是udp？<br>分为五层，分别是应用层，传输层，网络层，数据链路层，物理层<br>TCP处于传输层，UDP也在这一层，<br>HTTP处于应用层，HTTP&#x2F;1.1 和 HTTP&#x2F;2 都是基于 TCP 传输协议的，而 HTTP&#x2F;3 是基于 UDP 传输协议的。（可以引申出各个版本的区别）<br>1.6 tcp和udp 区别<br>（1）tcp是面向连接的，可靠的传输，以字节流进行传输，传输效率慢，需要的资源多，应用场景为文件传输，邮件传输等，有确认，窗口，重传，拥塞控制等机制，每一条tcp连接只能是一对一的，全双工的，首部20字节开销<br>（2）udp是无连接的不可靠传输，不能保证数据发送顺序，以数据报文段的形式进行传输，没有拥塞控制，支持一对一，一对多，多对一和多对多，首部8个字节<br>1.7 三次握手、四次挥手？</p>
<p>1.9 Mysql的索引<br>索引就类似于目录，方便我们快速获取数据的一种数据结构。Mysql5.5之后的版本默认存储引擎是InnoDB，其支持B+树索引。这里就可以聊聊B+树和B树的区别，说明为什么Mysql使用B+树来作为索引。（二级索引去查主键索引：回表，以及覆盖索引。）（B+树和B树和二叉树和哈希的比较）</p>
<p>各种索引：<br>（1）主键索引：建立在主键上的索引，唯一而且不能为空值<br>（2）唯一索引：使用UNIQUE值创建的索引可以有多个，索引列的值必须为1，但是允许有空值<br>（3）普通索引：建立在普通字段上的索引，不要求字段为主键，也不需要字段为UNIQUE<br>（4）联合索引：将多个字段组合成一个索引，使用最左匹配原则进行查找和匹配。但是特殊情况是，如果最左匹配到的某个索引列的值是范围值的话，那么之后的索引列就不能再最左匹配。Mysql5.6以后有了索引下推优化，可以在联合索引遍历的过程重， 对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>1.20 抢30数学题：分为说出30赢和输，不同的策略</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/05/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%9A%84%E5%8E%BB%E9%87%8D%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/05/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98%E7%9A%84%E5%8E%BB%E9%87%8D%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">回溯问题的去重技巧</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-05 23:04:56" itemprop="dateCreated datePublished" datetime="2022-04-05T23:04:56+08:00">2022-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-06 14:47:28" itemprop="dateModified" datetime="2022-04-06T14:47:28+08:00">2022-04-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-回溯问题"><a href="#1-回溯问题" class="headerlink" title="1. 回溯问题"></a>1. 回溯问题</h1><p>在<code>leetcode</code>中我们经常会遇到很多需要求解一组集合或者所有排列的问题，这类问题的难点在于，通常情况下我们只有暴力求解这一种方式，通过遍历所有可能的解，从中找到符合我们要求的题解。常见的回溯问题包括以下类别：组合（不要求顺序，元素相同顺序不同的视为同样的答案），排列（要求顺序，相同元素不同顺序视为不同答案），切割，子集，棋盘（N皇后，数独）等。这类问题有一个共同特点就是可以抽象为树性结构，其中，所遍历的集合的大小构成了树的宽度，递归的深度构成了树的深度。下面我们给出回溯函数的模板，包括返回值、参数以及写法：</p>
<ul>
<li><p><strong>回溯方法的函数伪代码</strong></p>
<pre><code>  void backtarcking(参数)
</code></pre>
</li>
</ul>
<p>这里我们使用<code>void</code>作为回溯函数的返回值，因为我们需要做的是在集合中寻找符合题意的解，那么就可以设置一个<code>result</code>数组来保存符合题意的解，在递归调用的过程中，不断将解加入<code>result</code>即可，函数遇到终止条件就可以<code>return</code>。</p>
<ul>
<li><p><strong>回溯函数的终止条件</strong></p>
<p>  终止条件视情况而定，有可能是遍历到叶子节点，有可能是需要满足一些条件，在<code>backtracking</code>函数中，首先要做的就是判断是否触发了终止条件，如果触发了，那么就处理当前的结果，需要的话还要<code>return</code>，这里的关键是，如果需要遍历所有情况，则不需要<code>return</code>，因为其会导致后面的通往叶子节点的路径不会被遍历到。如果需要剪枝的话，则需要<code>return</code>。终止条件的伪代码为：</p>
<pre><code>  if(终止条件)&#123;
      处理结果；
      (return, 视情况而定)
  &#125;
</code></pre>
<p>  还需要注意的是，有些寻找子集的问题或者排列组合的问题中，并不需要终止条件，此时只需要处理结果就可以。</p>
</li>
<li><p><strong>回溯函数的递归部分</strong></p>
<p>  递归部分是回溯函数的核心，只有把递归部分写的明白，才算真正懂得了何为“回溯”，所谓回溯就是指在遍历过程中保存的中间结果，在之后的遍历时仍然需要，那么就需要保存起来，常用的方法是使用<code>path</code>数组保存起来，遍历到当前节点时，将节点信息保存至<code>path</code>中，遍历后，在将最后一个保存的信息弹出，这样<code>path</code>中最后保存的就是前一个节点的信息。递归部分的伪代码：</p>
<pre><code>  for(int i = startIndex; i &lt; size; i++)&#123;
      处理节点
      path.push_back(当前节点)
      backtracking(i + 1, 其他参数)；
      path.pop_back(); // 回溯
  &#125;
</code></pre>
</li>
</ul>
<h1 id="2-回溯问题中的去重技巧"><a href="#2-回溯问题中的去重技巧" class="headerlink" title="2. 回溯问题中的去重技巧"></a>2. 回溯问题中的去重技巧</h1><p>在回溯问题中有这样几道题，比如<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combination-sum-ii/">leetcode-&gt;40</a>。这里的要求是解中不能包含重复的组合。我们一下就能想到，把符合题意的解放入<code>unordered_map</code>或者<code>unordered_set</code>中，每次有新的解，就去容器中<code>find</code>一下，如果<code>find</code>的结果等于容器的<code>end()</code>，那么就说明没有重复解，再次加入容器即可。然后理想很丰满，现实很骨感，这样的判断很容易导致超时。那么有什么更好的方法呢？既然在遍历过程中已经对所有情况进行了搜索，何不在搜索过程中就进行重复判断，比如这道题的示例<code>1</code>中，<code>[1,7]</code>和<code>[7,1]</code>都是会被搜索到的，那么怎么判断这两者重复了呢？答案就是排序，排完序后都是<code>[1,7]</code>。排序也分为两种情况，第一种是找到答案后再排序，这样无疑复杂度会很高，并且还是需要对结果进行判重，需要用到<code>unordered_map</code>或者<code>unordered_set</code>。第二种则是对初始数组进行排序，这样原数组就变成了<code>[1,1,2,5,6,7,10]</code>，在搜索过程中会遇到两次<code>[1,7]</code>,那么只需要判断：如果当前节点是否和前一个节点相同，并且在前一个节点使用过，那么当前节点就不能使用。此时可以利用一个<code>vector&lt;bool&gt; used</code>来保存每个节点的使用状态，要注意的是，判重是在同一层进行的，不同层之间<code>used</code>是不影响的。我们用一个例子来画一下树状图，比如<code>nums = [1,1,2]，target = 3</code></p>


<p>总体代码如下：</p>
<pre><code>class Solution &#123;
private:
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;

    void backtracking(int target, const vector&lt;int&gt;&amp; candidates, int startIndex, vector&lt;bool&gt; used)&#123;
        int sum = 0;
        for(int j = 0; j &lt; path.size(); j++)&#123;
            sum += path[j];
        &#125;   
        if(sum == target)&#123;
            result.push_back(path);
            return;
        &#125;else if(sum &gt; target)return ; // 剪枝

        for(int i = startIndex; i &lt; candidates.size(); i++)&#123;
            if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false)&#123; // 判重
                continue;
            &#125;
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(target, candidates, i + 1, used);
            used[i] = false; // 回溯
            path.pop_back(); // 回溯
        &#125;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123;
        result.clear();
        path.clear();
        vector&lt;bool&gt; used(candidates.size(), false);
        sort(candidates.begin(), candidates.end()); // 记住要排序
        backtracking(target, candidates, 0, used);
        return result;
    &#125;
&#125;;
</code></pre>
<p>当然，这里还有优化的空间，比如在递归调用中，每次进入下一层之后才会计算<code>path</code>的和，我们可以将<code>sum</code>放入<code>backtracking</code>的参数中，在进入下一层之前计算当前<code>sum + candidates[i]</code>的和是否大于<code>target</code>，如果大于的话就<code>break</code>，可以减少递归调用。</p>
<h1 id="3-去重问题的特殊情况"><a href="#3-去重问题的特殊情况" class="headerlink" title="3. 去重问题的特殊情况"></a>3. 去重问题的特殊情况</h1><p>下面我们来看一下<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-subsequences/">leetcode-&gt;491</a>，这道题需要找到数组中不同的递增子序列。这就说明我们不能对原数组进行排序。那么就会给判重增加一定的难度，但是想到使用<code>map</code>和<code>set</code>增加的复杂度，我们依然使用在搜索过程中进行判重的方法。在示例1的搜索过程中，会依次遍历到<code>[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[4,7]</code>，这里就产生了重复，我们画一下抽象树性图：</p>


<p>此时可以看到，导致重复的原因是同一层内出现了重复的元素，那么判重方法就是在同一层内判断当前节点的值是否和之前的<strong>所有值</strong>有相同情况出现。简单的增加一个判重函数即可。</p>
<pre><code>//判断从[startIndex, i)内有没有和nums[i]相等的元素，有就判定为重复
    bool isRepeat(const vector&lt;int&gt;&amp; nums, int start, int end)&#123;
        for(int i = start;i &lt; end; i++)&#123;
            if(nums[i] == nums[end])return false;
        &#125;
        return true;
    &#125;
</code></pre>
<p>其中start是递归for循环中startIndex的位置，end为递归for循环中i的位置。这样判重就可以方便的降低复杂度，避免了map和set的使用。</p>
<p>总体代码如下：</p>
<pre><code>class Solution &#123;
    vector&lt;vector&lt;int&gt;&gt; result;
    vector&lt;int&gt; path;
    void backtracking(const vector&lt;int&gt;&amp; nums, int startIndex)&#123;
        if(path.size() &gt;= 2)&#123; // path中至少存了2两个数就可以放入result中了
            result.push_back(path); // 并且由于需要遍历所以不需要return
        &#125;
        for(int i = startIndex; i &lt; nums.size(); i++)&#123;
            //如果 i 不等于 startIndex 并且重复，那么就跳过当前值
            if(i != startIndex &amp;&amp; !isRepeat(nums, startIndex, i))continue;
            if(startIndex == 0 || nums[i] &gt;= path.back())&#123; // 第一个数和满足条件的数要放入
                path.push_back(nums[i]);
                backtracking(nums, i + 1);
                path.pop_back();
        &#125;
        &#125;   
    &#125;
    //判断从[startIndex, i)内有没有和nums[i]相等的元素，有就判定为重复
    bool isRepeat(const vector&lt;int&gt;&amp; nums, int start, int end)&#123;
        for(int i = start;i &lt; end; i++)&#123;
            if(nums[i] == nums[end])return false;
        &#125;
        return true;
    &#125;
public:
    vector&lt;vector&lt;int&gt;&gt; findSubsequences(vector&lt;int&gt;&amp; nums) &#123;
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    &#125;
&#125;;
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/17/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/17/%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/" class="post-title-link" itemprop="url">拷贝构造和拷贝赋值</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-17 16:08:26 / 修改时间：18:19:19" itemprop="dateCreated datePublished" datetime="2022-03-17T16:08:26+08:00">2022-03-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-拷贝构造函数"><a href="#1-拷贝构造函数" class="headerlink" title="1. 拷贝构造函数"></a>1. 拷贝构造函数</h1><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。例如我们有如下类框架：</p>
<pre><code>class HasPtr&#123;
public:
    HasPtr(const std::string &amp;s = std::string()):
        ps(new std::string(s)), i(0) &#123; &#125;
    
    //拷贝构造函数，其中动态分配了一个新的string，并将对象拷贝到ps指向的位置
    //这里涉及到string的new构造方法，即动态创建一个堆内存，该内存保存hp.ps保存的值，并将ps设置为指向当前新开辟内存，这样就不会出现当前对象的ps和传入的参数同时指向一个内存地址的情况
    HasPtr(const HasPtr&amp; hp):
        ps(new std::string(*hp.ps)), i(hp.i) &#123;&#125;
private:
    std::string *ps;
    int i;
&#125;
</code></pre>
<p>拷贝构造函数在很多情况下都会被隐式使用，所以其不应该是<code>explicit</code>的。同时，其第一个参数必须是引用类型，否则其调用永远不会成功。假设该参数不是引用，而是传值参数，</p>
<pre><code>HasPtr(const HasPtr hp):   
</code></pre>
<p>那么拷贝构造时</p>
<pre><code>HasPtr hp1;
HasPtr hp2(hp1); //拷贝构造
</code></pre>
<p>此时<code>hp1</code>是实参，将会传值给形参<code>hp</code>，而此时相当于调用<code>HasPtr hp(hp1)</code>，此时编译器又会调用类的拷贝构造函数，导致这一过程无限继续下去，使得调用无法成功。</p>
<p>拷贝构造会在以下情况发生：</p>
<ul>
<li>拷贝初始化（用<code>=</code>初始化变量）</li>
<li>将一个对象作为实参传递给一个非引用类型的形参</li>
<li>从一个返回类型为非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
<li>某些类类型还会对它们所分配的对象使用拷贝初始化，例如初始化标准库容器或者调用其<code>insert</code>和<code>push</code>成员时。（与之相对的是，用<code>emplace</code>创建的元素都进行直接初始化）。</li>
</ul>
<h1 id="2-拷贝赋值运算符"><a href="#2-拷贝赋值运算符" class="headerlink" title="2. 拷贝赋值运算符"></a>2. 拷贝赋值运算符</h1><p>与类控制其对象如何初始化一样，类也可以控制其对象如何赋值。</p>
<pre><code>HasPtr hp1, hp2;
hp1 = hp2; //使用拷贝赋值运算符
</code></pre>
<p>为了实现自定义的拷贝赋值运算符，我们需要重载赋值运算符，其本质上就是一个函数，接受一个与其所在类相同类型的参数，如下形式：</p>
<pre><code>class HasPtr &#123;
public:
    HasPtr(const std::string &amp;s = std::string()) : ps(new std::string(s)), i(0) &#123; &#125;
    HasPtr(const HasPtr &amp;hp) : ps(new std::string(*hp.ps)), i(hp.i) &#123; &#125;

    //重载赋值运算符实现拷贝赋值运算符，返回引用
    HasPtr&amp; operator=(const HasPtr &amp;rhs_hp) &#123;
        if(this != &amp;rhs_hp)&#123;
            //在堆上新开辟内存，保存hp.ps的内容，并返回一个指向当前位置的指针
            std::string *temp_ps = new std::string(*rhs_hp.ps);
            delete ps; //这里销毁了ps指向的内存，而ps指针还存在
            ps = temp_ps; //将当前对象的ps设置为temp_ps
            i = rhs_hp.i;
        &#125;
        return *this; //返回自身类类型的引用
    &#125;
private:
    std::string *ps;
    int i;
&#125;;
</code></pre>
<p><strong>为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。</strong></p>
<h1 id="3-合成拷贝构造函数"><a href="#3-合成拷贝构造函数" class="headerlink" title="3. 合成拷贝构造函数"></a>3. 合成拷贝构造函数</h1><p>如果我们没有为一个类定义拷贝构造函数，编译器就会为我们定义一个，称为合成拷贝构造函数。一般情况下，它的作用是将其参数给定的对象中每个非<code>static</code>成员逐个拷贝到正在创建的对象中。那么我们就可以理解直接初始化和拷贝初始化的差异了。（拷贝初始化是指使用<code>=</code>进行的初始化）。</p>
<pre><code>string dots(10, &#39;.&#39;);  //直接初始化
string s(dots);        //直接初始化
string s2 = dots;      //拷贝初始化
string null_book = &quot;9-99-999-99&quot;; //拷贝初始化
string nines = string(100, &#39;9&#39;);  //拷贝初始化
</code></pre>
<p>使用直接初始化时，实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当使用拷贝初始化时，要求编译器将右侧运算对象拷贝到正在创建的对象中，必要的化还要进行类型转换。拷贝初始化一般情况下使用拷贝构造函数来完成，在之后的章节会介绍移动构造函数，会更方便的进行拷贝构造。</p>
<h1 id="4-合成拷贝赋值运算符"><a href="#4-合成拷贝赋值运算符" class="headerlink" title="4. 合成拷贝赋值运算符"></a>4. 合成拷贝赋值运算符</h1><p>如果我们没有为一个类定义拷贝赋值运算符，编译器就会为我们定义一个，称为合成拷贝赋值运算符。它会将右侧对象的每个非static成员赋予左侧运算对象的对应成员，对于数组成员，逐个赋值数组元素。最终返回一个指向左侧运算对象的引用。</p>
<h1 id="5-注意事项"><a href="#5-注意事项" class="headerlink" title="5. 注意事项"></a>5. 注意事项</h1><ul>
<li>某些情况下，合成拷贝构造函数和合成拷贝赋值运算符的作用是禁止该类型对象的构造和赋值。这时候是因为我们定义的类并不需要拷贝、赋值或者销毁其成员。这里参考<code>13.1.6</code>章节的阻止拷贝章节。</li>
<li>对于使用<code>shared_ptr</code>控制的对象类型，拷贝构造和拷贝赋值会增加<code>count</code>次数，而<code>weak_ptr</code>则不会。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">背包问题入门</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-15 20:15:38 / 修改时间：21:22:14" itemprop="dateCreated datePublished" datetime="2022-03-15T20:15:38+08:00">2022-03-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-什么是背包"><a href="#1-什么是背包" class="headerlink" title="1.什么是背包"></a>1.什么是背包</h1><p>背包问题是动态规划部分的经典题型。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。 一般来讲，背包问题有以下几种分类：</p>
<p><strong>1. 01背包问题</strong><br><strong>2. 完全背包问题</strong><br><strong>3. 多重背包问题</strong></p>
<p>在leetcode刷题过程中，我们需要掌握这几种背包问题的写法。要注意的是，有些题目并不会直接告诉你这是一道背包问题，而是需要我们利用发散思维将问题转换为背包问题，以此来找到解题方法。</p>
<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="1-题目"><a href="#1-题目" class="headerlink" title="1.题目"></a>1.题目</h2><p>最基本的背包问题就是01背包问题（<strong>01 knapsack problem</strong>）：一共有<code>N</code>件物品，第<code>i</code>（<code>i</code>从1开始）件物品的重量为<code>w[i]</code>，价值为<code>v[i]</code>。在总重量不超过背包承载上限<code>W</code>的情况下，能够装入背包的最大价值是多少？</p>
<p>我们的目标是书包内物品的总价值，而变量是物品和书包的限重，所以我们可定义状态<code>dp</code>，首先使用二维数组来表示<code>dp</code>过程：</p>
<pre><code>dp[i][j]表示将前i件物品装进最大容量为j的背包所获得的最大价值，0 &lt;= i &lt;= N, 0 &lt;= j &lt;= W
</code></pre>
<p>此时根据<code>dp</code>表示的含义，自然而然<code>dp[0][j]</code>为0，因为此时并未装进物品。此时当<code>i &gt; 0</code>时，有两种情况：</p>
<ol>
<li>不装第<code>i</code>件物品，即<code>dp[i][j] = dp[i - 1][j]</code></li>
<li>装入第<code>i</code>件物品（前提是剩余容量能装下），即<code>dp[i][j] = dp[i - 1][j - w[i]] + v[i]</code></li>
</ol>
<p>那么由此得到状态转移方程：</p>
<pre><code>dp[i][j] = max(dp[i − 1][j], dp[i − 1][j − w[i]] + v[i]) // j &gt;= w[i]
</code></pre>
<p>完整代码如下：</p>
<pre><code>for(int i = 1; i &lt; w.size(); i++) &#123; // 遍历物品
    for(int j = 0; j &lt;= bagweight; j++) &#123; // 遍历背包容量
        if (j &lt; w[i]) dp[i][j] = dp[i - 1][j]; 
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]);
    &#125;
&#125;
</code></pre>
<p>此时先遍历的是物品，再遍历背包容量，反之也是可以的，这里注意到<code>j</code>的遍历是正向的，因为下一层使用的是上一层的状态，具体而言，需要的是左上角的信息。</p>
<p>上述状态转移方程可知，<code>dp[i][j]</code>的值只与<code>dp[i - 1][j]</code>有关，所以我们使用动态规划常用的方法（滚动数组）来对空间复杂度进行优化，需要满足的条件是上一层可以重复利用，直接拷贝到当前层。此时<code>dp[j]</code>表示容量为<code>j</code>的背包，所装的物品最大价值。同理可得到状态转移方程：</p>
<pre><code>dp[j] = max(dp[j], dp[j - w[i]] + v[i])
</code></pre>
<p>初始化时，将<code>dp[i]</code>全部初始化为<code>0</code>.完整代码如下：</p>
<pre><code>for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品
    for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    &#125;
&#125;
</code></pre>
<p>这里我们发现，j的遍历顺序是逆序的。原因是：如果是正向计算，那么会出现状态重合的情况，例如下面的例子：背包容量为4，物品属性如下：</p>
<table>
<thead>
<tr>
<th>物品重量</th>
<th>物品价值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>4</td>
<td>30</td>
</tr>
</tbody></table>
<p>此时<code>dp[1] = 15, dp[2] = dp[2 - w[0]] + v[0] = d[1] + 15 = 30</code>。可以注意到这里<code>dp[2]</code>恰巧用到了<code>dp[1]</code>的数据，也就是说此时第一个物品被装了两次。那么为了避免这种情况，我们就需要对<code>j</code>进行逆序遍历，这样用到前面的数据时，前面的数据还没有被遍历到，其状态是0，模拟的就是一件物品只能被装进去一次。同时，<code>i</code>和<code>j</code>的遍历顺序也不能交换，如果<code>j</code>放在外层，那么遍历的结果是背包只放了一件物品。</p>
<p>完整的代码如下：</p>
<pre><code>void test_1_wei_bag_problem() &#123;
    vector&lt;int&gt; weight = &#123;1, 3, 4&#125;;
    vector&lt;int&gt; value = &#123;15, 20, 30&#125;;
    int bagWeight = 4;

    // 初始化
    vector&lt;int&gt; dp(bagWeight + 1, 0);
    for(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品
        for(int j = bagWeight; j &gt;= weight[i]; j--) &#123; // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        &#125;
    &#125;
    cout &lt;&lt; dp[bagWeight] &lt;&lt; endl;
&#125;

int main() &#123;
    test_1_wei_bag_problem();
&#125;
</code></pre>
<p>学习完以上的知识，就可以试着做一做leetcode的416和1049题，这两道题是经典的可以转化为背包问题的题目。下一篇博客将总结多重背包问题。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%AD%E6%9E%84%E9%80%A0%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E4%B8%AD%E6%9E%84%E9%80%A0%E5%89%8D%E5%90%8E%E6%8C%87%E9%92%88/" class="post-title-link" itemprop="url">二叉树遍历中构造前后指针</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-03-11 19:41:47 / 修改时间：20:14:11" itemprop="dateCreated datePublished" datetime="2022-03-11T19:41:47+08:00">2022-03-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1-何为前后指针"><a href="#1-何为前后指针" class="headerlink" title="1. 何为前后指针"></a>1. 何为前后指针</h1><p>在二叉树的一些题目中，需要我们记录前后两个相邻节点各自的信息（尤其是在二叉搜索树中经常出现，比如501和530，那么常用的技巧就是在遍历过程中设置两个指针，分别指向这两个相邻节点，在处理之后，将前一个指针指向当前节点，当前指针指向下一个节点。</p>
<h1 id="2-递归中构造前后指针"><a href="#2-递归中构造前后指针" class="headerlink" title="2. 递归中构造前后指针"></a>2. 递归中构造前后指针</h1><pre><code>class Solution&#123;
    private:
        TreeNode* pre;
        void traversal(TreeNode* cur)&#123;
            if(cur == NULL)return;
            traversal(cur-&gt;left); //左
            if(pre != NULL)&#123; //中
                //处理cur和pre
            &#125;
            pre = cur; //将前一个指针指向当前节点
            traversal(cur-&gt;right); //右
        &#125;
    public:
        TreeNode* getMinimumDifference(TreeNode* root)&#123;
            traversal(root);
            return root;
        &#125;
&#125;
</code></pre>
<p>这里使用的是前序遍历，实际中根据需要自行修改即可。</p>
<h1 id="3-迭代中构造前后指针"><a href="#3-迭代中构造前后指针" class="headerlink" title="3. 迭代中构造前后指针"></a>3. 迭代中构造前后指针</h1><pre><code>class Solution&#123;
    public:
        TreeNode* getMinimumDifference(TreeNode* root)&#123;
            stack&lt;TreeNode*&gt; stk;
            if(root == NULL)return root;
            TreeNode* pre = NULL;
            TreeNode* cur = root;
            while(!stk.empty() || cur != NULL)&#123;
                if(cur != NULL)&#123;
                    stk.push(cur);
                    cur = cur-&gt;left; //左
                &#125;else&#123;
                    cur = stk.top();
                    stk.pop();
                    if(pre == NULL)&#123;
                        //此时cur指向初始节点（最左下或者最右下）
                    &#125;
                    if(pre != NULL)&#123;
                        //处理pre和cur
                    &#125;
                    pre = cur; //前一个指针指向当前节点
                    cur = cur-&gt;right; //这里和上面对应，上面始终遍历左侧，则这里等于右子节点
                &#125;
            &#125;
            return root;
        &#125;
&#125;
</code></pre>
<p>相比较递归中的前后指针构造，我个人更熟悉迭代法中构造前后指针。在二叉搜索树中这样的处理方式很常见，需要慢慢体会这样的写法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gaotf</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
