<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="第三章 第一节 数据类型与类型检查数据类型及其表达基本数据类型对象数据结构  对象：对象是类的一个实例，有状态和行为 类：类是一个模板，它描述一类对象的行为和状态 Java作为一种面向对象语言，支持多态、继承、封装、抽象、重载等概念  包装类 类型检查动态检查：关于“值”的检查  bug在运行中被发现 倾向于检查特定值才出发的错误 动态分析检查的类型： 非法的变量值。例如整型变量x、y，表达式x&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="软件构造知识点总结 - 2">
<meta property="og:url" content="http://example.com/2019/05/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%202/index.html">
<meta property="og:site_name" content="漱石斋笔谈">
<meta property="og:description" content="第三章 第一节 数据类型与类型检查数据类型及其表达基本数据类型对象数据结构  对象：对象是类的一个实例，有状态和行为 类：类是一个模板，它描述一类对象的行为和状态 Java作为一种面向对象语言，支持多态、继承、封装、抽象、重载等概念  包装类 类型检查动态检查：关于“值”的检查  bug在运行中被发现 倾向于检查特定值才出发的错误 动态分析检查的类型： 非法的变量值。例如整型变量x、y，表达式x&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604205243278-1512350415.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604210551887-1733274652.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604212242139-1846422204.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604212302571-1426216850.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604212327839-789247230.png">
<meta property="article:published_time" content="2019-05-19T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-26T02:47:27.895Z">
<meta property="article:author" content="gaotf">
<meta property="article:tag" content="本科文档">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604205243278-1512350415.png">


<link rel="canonical" href="http://example.com/2019/05/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%202/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2019/05/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%202/","path":"2019/05/20/软件构造知识点总结 - 2/","title":"软件构造知识点总结 - 2"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>软件构造知识点总结 - 2 | 漱石斋笔谈</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">漱石斋笔谈</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">gaotf 的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="nav-number">1.</span> <span class="nav-text">第三章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="nav-number">1.1.</span> <span class="nav-text">第一节 数据类型与类型检查</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E8%A1%A8%E8%BE%BE"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据类型及其表达</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">基本数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="nav-number">1.1.3.</span> <span class="nav-text">类型检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%80%A7%E5%92%8C%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7"><span class="nav-number">1.1.4.</span> <span class="nav-text">可变性和不可变性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E8%8A%82-%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E5%9E%8B%EF%BC%88ADT%EF%BC%89"><span class="nav-number">1.2.</span> <span class="nav-text">第三节 抽象数据型（ADT）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ADT%E5%8F%8A%E5%85%B6%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">ADT及其四种类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E7%8B%AC%E7%AB%8B%E6%80%A7"><span class="nav-number">1.2.2.</span> <span class="nav-text">表示独立性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%98%E9%87%8F%EF%BC%88Invariants%EF%BC%89%E4%B8%8E%E8%A1%A8%E7%A4%BA%E6%B3%84%E9%9C%B2"><span class="nav-number">1.2.3.</span> <span class="nav-text">不变量（Invariants）与表示泄露</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E5%87%BD%E6%95%B0AF%E4%B8%8E%E8%A1%A8%E7%A4%BA%E4%B8%8D%E5%8F%98%E9%87%8FRI"><span class="nav-number">1.2.4.</span> <span class="nav-text">抽象函数AF与表示不变量RI</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E8%8A%82-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8BOOP"><span class="nav-number">1.3.</span> <span class="nav-text">第四节 面向对象编程OOP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OOP%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.3.1.</span> <span class="nav-text">OOP的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OOP%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%B9%E5%BE%81"><span class="nav-number">1.3.2.</span> <span class="nav-text">OOP的不同特征</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E8%8A%82-ADT%E5%92%8COOP%E4%B8%AD%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="nav-number">1.4.</span> <span class="nav-text">第五节 ADT和OOP中的等价性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%89%E4%BB%B7%E6%80%A7equals-%E5%92%8C"><span class="nav-number">1.4.1.</span> <span class="nav-text">等价性equals()和&#x3D;&#x3D;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals-%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.</span> <span class="nav-text">equals()的判断方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode-%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">hashCode()方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%AD%89%E4%BB%B7%E6%80%A7"><span class="nav-number">1.4.3.</span> <span class="nav-text">可变类型的等价性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="nav-number">2.</span> <span class="nav-text">第四章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E8%8A%82-%E9%9D%A2%E5%90%91%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">2.1.</span> <span class="nav-text">第一节 面向可理解性的构造</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7"><span class="nav-number">2.1.1.</span> <span class="nav-text">代码的可理解性</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gaotf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">gaotf</p>
  <div class="site-description" itemprop="description">热爱技术，笔耕不辍</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/1170300619" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1170300619" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3469205806@qq.com" title="E-Mail → 3469205806@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/05/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%202/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="软件构造知识点总结 - 2 | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          软件构造知识点总结 - 2
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-20T00:00:00+08:00">2019-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:47:27" itemprop="dateModified" datetime="2024-04-26T10:47:27+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/" itemprop="url" rel="index"><span itemprop="name">软件构造</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><hr>
<h2 id="第一节-数据类型与类型检查"><a href="#第一节-数据类型与类型检查" class="headerlink" title="第一节 数据类型与类型检查"></a>第一节 数据类型与类型检查</h2><h3 id="数据类型及其表达"><a href="#数据类型及其表达" class="headerlink" title="数据类型及其表达"></a>数据类型及其表达</h3><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a><em>基本数据类型</em></h3><p><strong>对象数据结构</strong></p>
<ul>
<li>对象：对象是类的一个实例，有状态和行为</li>
<li>类：类是一个模板，它描述一类对象的行为和状态</li>
<li>Java作为一种面向对象语言，支持多态、继承、封装、抽象、重载等概念</li>
</ul>
<p><strong>包装类</strong></p>
<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a><em>类型检查</em></h3><p><strong>动态检查：关于“值”的检查</strong></p>
<ul>
<li>bug在运行中被发现</li>
<li>倾向于检查特定值才出发的错误</li>
<li>动态分析检查的类型：<ul>
<li>非法的变量值。例如整型变量x、y，表达式x&#x2F;y 只有在运行后y为0才会报错，否则就是正确的。</li>
<li>非法的返回值。例如最后得到的返回值无法用声明的类型来表明。</li>
<li>越界访问。例如在一个字符串中使用一个负数索引。</li>
<li>空指针，使用一个null 对象解引用。</li>
</ul>
</li>
</ul>
<p><strong>静态检查：关于“类型”的检查</strong></p>
<ul>
<li>静态检查&gt;&gt;动态检查&gt;&gt;无检查</li>
<li>在编译阶段发现错误，避免将错误带入到运行阶段，提高程序的正确性\健壮性</li>
<li>静态分析检查的类型<ul>
<li>语法错误，例如多余的标点符号或者错误的关键词。即使在动态类型的语言例如Python中也会做这种检查：如果你有一个多余的缩进，在运行之前就能发现它</li>
<li>类名\函数名错误，例如<code>Math.sine(2)</code> . (应该是 sin )</li>
<li>参数数目错误，例如<code>Math.sin(30, 20)</code> </li>
<li>参数的型错误<code>Math.sin(&quot;30&quot;)</code> </li>
<li>返回值类型错误 ，例如⼀个声明返回<code>int</code>类型函数<code>return 30</code></li>
</ul>
</li>
</ul>
<h3 id="可变性和不可变性"><a href="#可变性和不可变性" class="headerlink" title="可变性和不可变性"></a><em>可变性和不可变性</em></h3><ul>
<li>改变一个变量：是将该变量指向另一个值得存储空间</li>
<li>改变一个变量的值：是将该变量当前指向的值的存储空间中写入一个新的值</li>
</ul>
<p><strong>不变性（immutability）</strong></p>
<ul>
<li><code>final</code>变量能被显式地初始化并且只能初始化一次。不变数据类型，一旦被创建，值不可修改</li>
<li>基本类型及其封装对象类型都是不可变的</li>
<li>不可变的引用是指一旦指定引用位置后，不可再次指定</li>
<li>如果编译器不能确定<code>final</code>变量不会改变，就提示错误，这也是静态类型检查的一部分</li>
<li>注意：<ul>
<li>final类无法派生子类</li>
<li>final变量无法改变值&#x2F;引用</li>
<li>final方法无法被子类重写</li>
</ul>
</li>
</ul>
<p><strong>可变性（mutability）</strong></p>
<ul>
<li><p>不变对象：一旦被创建，始终指向同个值&#x2F;引用 </p>
</li>
<li><p>可变对象：拥有方法以修改自己的值&#x2F;引用</p>
</li>
<li><p><code>String</code>与<code>StringBuilder</code></p>
<ul>
<li><p><code>String</code>：不可变数据类型，在修改时必须创建一个新的<code>String</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">a = s + <span class="string">&quot;b&quot;</span>;<span class="comment">//s = s.concat(&quot;b&quot;);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>StringBuilder</code>：可改变的数据类型，可以直接修改对象的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>可变性与不可变性的优缺点</strong></p>
<ul>
<li>可变数据类型最小化的拷贝以提高效率；使用不可变类型，对其频繁修改会产生大量的临时拷贝 （需要垃圾回收）</li>
<li>可变数据类型，可获得更好的效能</li>
<li>可变数据类型也适合在多个模块之间共享数据</li>
<li>不可变数据类型更安全，更易于理解，也更方便改变</li>
</ul>
<p><strong>防御性拷贝</strong></p>
<ul>
<li><p>如果一个方法或构造函数允许可变对象进&#x2F;出，那么就要考虑一下使用者是否有可能改变它。如果是的话，那你必须对该对象进行保护性拷贝，使进入方法内部的对象是外部时的拷贝而不它本身（因为外部的对象有可能还会被改变）。</p>
</li>
<li><pre><code class="java">public Date getEnd() &#123;  
     return new Date(end.getTime());  
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 第二节 设计规约</span><br><span class="line"></span><br><span class="line">### *什么是设计规约*</span><br><span class="line"></span><br><span class="line">-   为什么要有设计规约</span><br><span class="line">    -   很多bug来自于双方之间的误解；没有规约，那么不同开发者的理解就可能不同</span><br><span class="line">    -   代码惯例增加了软件包的可读性，使工程师们更快、更完整的理解软件</span><br><span class="line">    -   可以帮助程序员养成良好的编程习惯，提高代码质量</span><br><span class="line">    -   没有规约，难以定位错误</span><br><span class="line">-   使用设计规约的好处</span><br><span class="line">    -   规约起到了契约的作用。代表着程序与客户端之间达成的一致；客户端无需阅读调用函数的代码，只需理解spec即可</span><br><span class="line">    -   精确的规约，有助于区分责任，给“供需双方”确定了责任，在调用的时候双方都要遵守</span><br><span class="line">    -   规约可以隔离“变化”，无需通知客户端</span><br><span class="line">    -   规约也可以提高代码效率</span><br><span class="line"></span><br><span class="line">### 行为等价性</span><br><span class="line"></span><br><span class="line">行为等价性就是站在客户端的角度考量两个方法是否可以互换。</span><br><span class="line"></span><br><span class="line">-   另外，我们也可以根据规约判断是否行为等价注：规约与实现无关，规范无需讨论方法类的局部变量或方法类的私有字段。</span><br><span class="line"></span><br><span class="line">-   两个函数附和同一个规约，故二者等价</span><br><span class="line"></span><br><span class="line">### *规约的结构：前置条件与后置条件*</span><br><span class="line"></span><br><span class="line">**规约的结构**</span><br><span class="line"></span><br><span class="line">-    一个方法的规约常由以下几个短句组成契约：如果前置条件满足了，后置条件必须满足。如果没有满足，将产生不确定的异常行为</span><br><span class="line">    -   前置条件(precondition)：对客户端的约束，在使用方法时必须满足的条件。由关键字 **requires**表示；</span><br><span class="line">    -   后置条件(postcondition)：对开发者的约束，方法结束时必须满足的条件。由关键字 **effects**表示</span><br><span class="line">    -   异常行为(Exceptional behavior)：如果前置条件被违背，会发生什么</span><br><span class="line"></span><br><span class="line">-   静态类型声明是一种规约，可据此进行静态类型检查。 </span><br><span class="line">-   方法前的注释也是一种规约，但需人工判定其是否满足。</span><br><span class="line">    -   参数由@param 描述</span><br><span class="line">    -   子句和结果用 @return 和 @ throws子句 描述</span><br><span class="line">    -   尽可能的将前置条件放在 @param 中</span><br><span class="line">    -   尽可能的将后置条件放在 @return 和 @throws 中</span><br><span class="line"></span><br><span class="line">**mutating methods（可变方法）的规约**</span><br><span class="line"></span><br><span class="line">-   除非在后置条件里声明过，否则方法内部不应该改变输入参数</span><br><span class="line">-   应尽量遵循此规则，尽量不设计mutating的spec，否则就容易引发bugs </span><br><span class="line">-   程序员之间应达成的默契：除非spec必须如此，否则不应修改输入参数</span><br><span class="line">-   尽量避免使用可变(mutable)的对象</span><br><span class="line">    -   对可变对象的多引用，需要程序维护一致性，此时合同不再是单纯的在用户和实现者之间维持，需要每一个引用者都有良好的习惯，这就使得简单的程序变得复杂</span><br><span class="line">    -   可变对象使得程序难以理解，也难以保证正确性</span><br><span class="line">    -   可变数据类型还会导致程序修改变得异常困难 </span><br><span class="line"></span><br><span class="line">### *规约的评价*</span><br><span class="line"></span><br><span class="line">**规约评价的三个标准**</span><br><span class="line"></span><br><span class="line">-   规约的确定性</span><br><span class="line">-   规约的陈述性</span><br><span class="line">-   规约的强度</span><br><span class="line"></span><br><span class="line">**规约的确定性**</span><br><span class="line"></span><br><span class="line">　　确定的规约：给定一个满足前置条件的输入，其输出是唯一的、明确的。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static int findExactlyOne(int[] arr, int val)</span><br><span class="line">    \\ requires: val occurs exactly once in arr</span><br><span class="line">    \\ effects:  returns index i such that arr[i] = val</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>　　欠定的规约：同一个输入可以有多个输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findOneOrMoreAnyIndex</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> val)</span></span><br><span class="line">    \\ <span class="keyword">requires</span>: val occurs in arr</span><br><span class="line">    \\ effects:  returns index i such that arr[i] = val</span><br></pre></td></tr></table></figure>

<p>　　未确定的规约：同一个输入，多次执行时得到的输出可能不同；但为了避免分歧，我们通常将不是确定的spec统一定义为欠定的规约。</p>
<p><strong>规约的陈述性</strong></p>
<ul>
<li>操作式规约（Operational specs）：伪代码 。 </li>
<li>声明式规约（Declarative specs）：没有内部实现的描述，只有 “初&#x2F;终”状态 。 </li>
<li>声明式规约更有价值；内部实现的细节不在规约里呈现，而放在代码实现体内部注释里呈现。</li>
</ul>
<p><strong>规约的强度</strong></p>
<ul>
<li>通过比较规约的强度来判断是否可以用一个规约替换另一个；</li>
<li>如果规约的强度$S2 \ge S1$，就可以用$S2$代替$S1$，体现有二：一个更强的规约包括更轻松的前置条件和更严格的后置条件；越强的规约，意味着实现者(implementor)的自由度和责任越重，而客户(client)的责任越轻。<ul>
<li>$S2$的前置条件更弱</li>
<li>$S2$的后置条件更强</li>
</ul>
</li>
</ul>
<p><em><strong>examples</strong></em></p>
<ul>
<li>Original spec：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findExactlyOne</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> val)</span></span><br><span class="line"><span class="number">2</span>   \\ <span class="keyword">requires</span>: val occurs exactly once in a</span><br><span class="line"><span class="number">3</span>   \\ effects:  returns index i such that a[i] = val</span><br></pre></td></tr></table></figure>

<ul>
<li>A stronger spec:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findOneOrMoreAnyIndex</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> val)</span></span><br><span class="line"><span class="number">2</span>   \\ <span class="keyword">requires</span>: val occurs at least once in a</span><br><span class="line"><span class="number">3</span>   \\ effects:  returns index i such that a[i] = val</span><br></pre></td></tr></table></figure>

<ul>
<li>A much stronger spec:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findOneOrMoreFirstIndex</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> val)</span></span><br><span class="line"><span class="number">2</span>   \\ <span class="keyword">requires</span>: val occurs at least once in a</span><br><span class="line"><span class="number">3</span>   \\ effects:  returns lowest index i such that a[i] = val</span><br></pre></td></tr></table></figure>

<p><strong>如何设计一个好的规约</strong></p>
<ul>
<li>规约应该是简洁的：整洁，具有良好的结构，易于理解。</li>
<li>规约应该是内聚的：spec描述的功能应单一、简单、易理解。</li>
<li>规约应该是信息丰富的：不能让客户端产生理解的歧义。</li>
<li>规约应该是强度足够的：需要满足客户端基本需求，也必须考虑特殊情况。</li>
<li>规约的强度也不能太强：太强的spec，在很多特殊情况下难以达到。</li>
<li>规约应该使用抽象类型：在规约里使用抽象类型，可以给方法的实现体与客户端更大的自由度。</li>
</ul>
<p><strong>是否使用前置条件</strong></p>
<ul>
<li>是否使用前置条件取决于如果只在类的内部使用该方法(<code>private</code>)，那么可以不使用前置条件，在使用该方法的各个位置进行check——责任交给内部client。<ul>
<li>check的代价</li>
<li>方法的使用范围</li>
</ul>
</li>
<li>如果在其他地方使用该方法(<code>public</code>)，那么必须要使用前置条件，若client端不满足则方法抛出异常。</li>
</ul>
<h2 id="第三节-抽象数据型（ADT）"><a href="#第三节-抽象数据型（ADT）" class="headerlink" title="第三节 抽象数据型（ADT）"></a>第三节 抽象数据型（ADT）</h2><h3 id="ADT及其四种类型"><a href="#ADT及其四种类型" class="headerlink" title="ADT及其四种类型"></a><em>ADT及其四种类型</em></h3><p><strong>ADT的基本概念</strong></p>
<ul>
<li>抽象数据类型（Abstract Data Type，ADT）是是指一个数学模型以及定义在该模型上的一组操作；即包括数据数据元素，数据关系以及相关的操作。</li>
<li>ADT具有以下几个能表达抽象思想的词：<ul>
<li>抽象化：用更简单、更高级的思想省略或隐藏低级细节。</li>
<li>模块化： 将系统划分为组件或模块，每个组件可以设计，实施，测试，推理和重用，与系统其余部分分开使用。</li>
<li>封装：围绕模块构建墙，以便模块负责自身的内部行为，并且系统其他部分的错误不会损坏其完整性。</li>
<li>信息隐藏： 从系统其余部分隐藏模块实现的细节，以便稍后可以更改这些细节，而无需更改系统的其他部分。</li>
<li>关注点分离： 一个功能只是单个模块的责任，而不跨越多个模块。</li>
</ul>
</li>
<li>与传统类型定义的差别：<ul>
<li>传统的类型定义：关注数据的具体表示。</li>
<li>抽象类型：强调“作用于数据上的操作”，程序员和client无需关心数据如何具体存储的，只需设计&#x2F;使用操作即可。</li>
</ul>
</li>
<li>ADT是由操作定义的，与其内部如何实现无关。</li>
</ul>
<p><strong>ADT的四种类型</strong></p>
<p>前置定义：mutable and immutable types</p>
<p>可变类型的对象：提供了可改变其内部数据的值的操作。例如：<code>Date</code></p>
<p>不变数据类型： 其操作不改变内部值，而是构造新的对象。例如：<code>String</code></p>
<ul>
<li>Creators（构造器）：<ul>
<li>创建某个类型的新对象，⼀个创建者可能会接受⼀个对象作为参数，但是这个对象的类型不能是它创建对象对应的类型。可能实现为构造函数或静态函数。（通常称为工厂方法）</li>
<li>$t^* \to T$</li>
<li><em><strong>example</strong></em>：<code>Integer.valueOf()</code></li>
</ul>
</li>
<li>Producers（生产器）：<ul>
<li>通过接受同类型的对象创建新的对象。</li>
<li>$T^+,t^* \to T$</li>
<li><em><strong>example</strong></em>：<code>String.concat()</code></li>
</ul>
</li>
<li>Observers（观察器）：<ul>
<li>获取抽象类型的对象然后返回一个不同类型的对象&#x2F;值。</li>
<li>$T^+ , t^* \to t$</li>
<li><em><strong>example</strong></em>：<code>List.size()</code></li>
</ul>
</li>
<li>Mutators（变值器）：<ul>
<li>改变对象属性的方法 ，</li>
<li>变值器通常返回void，若为void，则必然意味着它改变了对象的某些内部状态；当然，也可能返回非空类型 </li>
<li>$T^+ , t^* \to t||T|| void$</li>
<li><em><strong>example</strong></em>：<code>List.add()</code></li>
</ul>
</li>
<li>解释：$T$是ADT本身；$t$是其他类型；$^+$表示这个类型可能出现一次或多次；$^*$表示可能出现0次或多次。</li>
</ul>
<p><strong>设计一个好的ADT</strong></p>
<p>设计好的ADT，靠“经验法则”，提供一组操作，设计其行为规约 spec。</p>
<ul>
<li>原则 1：设计简洁、一致的操作。<ul>
<li>最好有一些简单的操作，它们可以以强大的方式组合，而不是很多复杂的操作。</li>
<li>每个操作应该有明确的目的，并且应该有一致的行为而不是一连串的特殊情况。</li>
</ul>
</li>
<li>原则 2：要足以支持用户对数据所做的所有操作需要，且用操作满足用户需要的难度要低。<ul>
<li>提供<code>get()</code>操作以获得<code>list</code>内部数据</li>
<li>提供<code>size()</code>操作获取<code>list</code>的长度</li>
</ul>
</li>
<li>原则 3：要么抽象、要么具体，不要混合 —— 要么针对抽象设计，要么针对具体应用的设计。</li>
</ul>
<p><strong>测试ADT</strong></p>
<ul>
<li>测试creators, producers, and mutators：调用observers来观察这些 operations的结果是否满足spec。</li>
<li>测试observers：调用creators, producers, and mutators等方法产生或改变对象，来看结果是否正确。</li>
</ul>
<h3 id="表示独立性"><a href="#表示独立性" class="headerlink" title="表示独立性"></a><em>表示独立性</em></h3><ul>
<li>表示独立性：client使用ADT时无需考虑其内部如何实现，ADT内部表示的变化不应影响外部spec和客户端。</li>
<li>除非ADT的操作指明了具体的前置条件&#x2F;后置条件，否则不能改变ADT的内部表示——spec规定了 client和implementer之间的契约。</li>
</ul>
<h3 id="不变量（Invariants）与表示泄露"><a href="#不变量（Invariants）与表示泄露" class="headerlink" title="不变量（Invariants）与表示泄露"></a><em>不变量（Invariants）与表示泄露</em></h3><p>一个好的抽象数据类型的最重要的属性是它保持不变量。一旦一个不变类型的对象被创建，它总是代表一个不变的值。当一个ADT能够确保它内部的不变量恒定不变（不受使用者&#x2F;外部影响），我们就说这个ADT保护&#x2F;保留自己的不变量。</p>
<h3 id="抽象函数AF与表示不变量RI"><a href="#抽象函数AF与表示不变量RI" class="headerlink" title="抽象函数AF与表示不变量RI"></a><em>抽象函数AF与表示不变量RI</em></h3><p><strong>AF与RI</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604205243278-1512350415.png" alt="img"></p>
<ul>
<li><p>在研究抽象类型的时候，先思考一下两个值域之间的关系：</p>
<ul>
<li>表示域（rep values）里面<strong>包含的是值具体的实现实体</strong>。一般情况下ADT的表示比较简单，有些时候需要复杂表示。 </li>
<li>抽象域（A）里面包含的则是类型设计时支持使用的值。<strong>这些值是由表示域“抽象&#x2F;想象”出来的，也是使用者关注的。</strong></li>
</ul>
</li>
<li><p>ADT实现者关注表示空间R，用户关注抽象空间A 。</p>
</li>
<li><p>$R \to A$的映射特点：</p>
<ul>
<li><strong>每一个抽象值都是由表示值映射而来</strong> ，即满射：每个抽象值被映射到一些rep值</li>
<li><strong>一些抽象值是被多个表示值映射而来的</strong>，即未必单射：一些抽象值被映射到多个rep值</li>
<li><strong>不是所有的表示值都能映射到抽象域中</strong>，即未必双射：并非所有的rep值都被映射。</li>
</ul>
</li>
<li><p>抽象函数（AF）：R和A之间映射关系的函数</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AF : R → A</span><br></pre></td></tr></table></figure>

<ul>
<li>表示不变量（RI）：将rep值映射到布尔值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RI : R → boolean</span><br></pre></td></tr></table></figure>

<ul>
<li>对于表示值r，当且仅当$r$被$AF$映射到了A，$RI(r)$为真</li>
<li>表示不变性RI：某个具体的“表示”是否是“合法的”</li>
<li>也可将RI看作：所有表示值的一个子集，包含了所有合法的表示值</li>
<li>也可将RI看作：一个条件，描述了什么是“合法”的表示值</li>
<li>在下图中，绿色表示的就是$RI(r)$为真的部分，$AF$只在这个子集上有定义。</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604210551887-1733274652.png" alt="img"></p>
<ul>
<li>表示不变量和抽象函数都应该记录在代码中，就在代表本身的声明旁边，以下图为例</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604212242139-1846422204.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="comment">// Rep invariant:</span></span><br><span class="line">    <span class="comment">//   s contains no repeated characters</span></span><br><span class="line">    <span class="comment">// Abstraction function:</span></span><br><span class="line">    <span class="comment">//   AF(s) = &#123;s[i] | 0 &lt;= i &lt; s.length()&#125;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604212302571-1426216850.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="comment">// Rep invariant:</span></span><br><span class="line">    <span class="comment">//   s[0] &lt;= s[1] &lt;= ... &lt;= s[s.length()-1]</span></span><br><span class="line">    <span class="comment">// Abstraction function:</span></span><br><span class="line">    <span class="comment">//   AF(s) = &#123;s[i] | 0 &lt;= i &lt; s.length()&#125;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images2018.cnblogs.com/blog/1336655/201806/1336655-20180604212327839-789247230.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharSet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String s;</span><br><span class="line">    <span class="comment">// Rep invariant:</span></span><br><span class="line">    <span class="comment">//   s.length() is even</span></span><br><span class="line">    <span class="comment">//   s[0] &lt;= s[1] &lt;= ... &lt;= s[s.length()-1]</span></span><br><span class="line">    <span class="comment">// Abstraction function:</span></span><br><span class="line">    <span class="comment">//   AF(s) = union of &#123;s[2i],...,s[2i+1]&#125; for 0 &lt;= i &lt; s.length()/2</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用注释写AF和RI</strong></p>
<ul>
<li>在抽象类型（私有的）表示声明后写上对于抽象函数和表示不变量的注解，这是一个好的实践要求。我们在上面的例子中也是这么做的。</li>
<li>在描述抽象函数和表示不变量的时候，注意要清晰明确：<ul>
<li>对于RI（表示不变量），仅仅宽泛的说什么区域是合法的并不够，你还应该说明是什么使得它合法&#x2F;不合法。</li>
<li>对于AF（抽象函数）来说，仅仅宽泛的说抽象域表示了什么并不够。抽象函数的作用是规定合法的表示值会如何被解释到抽象域。作为一个函数，我们应该清晰的知道从一个输入到一个输入是怎么对应的。</li>
</ul>
</li>
<li>本门课程还要求你将<strong>表示暴露的安全性</strong>注释出来。这种注释应该说明表示的每一部分，它们为什么不会发生表示暴露，特别是处理的表示的参数输入和返回部分（这也是表示暴露发生的位置）。</li>
<li>下面是一个<code>Tweet</code>类的例子，它将表示不变量和抽象函数以及表示暴露的安全性注释了出来：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Immutable type representing a tweet.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String author;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String text;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rep invariant:</span></span><br><span class="line">    <span class="comment">//   author is a Twitter username (a nonempty string of letters, digits, underscores)</span></span><br><span class="line">    <span class="comment">//   text.length &lt;= 140</span></span><br><span class="line">    <span class="comment">// Abstraction function:</span></span><br><span class="line">    <span class="comment">//   AF(author, text, timestamp) = a tweet posted by author, with content text, </span></span><br><span class="line">    <span class="comment">//                                 at time timestamp </span></span><br><span class="line">    <span class="comment">// Safety from rep exposure:</span></span><br><span class="line">    <span class="comment">//   All fields are private;</span></span><br><span class="line">    <span class="comment">//   author and text are Strings, so are guaranteed immutable;</span></span><br><span class="line">    <span class="comment">//   timestamp is a mutable Date, so Tweet() constructor and getTimestamp() </span></span><br><span class="line">    <span class="comment">//        make defensive copies to avoid sharing the rep&#x27;s Date object with clients.</span></span><br><span class="line">    <span class="comment">// Operations (specs and method bodies omitted to save space)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tweet</span><span class="params">(String author, String text, Date timestamp)</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getText</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getTimestamp</span><span class="params">()</span> &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第四节-面向对象编程OOP"><a href="#第四节-面向对象编程OOP" class="headerlink" title="第四节 面向对象编程OOP"></a>第四节 面向对象编程OOP</h2><h3 id="OOP的基本概念"><a href="#OOP的基本概念" class="headerlink" title="OOP的基本概念"></a><em>OOP的基本概念</em></h3><p><strong>对象</strong></p>
<ul>
<li>对象是类的一个实例，有状态和行为。</li>
<li>例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li>概念：一个对象是一堆状态和行为的集合。<ul>
<li>状态是包含在对象中的数据，在Java中，它们是对象的fields。</li>
<li>行为是对象支持的操作，在Java中，它们称为methods。</li>
</ul>
</li>
</ul>
<p><strong>类</strong></p>
<ul>
<li>类是一个模板，它描述一类对象的行为和状态。</li>
<li>每个对象都有一个类</li>
<li>类定义了属性类型（type）和行为实现（implementation）</li>
<li>简单地说，类的方法是它的应用程序编程接口（API）。</li>
<li>类成员变量（class variable）又叫静态变量；类方法（class method）又叫静态方法：</li>
<li>实例变量（instance variable）和实例方法（instance method）是不用<code>static</code>形容的实例和方法；</li>
<li>二者有以下的区别：<ul>
<li>类方法是属于整个类，而不属于某个对象。 </li>
<li>类方法只能访问类成员变量（方法），不能访问实例变量（方法），而实例方法可以访问类成员变量（方法）和实例变量（方法）。 </li>
<li>类方法的调用可以通过类名.类方法和对象.类方法，而实例方法只能通过对象.实例方法访问。 </li>
<li>类方法不能被覆盖，实例方法可以被覆盖。</li>
<li>当类的字节码文件被加载到内存时，类的实例方法不会被分配入口地址 当该类创建对象后，类中的实例方法才分配入口地址， 从而实例方法可以被类创建的任何对象调用执行。</li>
<li>类方法在该类被加载到内存时，就分配了相应的入口地址。 从而类方法不仅可以被类创建的任何对象调用执行，也可以直接通过类名调用。 类方法的入口地址直到程序退出时才被取消。</li>
</ul>
</li>
<li>注意：<ul>
<li>当我们创建第一个对象时，类中的实例方法就分配了入口地址，当再创建对象时，不再分配入口地址。</li>
<li>也就是说，方法的入口地址被所有的对象共享，当所有的对象都不存在时，方法的入口地址才被取消。</li>
</ul>
</li>
<li>总结：<ul>
<li>类变量和类方法与类相关联，并且每个类都会出现一次。 使用它们不需要创建对象。</li>
<li>实例方法和变量会在每个类的实例中出现一次。</li>
</ul>
</li>
</ul>
<p><strong>接口</strong></p>
<ul>
<li>概念：接口在JAVA编程语言中是一个抽象类型，<strong>用于设计和表达ADT的语言机制</strong>，其是抽象方法的集合，接口通常以interface来声明。</li>
<li>一个类通过继承接口的方式，从而来继承接口的抽象方法。</li>
<li>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</li>
<li>一个接口可以扩展其他接口，一个类可以实现多个接口；一个接口也可以有多重实现</li>
<li>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</li>
<li>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</li>
</ul>
<p><strong>接口的好处</strong></p>
<ul>
<li>Safe from bugs<br>ADT是由其操作定义的，接口就是这样做的。<br>当客户端使用接口类型时，静态检查确保他们只使用由接口定义的方法。<br>如果实现类公开其他方法，或者更糟糕的是，具有可见的表示，客户端不会意外地看到或依赖它们。<br>当我们有一个数据类型的多个实现时，接口提供方法签名的静态检查。</li>
<li>Easy to understand<br>客户和维护人员确切知道在哪里查找ADT的规约。<br>由于接口不包含实例字段或实例方法的实现，因此更容易将实现的细节保留在规范之外。</li>
<li>Ready for change<br>通过添加实现接口的类，我们可以轻松地添加新类型的实现。<br>如果我们避免使用静态工厂方法的构造函数，客户端将只能看到该接口。<br>这意味着我们可以切换客户端正在使用的实现类，而无需更改其代码。</li>
</ul>
<p><strong>抽象类</strong></p>
<ul>
<li>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</li>
<li>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。</li>
<li>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</li>
<li>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>
<li>如果一个类包含抽象方法，那么该类必须是抽象类。</li>
<li>任何子类必须重写父类的抽象方法，或者声明自身为抽象类。</li>
<li>构造方法，类方法（用<code>static</code>修饰的方法）不能声明为抽象方法。</li>
</ul>
<h3 id="OOP的不同特征"><a href="#OOP的不同特征" class="headerlink" title="OOP的不同特征"></a><em>OOP的不同特征</em></h3><p><strong>封装</strong></p>
<ul>
<li><p>封装（Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>
</li>
<li><p>设计良好的代码隐藏了所有的实现细节</p>
<ul>
<li>干净地将API与实施分开</li>
<li>模块只能通过API进行通信</li>
<li>对彼此的内在运作不了解</li>
</ul>
</li>
<li><p>信息封装的好处</p>
<ul>
<li>将构成系统的类分开，减少耦合</li>
<li>加快系统开发速度</li>
<li>减轻了维护的负担</li>
<li>启用有效的性能调整</li>
<li>增加软件复用</li>
</ul>
</li>
<li><p>信息隐藏接口</p>
<ul>
<li>使用接口类型声明变量</li>
<li>客户端仅使用接口中定义的方法</li>
<li>客户端代码无法直接访问属性</li>
</ul>
</li>
<li><p>实现封装的方法</p>
</li>
</ul>
<ol>
<li><p>修改属性的可见性来限制对属性的访问（一般限制为<code>private</code>），例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用**<code>this</code>**关键字是为了解决实例变量（<code>private String name</code>）和局部变量（<code>setName(String name)</code>中的<code>name</code>变量）之间发生的同名的冲突。</p>
</li>
</ol>
<p><strong>继承与重写</strong></p>
<ul>
<li><p>继承概念：继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 </p>
</li>
<li><p>重写概念：重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。<strong>即外壳不变，核心重写！</strong></p>
</li>
<li><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>
</li>
<li><p>实际执行时调用那种方法，在运行时决定</p>
</li>
<li><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。</p>
</li>
<li><p>子类只能添加新方法，无法重写超类中的方法。</p>
</li>
<li><p>当子类包含一个覆盖超类方法的方法时，它也可以使用关键字<code>super</code></p>
<p>调用超类方法。例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物可以移动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">move</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>.move(); <span class="comment">// 应用super类的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;狗可以跑和走&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// Dog 对象</span></span><br><span class="line">        b.move(); <span class="comment">//执行 Dog类的方法 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法重写的规则</p>
<ul>
<li>参数列表必须完全与被重写方法的相同；</li>
<li>返回类型必须完全与被重写方法的返回类型相同；</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为<code>public</code>，那么在子类中重写该方法就不能声明为<code>protected</code>。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为<code>final</code>的方法不能被重写。</li>
<li>声明为<code>static</code>的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为<code>private</code>和<code>final</code>的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为<code>public</code>和<code>protected</code>的非<code>final</code>方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承一个方法，则不能重写这个方法。</li>
</ul>
</li>
</ul>
<p><strong>多态与重载</strong></p>
<ul>
<li>多态是同一行为具有多种不同表现形式或形态的能力</li>
<li>三种类型的多态<ul>
<li>Ad hoc polymorphism (特殊多态)：功能重载，一个函数可以有多个同名的实现。</li>
<li>Parametric polymorphism (参数多态)：泛型或泛型编程，一个类型名字可以代表多个类型</li>
<li>Subtyping (also called subtype polymorphism or inclusion polymorphism，子类型多态、包含多态):当一个名称表示许多不同的类与一些常见的超类相关的实例。</li>
</ul>
</li>
<li>重载(overloading) 是<strong>在一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同。</strong></li>
<li>每个重载的方法（或构造函数）都必须有一个独一无二的参数类型列表。</li>
<li>价值：方便client调用，client可用不同的参数列表，调用同样的函数。</li>
<li>重载是静态多态，根据参数列表进行最佳匹配。在编译阶段时决定要具体执行哪个方法 (static type checking) ，与之相反，重构方法则是在run-time进行dynamic checking！</li>
<li>重载规则<ul>
<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载；</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
</li>
</ul>
<p><strong>重写与重载的区别</strong></p>
<table>
<thead>
<tr>
<th align="center">区别点</th>
<th align="center">重载方法</th>
<th align="center">重写方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">参数列表</td>
<td align="center">必须修改</td>
<td align="center">一定不能修改</td>
</tr>
<tr>
<td align="center">返回类型</td>
<td align="center">可以修改</td>
<td align="center">一定不能修改</td>
</tr>
<tr>
<td align="center">异常</td>
<td align="center">可以修改</td>
<td align="center">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td align="center">访问</td>
<td align="center">可以修改</td>
<td align="center">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td align="center">调用情况</td>
<td align="center">引用类型决定选择哪个重载版本（基于声明的参数类型，<strong>在编译时发生</strong></td>
<td align="center">对象类型（换句话说，堆上实际实例的类型）决定选择哪种方法在运行时发生。</td>
</tr>
</tbody></table>
<p>　　方法的重写(Overriding)和重载(Overloading)是Java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p>
<ul>
<li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li>
<li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li>
<li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li>
</ul>
<p><strong>泛型（参数多态）</strong></p>
<ul>
<li>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</li>
<li>可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。</li>
<li>下面是定义泛型方法的规则：<ul>
<li>所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。</li>
<li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。</li>
<li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li>
<li>泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像<code>int</code>, <code>double</code>, <code>char</code>等）。</li>
</ul>
</li>
</ul>
<h2 id="第五节-ADT和OOP中的等价性"><a href="#第五节-ADT和OOP中的等价性" class="headerlink" title="第五节 ADT和OOP中的等价性"></a>第五节 ADT和OOP中的等价性</h2><h3 id="等价性equals-和"><a href="#等价性equals-和" class="headerlink" title="等价性equals()和=="></a><em>等价性<code>equals()</code>和<code>==</code></em></h3><ul>
<li><p>和很多其他语言一样，Java有两种判断相等的操作——<code>==</code>和<code>equals()</code>。</p>
</li>
<li><pre><code>==
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">是引用等价性 ；而</span><br><span class="line"></span><br></pre></td></tr></table></figure>
equals()
</code></pre>
<p>是对象等价性。 </p>
<ul>
<li><code>== </code>比较的是索引。更准确的说，它测试的是指向相等（referential equality）。如果两个索引指向同一块存储区域，那它们就是<code>==</code>的。对于我们之前提到过的快照图来说，<code>==</code>就意味着它们的箭头指向同一个对象。</li>
<li><code>equals()</code>操作比较的是对象的内容，换句话说，它测试的是对象值相等（object equality）。在每一个ADT中，<code>equals</code>操作必须合理定义。</li>
</ul>
</li>
</ul>
<p>Java中的数据类型，可分为两类： </p>
<ul>
<li>基本数据类型，也称原始数据类型。<code>byte, short, char, int, long, float, double, boolean</code> <ul>
<li>他们之间的比较，应用双等号（<code>==</code>）,比较的是他们的值。</li>
</ul>
</li>
<li>复合数据类型(类) <ul>
<li>当他们用（<code>==</code>）进行比较的时候，比较的是他们在内存中的存放地址，所以，除非是同一个new出来的对象，他们的比较后的结果为true，否则比较后结果为false。 </li>
<li>Java当中所有的类都是继承于<code>Object</code>这个基类的，在<code>Object</code>中的基类中定义了一个<code>equals</code>的方法，这个方法的初始行为是比较对象的内存地址，但在一些类库当中这个方法被覆盖掉了，如<code>String, Integer, Date</code>在这些类当中<code>equals</code>有其自身的实现，而不再是比较类在堆内存中的存放地址了。  </li>
<li>对于复合数据类型之间进行<code>equals</code>比较，在没有覆写<code>equals</code>方法的情况下，他们之间的比较还是基于他们在内存中的存放位置的地址值的，因为<code>Object</code>的<code>equals</code>方法也是用双等号（<code>==</code>）进行比较的，所以比较后的结果跟双等号（<code>==</code>）的结果相同。</li>
</ul>
</li>
</ul>
<h3 id="equals-的判断方法"><a href="#equals-的判断方法" class="headerlink" title="equals()的判断方法"></a><em><code>equals()</code>的判断方法</em></h3><p>严格来说，我们可以从三个角度定义相等：</p>
<ul>
<li><p><strong>抽象函数：</strong>回忆一下抽象函数（$AF: R \to A$ ），它将具体的表示数据映射到了抽象的值。如果$AF(a)&#x3D;AF(b)$，我们就说a和b相等。</p>
</li>
<li><p>等价关系：</p>
<p>等价是指对于关系$E \subseteq T \times T$ ，它满足：</p>
<ul>
<li>自反性: <code>x.equals(x)</code>必须返回<code>true</code></li>
<li>对称性: <code>x.equals(y)</code>与<code>y.equals(x)</code>的返回值必须相等。</li>
<li>传递性: <code>x.equals(y)</code>为<code>true</code>，<code>y.equals(z)</code>也为<code>true</code>，那么<code>x.equals(z)</code>必须为<code>true</code>。</li>
</ul>
</li>
</ul>
<p>以上两种角度&#x2F;定义实际上是一样的，通过等价关系我们可以构建一个抽象函数（译者注：就是一个封闭的二元关系运算）；而抽象函数也能推出一个等价关系。</p>
<h4 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode()方法"></a><code>hashCode()</code>方法</h4><ul>
<li>对于不可变类型：<ul>
<li><code>equals()</code>应该比较抽象值是否相等。这和 <code>equals()</code>比较行为相等性是一样的。</li>
<li><code>hashCode()</code>应该将抽象值映射为整数。</li>
<li>所以不可变类型应该同时覆盖<code>equals()</code>和<code>hashCode()</code></li>
</ul>
</li>
<li>对于可变类型：<ul>
<li><code>equals()</code>应该比较索引，就像<code>==</code>一样。同样的，这也是比较行为相等性。</li>
<li><code>hashCode()</code>应该将索引映射为整数。</li>
<li>所以可变类型不应该将<code>equals()</code>和<code>hashCode()</code>覆盖，而是直接继承 <code>Object</code>中的方法。Java没有为大多数聚合类遵守这一规定，这也许会导致上面看到的隐秘bug。</li>
</ul>
</li>
<li><code>equals()</code>与<code>hashCode()</code>两个方法均属于<code>Object</code>对象，<code>equals()</code>根据我们的需要重写， 用来判断是否是同一个内容或同一个对象，具体是判断什么，怎么判断得看怎么重写，默认的<code>equals()</code>是比较地址。</li>
<li><code>hashCode()</code>方法返回一个<code>int</code>的哈希码， 同样可以重写来自定义获取哈希码的方法。</li>
<li><code>equals()</code>判定为相同，<code>hashCode</code>一定相同。<code>equals()</code>判定为不同，<code>hashCode</code>不一定不同。</li>
<li><code>hashCode</code>必须为两个被该<code>equals</code>方法视为相等的对象产生相同的结果。</li>
<li>与<code>equals()</code>方法类似，<code>hashCode()</code>方法可以被重写。JDK中对<code>hashCode()</code>方法的作用，以及实现时的注意事项做了说明：<ul>
<li><code>hashCode()</code>在哈希表中起作用，如<code>java.util.HashMap</code>。</li>
<li>如果对象在<code>equals()</code>中使用的信息都没有改变，那么<code>hashCode()</code>值始终不变。</li>
<li>如果两个对象使用<code>equals()</code>方法判断为相等，则<code>hashCode()</code>方法也应该相等。</li>
<li>如果两个对象使用<code>equals()</code>方法判断为不相等，则不要求<code>hashCode()</code>也必须不相等；但是开发人员应该认识到，不相等的对象产生不相同的<code>hashCode</code>可以提高哈希表的性能。</li>
</ul>
</li>
</ul>
<h3 id="可变类型的等价性"><a href="#可变类型的等价性" class="headerlink" title="可变类型的等价性"></a><em>可变类型的等价性</em></h3><p>　　回忆之前我们对于相等的定义，即它们不能被使用者观察出来不同。而对于可变对象来说，它们多了一种新的可能：通过在观察前调用改造者，我们可以改变其内部的状态，从而观察出不同的结果。</p>
<ul>
<li><p>所以我们重新定义两种相等：</p>
<ul>
<li><strong>观察等价性</strong>：两个索引在不改变各自对象状态的前提下不能被区分。即通过只调用observer，producer和creator的方法，它测试的是这两个索引在当前程序状态下“看起来”相等。</li>
<li><strong>行为等价性</strong>：两个索引在任何代码的情况下都不能被区分，即使有一个对象调用了改造者。它测试的是两个对象是否会在未来所有的状态下“行为”相等。</li>
</ul>
</li>
<li><p>对于不可变对象，观察相等和行为相等是完全等价的，因为它们没有改造者改变对象内部的状态。</p>
</li>
<li><p><strong>对于可变对象，Java通常实现的是观察相等</strong>。例如两个不同的<code>List</code>对象包含相同的序列元素，那么<code>equals()</code> 操作就会返回真。</p>
</li>
</ul>
<br>
------    

<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="第一节-面向可理解性的构造"><a href="#第一节-面向可理解性的构造" class="headerlink" title="第一节 面向可理解性的构造"></a>第一节 面向可理解性的构造</h2><h3 id="代码的可理解性"><a href="#代码的可理解性" class="headerlink" title="代码的可理解性"></a><em>代码的可理解性</em></h3><br>
**如何编写易于理解的代码**

<ul>
<li>遵循命名规范</li>
<li>限制代码行的最大长度、文件的最大LoC</li>
<li>足够的注释</li>
<li>代码有好的布局：缩进、空行、对其、分块、等。</li>
<li>避免多层嵌套—增加复杂度</li>
<li>文件和包的组织</li>
</ul>
<p>代码的可读性&#x2F;可理解性很多时候比效率&#x2F;性能更重要，不可读、不可理解代码可能蕴含更多的错误。 因此先写出可读易懂的代码，再去逐渐调优。</p>
<hr>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%9C%AC%E7%A7%91%E6%96%87%E6%A1%A3/" rel="tag"># 本科文档</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/04/21/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93%20-%201/" rel="prev" title="软件构造知识点总结 - 1">
                  <i class="fa fa-angle-left"></i> 软件构造知识点总结 - 1
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/06/12/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%203/" rel="next" title="软件构造知识点总结 - 3">
                  软件构造知识点总结 - 3 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gaotf</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
