<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="第十章 并发编程并发（concurrency）  定义：指的是多线程场景下对共享资源的争夺运行 并发的应用背景： 网络上的多台计算机 一台计算机上的多个应用 一个CPU上的多核处理器   为什么要有并发： 摩尔定律失效、“核”变得越来越多 为了充分利用多核和多处理器需要将程序转化为并行执行   并发编程的两种模式： 共享内存：在内存中读写共享数据 信息传递（Message Passing）：通过c">
<meta property="og:type" content="article">
<meta property="og:title" content="软件构造知识点总结 - 6">
<meta property="og:url" content="http://example.com/2019/07/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%206/index.html">
<meta property="og:site_name" content="漱石斋笔谈">
<meta property="og:description" content="第十章 并发编程并发（concurrency）  定义：指的是多线程场景下对共享资源的争夺运行 并发的应用背景： 网络上的多台计算机 一台计算机上的多个应用 一个CPU上的多核处理器   为什么要有并发： 摩尔定律失效、“核”变得越来越多 为了充分利用多核和多处理器需要将程序转化为并行执行   并发编程的两种模式： 共享内存：在内存中读写共享数据 信息传递（Message Passing）：通过c">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-07-19T16:00:00.000Z">
<meta property="article:modified_time" content="2024-04-26T02:47:18.816Z">
<meta property="article:author" content="gaotf">
<meta property="article:tag" content="本科文档">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2019/07/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%206/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2019/07/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%206/","path":"2019/07/20/软件构造知识点总结 - 6/","title":"软件构造知识点总结 - 6"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>软件构造知识点总结 - 6 | 漱石斋笔谈</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">漱石斋笔谈</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">gaotf 的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0"><span class="nav-number">1.</span> <span class="nav-text">第十章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">并发编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8"><span class="nav-number">1.1.2.</span> <span class="nav-text">线程的创建和启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87%E3%80%81%E4%BA%A4%E9%94%99%E6%89%A7%E8%A1%8C%E3%80%81%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="nav-number">1.1.3.</span> <span class="nav-text">时间分片、交错执行、竞争条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%91%E7%9C%A0%E3%80%81%E4%B8%AD%E6%96%AD"><span class="nav-number">1.1.4.</span> <span class="nav-text">线程的休眠、中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%AD%96%E7%95%A5"><span class="nav-number">1.1.5.</span> <span class="nav-text">线程安全的四个策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">1.1.6.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A5%E6%B3%A8%E9%87%8A%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%92%B0%E5%86%99%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5"><span class="nav-number">1.1.7.</span> <span class="nav-text">以注释的形式撰写线程安全策略</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gaotf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">gaotf</p>
  <div class="site-description" itemprop="description">热爱技术，笔耕不辍</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/1170300619" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1170300619" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3469205806@qq.com" title="E-Mail → 3469205806@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/20/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%206/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="软件构造知识点总结 - 6 | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          软件构造知识点总结 - 6
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2019-07-20T00:00:00+08:00">2019-07-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:47:18" itemprop="dateModified" datetime="2024-04-26T10:47:18+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0/" itemprop="url" rel="index"><span itemprop="name">软件构造</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><hr>
<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p><strong>并发（concurrency）</strong></p>
<ul>
<li>定义：指的是多线程场景下对共享资源的争夺运行</li>
<li>并发的应用背景：<ul>
<li>网络上的多台计算机</li>
<li>一台计算机上的多个应用</li>
<li>一个CPU上的多核处理器</li>
</ul>
</li>
<li>为什么要有并发：<ul>
<li>摩尔定律失效、“核”变得越来越多</li>
<li>为了充分利用多核和多处理器需要将程序转化为并行执行</li>
</ul>
</li>
<li>并发编程的两种模式：<ul>
<li>共享内存：在内存中读写共享数据</li>
<li>信息传递（Message Passing）：通过channel交换消息</li>
</ul>
</li>
</ul>
<p><strong>共享内存</strong></p>
<ul>
<li>共享内存这种方式比较常见，我们经常会设置一个共享变量，然后多个线程去操作同一个共享变量。从而达到线程通讯的目的。</li>
<li>例子：<ul>
<li>两个处理器，共享内存</li>
<li>同一台机器上的两个程序，共享文件系统</li>
<li>同一个Java程序内的两个线程，共享Java对象</li>
</ul>
</li>
</ul>
<p><strong>信息传递</strong></p>
<ul>
<li>消息传递方式采取的是线程之间的直接通信，不同的线程之间通过显式的发送消息来达到交互目的</li>
<li>接收方将收到的消息形成队列逐一处理，消息发送者继续发送（异步方式）</li>
<li>消息传递机制也无法解决竞争条件问题</li>
<li>仍然存在消息传递时间上的交错</li>
<li>例子：<ul>
<li>网络上的两台计算机，通过网络连接通讯</li>
<li>浏览器和Web服务器，A请求页面，B发送页面数据给A</li>
<li>即时通讯软件的客户端和服务器</li>
<li>同一台计算机上的两个程序，通过管道连接进行通讯</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">并发模型</th>
<th align="center">通信机制</th>
<th align="center">同步机制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">共享内存</td>
<td align="center">线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。</td>
<td align="center">同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。</td>
</tr>
<tr>
<td align="center">消息传递</td>
<td align="center">线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</td>
<td align="center">由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</td>
</tr>
</tbody></table>
<h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a><em>进程和线程</em></h3><ul>
<li>进程：是执行中一段程序，即一旦程序被载入到内存中并准备执行，它就是一个进程。进程是表示资源分配的的基本概念，又是调度运行的基本单位，是系统中的并发执行的单位。<ul>
<li>程序运行时在内存中分配自己独立的运行空间</li>
<li>进程拥有整台计算机的资源</li>
<li>多进程之间不共享内存</li>
<li>进程之间通过消息传递进行协作</li>
<li>一般来说，进程<code>==</code>程序<code>==</code>应用（但一个应用中可能包含多个进程）</li>
<li>OS支持的IPC机制(pipe&#x2F;socket)支持进程间通信（IPC不仅是本机的多个进程之间， 也可以是不同机器的多个进程之间）</li>
<li>JVM通常运行单一进程，但也可以创建新的进程。</li>
</ul>
</li>
<li>线程：它是位于进程中，负责当前进程中的某个具备独立运行资格的空间。<ul>
<li>线程有自己的堆栈和局部变量，但是多个线程共享内存空间</li>
<li>进程&#x3D;虚拟机；线程&#x3D;虚拟CPU</li>
<li>程序共享、资源共享，都隶属于进程</li>
<li>很难获得线程私有的内存空间</li>
<li>线程需要同步：在改变对象时要保持lock状态</li>
<li>清理线程是不安全的</li>
</ul>
</li>
<li>进程是负责整个程序的运行，而线程是程序中具体的某个独立功能的运行。</li>
<li>一个进程中至少应该有一个线程。</li>
<li>主线程可以创建其他的线程。</li>
</ul>
<h3 id="线程的创建和启动"><a href="#线程的创建和启动" class="headerlink" title="线程的创建和启动"></a><em>线程的创建和启动</em></h3><p><strong>方式1：继承<code>Thread</code>类</strong></p>
<ul>
<li>方法：用<code>Thread</code>类实现了<code>Runnable</code>接口，但它其中的<code>run</code>方法什么都没做，所以用一个类做<code>Thread</code>的子类，提供它自己实现的<code>run</code>方法。用<code>Thread.start()</code>来开始一个新的线程。</li>
<li>创建：<code>A a = new A()</code>;</li>
<li>启动：<code>a.start()</code>;</li>
<li>步骤:<ul>
<li>定义一个类A继承于<code>java.lang.Thread</code>类.</li>
<li>在<code>A</code>类中覆盖<code>Thread</code>类中的<code>run</code>方法.</li>
<li>我们在<code>run</code>方法中编写需要执行的操作：<code>run</code>方法里的代码,线程执行体.</li>
<li>在<code>main</code>方法(线程)中,创建线程对象,并启动线程.</li>
</ul>
</li>
<li><em><strong>examples</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1):定义一个类A继承于java.lang.Thread类.  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;  </span><br><span class="line">     <span class="comment">//2):在A类中覆盖Thread类中的run方法.  </span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">          <span class="comment">//3):在run方法中编写需要执行的操作  </span></span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i ++)&#123;  </span><br><span class="line">              System.out.println(<span class="string">&quot;播放音乐&quot;</span>+i);  </span><br><span class="line">          &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line">   </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExtendsThreadDemo</span> &#123;  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;             </span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">50</span>; j ++)&#123;  </span><br><span class="line">             System.out.println(<span class="string">&quot;运行游戏&quot;</span>+j);  </span><br><span class="line">             <span class="keyword">if</span>(j == <span class="number">10</span>)&#123;  </span><br><span class="line">                 <span class="comment">//4):在main方法(线程)中,创建线程对象,并启动线程.  </span></span><br><span class="line">                 <span class="type">MusicThread</span> <span class="variable">music</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicThread</span>();  </span><br><span class="line">                 music.start();  </span><br><span class="line">             &#125;  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>方式2：实现Runable接口</strong></p>
<ul>
<li><strong>创建</strong>：<code>Thread  t = new Thread(new  A())</code>;</li>
<li><strong>调用</strong>：<code>t.start()</code>;</li>
<li>步骤<ul>
<li>定义一个类A实现于<code>java.lang.Runnable</code>接口,注意A类不是线程类.</li>
<li>在A类中覆盖<code>Runnable</code>接口中的<code>run</code>方法.</li>
<li>我们在<code>run</code>方法中编写需要执行的操作：<code>run</code>方法里的,线程执行体.</li>
<li>在<code>main</code>方法(线程)中,创建线程对象,并启动线程.</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1):定义一个类A实现于java.lang.Runnable接口,注意A类不是线程类.  </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MusicImplements</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="comment">//2):在A类中覆盖Runnable接口中的run方法.  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="comment">//3):在run方法中编写需要执行的操作  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i ++)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;播放音乐&quot;</span>+i);  </span><br><span class="line">        &#125;  </span><br><span class="line">          </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementsRunnableDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">50</span>; j ++)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;运行游戏&quot;</span>+j);  </span><br><span class="line">            <span class="keyword">if</span>(j == <span class="number">10</span>)&#123;  </span><br><span class="line">                <span class="comment">//4):在main方法(线程)中,创建线程对象,并启动线程  </span></span><br><span class="line">                <span class="type">MusicImplements</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MusicImplements</span>();  </span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mi);  </span><br><span class="line">                t.start();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li><p>实现<code>Runnable</code>接口相比继承<code>Thread</code>类有如下好处：</p>
<ul>
<li>避免点继承的局限，一个类可以继承多个接口。</li>
<li>适合于资源的共享</li>
</ul>
</li>
<li><p>创建并运行一个线程所犯的常见错误是调用线程的<code>run()</code>方法而非<code>start()</code>方法，如下所示：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">newThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(MyRunnable());</span><br><span class="line">newThread.run();  <span class="comment">//should be start();</span></span><br></pre></td></tr></table></figure>

<p>　　起初并不会感觉到有什么不妥，因为<code>run()</code>方法的确如你所愿的被调用了。但是，事实上，<code>run()</code>方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。也就是被执行上面两行代码的线程所执行的。想要让创建的新线程执行<code>run()</code>方法，必须调用新线程的<code>start()</code>方法。</p>
<h3 id="时间分片、交错执行、竞争条件"><a href="#时间分片、交错执行、竞争条件" class="headerlink" title="时间分片、交错执行、竞争条件"></a><em>时间分片、交错执行、竞争条件</em></h3><p> <strong>时间分片</strong></p>
<ul>
<li>虽然有多线程，但只有一个核，每个时刻只能执行一个线程。<ul>
<li>通过时间分片，再多个线程&#x2F;进程之间共享处理器</li>
</ul>
</li>
<li>即使是多核CPU，进程&#x2F;线程的数目也往往大于核的数目</li>
<li>通过时间分片，在多个进程&#x2F;线程之间共享处理器。（时间分片是由OS自动调度的）</li>
<li>当线程数多于处理器数量时，并发性通过时间片来模拟，处理器切换处理不同的线程</li>
</ul>
<p> <strong>交错执行</strong></p>
<p>　　顾名思义，就是说在线程运行的过程中，多个线程同时运行相互交错。而且，由于线程运行一般不是连续的，那么就会导致线程间的交错。可以说，所有线程安全问题的本质都是线程交错的问题。</p>
<p> <strong>竞争条件</strong></p>
<p>　　竞争是发生在线程交错的基础上的。当多个线程对同一对象进行读写访问时，就可能会导致竞争的问题。程序中可能出现的一种问题就是，读写数据发生了不同步。例如，我要用一个数据，在该数据修改还没写回内存中时就读取出来了，那么就会导致程序出现问题。</p>
<p>　　程序运行时有一种情况，就是程序如果要正确运行，必须保证A线程在B线程之前完成（正确性意味着程序运行满足其规约）。当发生这种情况时，就可以说A与B发生竞争关系。</p>
<ul>
<li>计算机运行过程中，并发、无序、大量的进程在使用有限、独占、不可抢占的资源，由于进程无限，资源有限，产生矛盾，这种矛盾称为竞争（Race）。</li>
<li>由于两个或者多个进程竞争使用不能被同时访问的资源，使得这些进程有可能因为时间上推进的先后原因而出现问题，这叫做竞争条件（Race Condition）。</li>
<li>竞争条件分为两类:<br>-Mutex（互斥）：两个或多个进程彼此之间没有内在的制约关系，但是由于要抢占使用某个临界资源（不能被多个进程同时使用的资源，如打印机，变量）而产生制约关系。<br>-Synchronization（同步）：两个或多个进程彼此之间存在内在的制约关系（前一个进程执行完，其他的进程才能执行），如严格轮转法。</li>
<li>解决互斥方法：<br>Busy Waiting(忙等待)：等着但是不停的检查测试，不睡觉，知道能进行为止<br>Sleep and Wakeup(睡眠与唤醒)：引入Semapgore(信号量，包含整数和等待队列,为进程睡觉而设置)，唤醒由其他进程引发。</li>
<li>临界区（Critical Region）：<ul>
<li>一段访问临界资源的代码。</li>
<li>为了避免出现竞争条件，进入临界区要遵循四条原则： <ul>
<li>任何两个进程不能同时进入访问同一临界资源的临界区</li>
<li>进程的个数，CPU个数性能等都是无序的，随机的</li>
<li>临界区之外的进程不得阻塞其他进程进入临界区</li>
<li>任何进程都不应被长期阻塞在临界区之外</li>
</ul>
</li>
</ul>
</li>
<li>解决互斥的方法:<br>• 禁用中断 Disabling interrupts<br>• 锁变量 Lock variables （no）<br>• 严格轮转 Strict alternation (no)<br>• Peterson’s solution (yes)<br>• The TSL instruction (yes)</li>
</ul>
<h3 id="线程的休眠、中断"><a href="#线程的休眠、中断" class="headerlink" title="线程的休眠、中断"></a><em>线程的休眠、中断</em></h3><p> <strong><code>Thread.sleep</code></strong></p>
<ul>
<li>在线程中允许一个线程进行暂时的休眠，直接使用<code>Thread.sleep()</code>方法即可。 <ul>
<li>将某个线程休眠，意味着其他线程得到更多的执行机会</li>
<li>进入休眠的线程不会失去对现有monitor或锁的所有权</li>
</ul>
</li>
<li>sleep定义格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> milis,<span class="type">int</span> nanos)</span></span><br><span class="line">       <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure>

<p>　　首先，**<code>static</code>，说明可以由<code>Thread</code>类名称调用<strong>，其次</strong><code>throws</code>表示如果有异常要在调用此方法处处理异常**。</p>
<p><strong>所以<code>sleep()</code>方法要有<code>InterruptedException</code>异常处理，而且<code>sleep()</code>调用方法通常为<code>Thread.sleep(500);</code>形式。</strong></p>
<p><strong><code>Thread.interrupt</code></strong> </p>
<ul>
<li><p>一个线程可以被另一个线程中断其操作的状态，使用<code>interrupt()</code>方法完成。</p>
<ul>
<li>通过线程的实例来调用<code>interrupt()</code>函数，向线程发出中断信号</li>
<li><code>t.interrupt()</code>：在其他线程里向<code>t</code>发出中断信号</li>
<li><code>t.isInterrupted()</code>：检查<code>t</code>是否已在中断状态中</li>
</ul>
</li>
<li><p>当某个线程被中断后，一般来说应停止其<code>run()</code>中的执行，取决于程序员在<code>run()</code>中处理</p>
<ul>
<li>一般来说，线程在收到中断信号时应该中断，直接终止</li>
<li>但是，线程收到其他线程发出来的中断信号，并不意味着一定要“停止”</li>
</ul>
</li>
<li><p>实例：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Thread1;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;    <span class="comment">// 实现Runnable接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;    <span class="comment">// 覆写run()方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1、进入run()方法&quot;</span>) ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>) ;    <span class="comment">// 线程休眠10秒</span></span><br><span class="line">                System.out.println(<span class="string">&quot;2、已经完成了休眠&quot;</span>) ;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3、休眠被终止&quot;</span>) ;</span><br><span class="line">            <span class="keyword">return</span> ; <span class="comment">// 返回调用处</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;4、run()方法正常结束&quot;</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo1</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() ;    <span class="comment">// 实例化Runnable子类对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(mt,<span class="string">&quot;线程&quot;</span>);        <span class="comment">// 实例化Thread对象</span></span><br><span class="line">        t.start() ;    <span class="comment">// 启动线程</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>) ;    <span class="comment">// 线程休眠2秒</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;3、休眠被终止&quot;</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        t.interrupt() ;    <span class="comment">// 中断线程执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、进入run()方法</span><br><span class="line">3、休眠被终止</span><br></pre></td></tr></table></figure>

<h3 id="线程安全的四个策略"><a href="#线程安全的四个策略" class="headerlink" title="线程安全的四个策略"></a><em>线程安全的四个策略</em></h3><ul>
<li>线程安全的定义：ADT或方法在多线程中要执行正确，即无论如何执行，不许调度者做额外的协作，都能满足正确性</li>
<li>四种线程安全的策略：<ul>
<li>Confinement 限制数据共享</li>
<li>Immutability 共享不可变数据</li>
<li>Threadsafe data type 共享线程安全的可变数据</li>
<li>Synchronization 同步机制共享共享线程不安全的可变数据，对外即为线程安全的ADT.</li>
</ul>
</li>
</ul>
<p><strong>Confinement限制数据共享</strong></p>
<ul>
<li>核心思想：线程之间不共享mutable数据类型<ul>
<li>将可变数据限制在单一线程内部，避免竞争</li>
<li>不允许任何县城直接读写该数据</li>
</ul>
</li>
<li>在多线程环境中，取消全局变量，尽量避免使用不安全的静态变量。<ul>
<li>限制数据共享主要是在线程内部使用局部变量，因为局部变量在每个函数的栈内，每个函数都有自己的栈结构，互不影响，这样局部变量之间也互不影响。</li>
<li>如果局部变量是一个指向对象的引用，那么就需要检查该对象是否被限制住，如果没有被限制住（即可以被其他线程所访问），那么就没有限制住数据，因此也就不能用这种方法来保证线程安全</li>
</ul>
</li>
<li><em><strong>examples</strong></em></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorial</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes n! and prints it on standard output.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n must be &gt;= 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">computeFact</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">BigInteger</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;working on fact &quot;</span> + n);</span><br><span class="line">            result = result.multiply(<span class="keyword">new</span> <span class="title class_">BigInteger</span>(String.valueOf(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;fact(&quot;</span> + n + <span class="string">&quot;) = &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">// create a thread using an</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;     <span class="comment">// anonymous Runnable</span></span><br><span class="line">                computeFact(<span class="number">99</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        computeFact(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 解释：主函数开启了两个线程，调用的是相同函数。因为线程共享局部变量的类型，但每个函数调用有不同的栈，因此有不同的<code>i, n, result</code>。由于每个函数都有自己的局部变量，那么每个函数就可以独立运行，更新它们自己的函数值，线程之间不影响结果。</p>
<p><strong>Immutability共享不可变数据</strong> </p>
<p>不可变数据类型，指那些在整个程序运行过程中，指向内存的引用是一直不变的，通常使用<code>final</code>来修饰。不可变数据类型通常来讲是线程安全的，但也可能发生意外。</p>
<p>但是，程序在运行过程中，有时为了优化程序结构，默默地将这个引用更改了。此时，客户端程序员是不知道它被更改了，对于客户端而言，这个引用还是不可变的，但其实已经被悄悄更改了。这时就会发生一些线程安全问题。</p>
<p>解决方案就是给这些不可变数据类型再增加一些限制：</p>
<ul>
<li>所有的方法和属性都是私有的。</li>
<li>不提供可变的方法，即不对外开放可以更改内部属性的方法。</li>
<li>没有数据的泄露，即返回值而不是引用。</li>
<li>不在其中存储可变数据对象。</li>
</ul>
<p>这样就可以保证线程的安全了。</p>
<p><strong>Threadsafe data type（共享线程安全的可变数据）</strong></p>
<ul>
<li>方法：如果必须要用mutable的数据类型在多线程之间共享数据，要使用线程安全的数据类型。（在JDK中的类，文档中明确指明了是否threadsafe）</li>
<li>一般来说，JDK同时提供两个相同功能的类，一个是threadsafe，另一个不是。原因：threadsafe的类一般性能上受影响。</li>
<li><code>List、Set、Map</code>这些集合类都是线程不安全的，Java API为这些集合类提供了进一步的decorator</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer,Boolean&gt; cache = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">synchronizedCollection</span><span class="params">(Collection&lt;T&gt; c)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Set&lt;T&gt; <span class="title function_">synchronizedSet</span><span class="params">(Set&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; <span class="title function_">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; SortedSet&lt;T&gt; <span class="title function_">synchronizedSortedSet</span><span class="params">(SortedSet&lt;T&gt; s)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; SortedMap&lt;K,V&gt; <span class="title function_">synchronizedSortedMap</span><span class="params">(SortedMap&lt;K,V&gt; m)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>在使用<code>synchronizedMap(hashMap)</code>之后，不要再把参数<code>hashMap</code>共享给其他线程，不要保留别名，一定要彻底销毁.（可以用<code>private static Map cache = Collections.synchronizedMap(new HashMap&lt;&gt;())</code>;的方式实例化集合类）</li>
<li>即使在线程安全的集合类上，使用<code>iterator</code>也是不安全的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Type&gt; c = Collections.synchronizedList(<span class="keyword">new</span></span><br><span class="line"><span class="title class_">ArrayList</span>&lt;Type&gt;());</span><br><span class="line"><span class="keyword">synchronized</span>(c) &#123; <span class="comment">// to be introduced later (the 4-th threadsafe way)</span></span><br><span class="line">    <span class="keyword">for</span> (Type e : c)</span><br><span class="line">        foo(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要注意用java提供的包装类包装集合后，只是将集合的每个操作都看成了原子操作，也就保证了每个操作内部的正确性，但是在两个操作之间不能保证集合类不被修改，因此需要用lock机制，例如</li>
</ul>
<p>　　如果在<code>isEmpty</code>和<code>get</code>中间，将元素移除，也就产生了竞争。</p>
<p><strong>前三种策略的核心思想：避免共享$\to$即使共享，也只能读&#x2F;不可写(immutable)$\to$即使可写(mutable)，共享的可写数据应自己具备在多线程之间协调的能力，即“使用线程安全的mutable ADT”</strong></p>
<p> <strong>Synchronization同步与锁</strong></p>
<ul>
<li><p>为什么要同步</p>
<ul>
<li>java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查）</li>
<li>将会导致数据不准确，相互之间产生冲突，因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用</li>
<li>保证了该变量的唯一性和准确性</li>
</ul>
</li>
<li><p>同步方法</p>
<ul>
<li><p>即有<code>synchronized</code>关键字修饰的方法。</p>
</li>
<li><p>由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，内置锁会保护整个方法。</p>
</li>
<li><p>在调用该方法前，需要获得内置锁，否则就处于阻塞状态。</p>
</li>
<li><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><pre><code>注：`synchronized`关键字也可以修饰静态方法，此时如果调用该静态方法，将会锁住整个类
</code></pre>
</li>
</ul>
</li>
<li><p>同步代码块</p>
</li>
</ul>
<pre><code>-   在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

-   被该关键字修饰的语句块会自动被加上内置锁，从而实现同步。

-   代码如：

    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object)&#123;...&#125;</span><br></pre></td></tr></table></figure>

-   注：同步是一种高开销的操作，因此应该尽量减少同步的内容。
</code></pre>
<ul>
<li><p>使用锁机制，获得对数据的独家mutation权，其他线程被阻塞，不得访问</p>
</li>
<li><p>Lock是Java语言提供的内嵌机制，每个object都有相关联的lock</p>
</li>
<li><p>任何共享的mutable变量&#x2F;对象必须被lock所保护</p>
</li>
<li><p>涉及到多个mutable变量的时候，它们必须被同一个lock所保护</p>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a><em>死锁</em></h3><ul>
<li><p><strong>定义</strong>：两个或多个线程相互等待对方释放锁，则会出现死锁现象。</p>
</li>
<li><p>java虚拟机没有检测，也没有采用措施来处理死锁情况，所以多线程编程是应该采取措施避免死锁的出现。一旦出现死锁，整个程序即不会发生任何异常，也不会给出任何提示，只是所有线程都处于堵塞状态。</p>
</li>
<li><p><strong>形成死锁的条件：</strong></p>
<ul>
<li>互斥条件：线程使用的资源必须至少有一个是不能共享的（至少有锁）；</li>
<li>请求与保持条件：至少有一个线程必须持有一个资源并且正在等待获取一个当前被其它线程持有的资源（至少两个线程持有不同锁，又在等待对方持有锁）；</li>
<li>非剥夺条件：分配资源不能从相应的线程中被强制剥夺（不能强行获取被其他线程持有锁）；</li>
<li>循环等待条件：第一个线程等待其它线程，后者又在等待第一个线程（线程$A$等线程$B$；线程$B$等线程$C$; $\cdots$ ;线程$N$等线程$A$。如此形成环路）。</li>
</ul>
</li>
<li><p>防止死锁的方法：</p>
<ul>
<li><strong>加锁顺序：</strong>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。这种方式是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁，但总有些时候是无法预知的</li>
</ul>
</li>
<li><ul>
<li><p>使用粗粒度的锁，用单个锁来监控多个对象</p>
<ul>
<li>对整个社交网 络设置 一个锁 ，并且对其任何组成部分的所有操作都在该锁上进行同步。</li>
<li>例如：所有的Wizards都属于一个Castle,  可使用 castle 实例的锁</li>
</ul>
<p>　　缺点：性能损失大；</p>
<ul>
<li>如果用一个锁保护大量的可变数据，那么久放弃了同时访问这些数据的能力；</li>
<li>在最糟糕的情况下，程序可能基本上是顺序执行的，丧失了并发性</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><strong>加锁时限</strong>：在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁。</li>
<li>用 jstack 等工具进行死锁检测</li>
</ul>
</li>
</ul>
<h3 id="以注释的形式撰写线程安全策略"><a href="#以注释的形式撰写线程安全策略" class="headerlink" title="以注释的形式撰写线程安全策略"></a><em>以注释的形式撰写线程安全策略</em></h3><ul>
<li><p>在代码中以注释的形式添加说明：该ADT采取了什么设计决策来保证线程安全</p>
</li>
<li><p>阐述如何使rep线程安全；</p>
</li>
<li><p>写入表示不变性的说明中，以便代码维护者知道你是如何为类设计线程安全性的。</p>
</li>
<li><p>需要对安全性进行这种仔细的论证，阐述使用了哪种技术，使用threadsafe data types, or synchronization时，需要论证所有对数据的访问都是具有原子性的</p>
</li>
<li><p>字符串是不可变的并且是线程安全的; 但是指向该字符串的rep，特别是文本变量，并不是不可变的；</p>
</li>
<li><p>文本不是最终变量，因为我们需要数据类型来支持插入和删除操作；</p>
</li>
<li><p>因此读取和写入文本变量本身不是线程安全的。</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%9C%AC%E7%A7%91%E6%96%87%E6%A1%A3/" rel="tag"># 本科文档</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/07/01/%E8%BD%AF%E4%BB%B6%E6%9E%84%E9%80%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%20-%205/" rel="prev" title="软件构造知识点总结 - 5">
                  <i class="fa fa-angle-left"></i> 软件构造知识点总结 - 5
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/09/16/Windows-10-%E5%AE%89%E8%A3%85PyTorch/" rel="next" title="Windows 10 安装PyTorch">
                  Windows 10 安装PyTorch <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gaotf</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
