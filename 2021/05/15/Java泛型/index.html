<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1.为什么要使用泛型设计泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。例如，你不想为收集String和File对象分别编写不同的类。实际上，也不需要这样做，因为一个ArrayList类就可以收集任何类的对象。这就是泛型程序设计的一个例子。 List arrayList &#x3D; new ArrayList(); arrayList.add(&quot;aaaa&quot;); arrayLi">
<meta property="og:type" content="article">
<meta property="og:title" content="Java泛型">
<meta property="og:url" content="http://example.com/2021/05/15/Java%E6%B3%9B%E5%9E%8B/index.html">
<meta property="og:site_name" content="漱石斋笔谈">
<meta property="og:description" content="1.为什么要使用泛型设计泛型程序设计意味着编写的代码可以对多种不同类型的对象重用。例如，你不想为收集String和File对象分别编写不同的类。实际上，也不需要这样做，因为一个ArrayList类就可以收集任何类的对象。这就是泛型程序设计的一个例子。 List arrayList &#x3D; new ArrayList(); arrayList.add(&quot;aaaa&quot;); arrayLi">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-05-15T05:20:14.000Z">
<meta property="article:modified_time" content="2021-05-15T16:08:17.000Z">
<meta property="article:author" content="gaotf">
<meta property="article:tag" content="Java 泛型详解">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2021/05/15/Java%E6%B3%9B%E5%9E%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2021/05/15/Java%E6%B3%9B%E5%9E%8B/","path":"2021/05/15/Java泛型/","title":"Java泛型"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java泛型 | 漱石斋笔谈</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">漱石斋笔谈</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">gaotf 的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">1.为什么要使用泛型设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">2.</span> <span class="nav-text">2.泛型的特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">3.泛型类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.</span> <span class="nav-text">4.泛型接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">5.泛型方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 泛型方法的基本用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 泛型类中的泛型方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%B8%8E%E6%B3%9B%E5%9E%8B"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 静态方法与泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 泛型方法总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E6%B3%9B%E5%9E%8B%E4%B8%8A%E4%B8%8B%E8%BE%B9%E7%95%8C"><span class="nav-number">6.</span> <span class="nav-text">6.泛型上下边界</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gaotf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">gaotf</p>
  <div class="site-description" itemprop="description">热爱技术，笔耕不辍</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/1170300619" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1170300619" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3469205806@qq.com" title="E-Mail → 3469205806@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/05/15/Java%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java泛型 | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java泛型
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-05-15 13:20:14" itemprop="dateCreated datePublished" datetime="2021-05-15T13:20:14+08:00">2021-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2021-05-16 00:08:17" itemprop="dateModified" datetime="2021-05-16T00:08:17+08:00">2021-05-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="1-为什么要使用泛型设计"><a href="#1-为什么要使用泛型设计" class="headerlink" title="1.为什么要使用泛型设计"></a>1.为什么要使用泛型设计</h1><p><strong>泛型程序设计</strong>意味着编写的代码可以对多种不同类型的对象重用。例如，你不想为收集<strong>String</strong>和<strong>File</strong>对象分别编写不同的类。实际上，也不需要这样做，因为一个<strong>ArrayList</strong>类就可以收集任何类的对象。这就是泛型程序设计的一个例子。</p>
<pre><code>List arrayList = new ArrayList();
arrayList.add(&quot;aaaa&quot;);
arrayList.add(100);

for(int i = 0; i&lt; arrayList.size();i++)&#123;
    String item = (String)arrayList.get(i);
    Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);
&#125;
</code></pre>
<p>毫无疑问，这个程序会在运行时崩溃，为了解决这样的问题（在编译阶段就可以解决），泛型应运而生。我们将第一行声明初始化<strong>list</strong>的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<pre><code>List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();
...
//arrayList.add(100); 在编译阶段，编译器就会报错
</code></pre>
<h1 id="2-泛型的特性"><a href="#2-泛型的特性" class="headerlink" title="2.泛型的特性"></a>2.泛型的特性</h1><p>泛型只在编译阶段有效，下面是一个经典的泛型的例子。</p>
<pre><code>List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();
List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();

Class classStringArrayList = stringArrayList.getClass();
Class classIntegerArrayList = integerArrayList.getClass();

if(classStringArrayList.equals(classIntegerArrayList))&#123;
    Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);
&#125;
</code></pre>
<p>输出的结果是<strong>类型相同</strong>。通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说<strong>Java</strong>中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<h1 id="3-泛型类"><a href="#3-泛型类" class="headerlink" title="3.泛型类"></a>3.泛型类</h1><p>通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：<strong>List</strong>，<strong>Set</strong>，<strong>Map</strong>。<br>泛型类的基本写法为：</p>
<pre><code>class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123;
    private 泛型标识 /*（成员变量类型）*/ var; 
    .....
    &#125;
&#125;
</code></pre>
<p>下面我们实现一个简单的泛型类：</p>
<pre><code>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt;&#123; 
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    &#125;

    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    &#125;
&#125;
</code></pre>
<p>传入参数时：如果传入泛型类型实参，会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。</p>
<pre><code>//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型
//传入的实参类型需与泛型的类型参数类型相同，即为Integer.
Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);

//传入的实参类型需与泛型的类型参数类型相同，即为String.
Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey());
</code></pre>
<p>如果不选择传入泛型类型实参：在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<pre><code>Generic generic = new Generic(&quot;111111&quot;);
Generic generic1 = new Generic(4444);
Generic generic2 = new Generic(55.55);
Generic generic3 = new Generic(false);

Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic1.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic2.getKey());
Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic3.getKey());
</code></pre>
<p><font face = "黑体" font color = "red">注意：</font></p>
<ul>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
<li>不能对确切的泛型类型使用<strong>instanceof</strong>操作。如下面的操作是非法的，编译时会出错。</li>
</ul>
<pre><code>if(ex_num instanceof Generic&lt;Number&gt;)&#123; &#125;
</code></pre>
<h1 id="4-泛型接口"><a href="#4-泛型接口" class="headerlink" title="4.泛型接口"></a>4.泛型接口</h1><p>泛型接口常被用在各种类的生产器中：</p>
<pre><code>//定义一个泛型接口
public interface Generation&lt;T&gt; &#123;
    public T next();
&#125;
</code></pre>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<pre><code>/**
* 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中
* 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;
* 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;
*/
class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;
    @Override
    public T next() &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<pre><code>/**
* 传入泛型实参时：
* 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;
* 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。
* 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型
* 此时不需要在声明类中的泛型声明T
* 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。
*/
public class FruitGenerator implements Generator&lt;String&gt; &#123;

    private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;;

    @Override
    public String next() &#123;
        Random rand = new Random();
        return fruits[rand.nextInt(3)];
    &#125;
&#125;
</code></pre>
<h1 id="5-泛型方法"><a href="#5-泛型方法" class="headerlink" title="5.泛型方法"></a>5.泛型方法</h1><p>泛型方法的基本形式：</p>
<pre><code>/**
* 泛型方法的基本介绍
* @param tClass 传入的泛型实参
* @return T 返回值为T类型
* 说明：
*     1）public与返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。
*     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。
*     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。
*     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。
*/
public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException ,
IllegalAccessException&#123;
        T instance = tClass.newInstance();
        return instance;
&#125;
</code></pre>
<h2 id="5-1-泛型方法的基本用法"><a href="#5-1-泛型方法的基本用法" class="headerlink" title="5.1 泛型方法的基本用法"></a>5.1 泛型方法的基本用法</h2><pre><code>public class GenericTest &#123;
    //这个类是个泛型类，在上面已经介绍过
    public class Generic&lt;T&gt;&#123;     
        private T key;

        public Generic(T key) &#123;
            this.key = key;
        &#125;

        //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。
        //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。
        //所以在这个方法中才可以继续使用 T 这个泛型。
        public T getKey()&#123;
            return key;
        &#125;

        /**
        * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot;
        * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。
        public E setKey(E key)&#123;
            this.key = keu
        &#125;
        */
    &#125;

    /** 
    * 这才是一个真正的泛型方法。
    * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T
    * 这个T可以出现在这个泛型方法的任意位置.
    * 泛型的数量也可以为任意多个 
    *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;
    *        ...
    *        &#125;
    */
    public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123;
        System.out.println(&quot;container key :&quot; + container.getKey());
        //当然这个例子举的不太合适，只是为了说明泛型方法的特性。
        T test = container.getKey();
        return test;
    &#125;

    //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。
    public void showKeyValue1(Generic&lt;Number&gt; obj)&#123;
        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
    &#125;

    //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?
    //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类
    public void showKeyValue2(Generic&lt;?&gt; obj)&#123;
        Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
    &#125;

    /**
    * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#39;E&#39; &quot;
    * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。
    * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。
    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;
        ...
    &#125;  
    */

    /**
    * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#39;T&#39; &quot;
    * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。
    * 所以这也不是一个正确的泛型方法声明。
    public void showkey(T genericObj)&#123;

    &#125;
    */

    public static void main(String[] args) &#123;
        ...
    &#125;
&#125;
</code></pre>
<h2 id="5-2-泛型类中的泛型方法"><a href="#5-2-泛型类中的泛型方法" class="headerlink" title="5.2 泛型类中的泛型方法"></a>5.2 泛型类中的泛型方法</h2><p>有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下：</p>
<pre><code>public class GenericFruit &#123;
    class Fruit&#123;
        @Override
        public String toString() &#123;
            return &quot;fruit&quot;;
        &#125;
    &#125;

    class Apple extends Fruit&#123;
        @Override
        public String toString() &#123;
            return &quot;apple&quot;;
        &#125;
    &#125;

    class Person&#123;
        @Override
        public String toString() &#123;
            return &quot;Person&quot;;
        &#125;
    &#125;

    class GenerateTest&lt;T&gt;&#123;
        public void show_1(T t)&#123;
            System.out.println(t.toString());
        &#125;

        //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。
        //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。
        public &lt;E&gt; void show_3(E t)&#123;
            System.out.println(t.toString());
        &#125;

        //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。
        public &lt;T&gt; void show_2(T t)&#123;
            System.out.println(t.toString());
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Apple apple = new Apple();
        Person person = new Person();

        GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;();
        //apple是Fruit的子类，所以这里可以
        generateTest.show_1(apple);
        //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person
        //generateTest.show_1(person);

        //使用这两个方法都可以成功
        generateTest.show_2(apple);
        generateTest.show_2(person);

        //使用这两个方法也都可以成功
        generateTest.show_3(apple);
        generateTest.show_3(person);
    &#125;
&#125;
</code></pre>
<h2 id="5-3-静态方法与泛型"><a href="#5-3-静态方法与泛型" class="headerlink" title="5.3 静态方法与泛型"></a>5.3 静态方法与泛型</h2><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。</p>
<pre><code>public class StaticGenerator&lt;T&gt; &#123;
    ....
    ....
    /**
    * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）
    * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。
    * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：
        &quot;StaticGenerator cannot be refrenced from static context&quot;
    */
    public static &lt;T&gt; void show(T t)&#123;

    &#125;
&#125;
</code></pre>
<h2 id="5-4-泛型方法总结"><a href="#5-4-泛型方法总结" class="headerlink" title="5.4 泛型方法总结"></a>5.4 泛型方法总结</h2><p>一个基本的指导原则：</p>
<pre><code>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，

那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。

所以如果static方法要使用泛型能力，就必须使其成为泛型方法。
</code></pre>
<h1 id="6-泛型上下边界"><a href="#6-泛型上下边界" class="headerlink" title="6.泛型上下边界"></a>6.泛型上下边界</h1><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。为泛型添加上边界，即传入的类型实参必须是指定类型的子类型。</p>
<pre><code>public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123;
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
&#125;
</code></pre>
<p>具体情况：</p>
<pre><code>Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);
Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);
Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);
Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);

//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类
//showKeyValue1(generic1);

showKeyValue1(generic2);
showKeyValue1(generic3);
showKeyValue1(generic4);
</code></pre>
<p>如果我们把泛型类的定义也修改一下：</p>
<pre><code>public class Generic&lt;T extends Number&gt;&#123;
    private T key;

    public Generic(T key) &#123;
        this.key = key;
    &#125;

    public T getKey()&#123;
        return key;
    &#125;
&#125;
</code></pre>
<p>这种情况下：</p>
<pre><code>//这一行代码也会报错，因为String不是Number的子类
Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);
</code></pre>
<p>再来看一个例子：</p>
<pre><code>//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加
//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;
public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123;
    System.out.println(&quot;container key :&quot; + container.getKey());
    T test = container.getKey();
    return test;
&#125;
</code></pre>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java-%E6%B3%9B%E5%9E%8B%E8%AF%A6%E8%A7%A3/" rel="tag"># Java 泛型详解</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/01/02/new-future/" rel="prev" title="new future">
                  <i class="fa fa-angle-left"></i> new future
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/05/%E8%A7%A3%E5%86%B3hexo%E4%B8%8D%E6%98%BE%E7%A4%BA%E6%8F%92%E5%85%A5%E5%9B%BE%E5%83%8F%E7%9A%84%E9%97%AE%E9%A2%98/" rel="next" title="解决hexo不显示插入图像的问题">
                  解决hexo不显示插入图像的问题 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gaotf</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
