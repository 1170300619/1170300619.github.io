<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic%7CLato:300,300italic,400,400italic,700,700italic%7CRoboto+Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"show_result":true},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一. C++部分1.说一说指针和引用的区别指针内部保存的是指向的对象的地址信息，而引用是变量的别名；指针可以随时初始化，而引用被定义之后就要初始化，不可以为空sizeof引用是被引用的对象的大小，而sizeof指针是指针类型的大小指针既有顶层const（指针本身不能变），也有底层const（指针指向的对象不能变），而引用只有底层const，顶层const是无意义的。二者的++操作不同，指针++表示">
<meta property="og:type" content="article">
<meta property="og:title" content="牛客C++面经">
<meta property="og:url" content="http://example.com/2022/07/05/%E7%89%9B%E5%AE%A2c-%E9%9D%A2%E7%BB%8F/index.html">
<meta property="og:site_name" content="漱石斋笔谈">
<meta property="og:description" content="一. C++部分1.说一说指针和引用的区别指针内部保存的是指向的对象的地址信息，而引用是变量的别名；指针可以随时初始化，而引用被定义之后就要初始化，不可以为空sizeof引用是被引用的对象的大小，而sizeof指针是指针类型的大小指针既有顶层const（指针本身不能变），也有底层const（指针指向的对象不能变），而引用只有底层const，顶层const是无意义的。二者的++操作不同，指针++表示">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-05T12:15:56.000Z">
<meta property="article:modified_time" content="2024-04-26T02:46:43.102Z">
<meta property="article:author" content="gaotf">
<meta property="article:tag" content="面试笔记">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/07/05/%E7%89%9B%E5%AE%A2c-%E9%9D%A2%E7%BB%8F/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/07/05/%E7%89%9B%E5%AE%A2c-%E9%9D%A2%E7%BB%8F/","path":"2022/07/05/牛客c-面经/","title":"牛客C++面经"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>牛客C++面经 | 漱石斋笔谈</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">漱石斋笔谈</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">gaotf 的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-C-%E9%83%A8%E5%88%86"><span class="nav-number">1.</span> <span class="nav-text">一. C++部分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.1.</span> <span class="nav-text">1.说一说指针和引用的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.2.</span> <span class="nav-text">2.struct和class的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-C-%E4%B8%AD%E5%A4%9A%E6%80%81"><span class="nav-number">1.0.3.</span> <span class="nav-text">3.C++中多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.0.4.</span> <span class="nav-text">4.面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">1.0.5.</span> <span class="nav-text">5.浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-STL%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%9F%A5%E6%89%BE%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.0.6.</span> <span class="nav-text">6.STL容器的实现和查找时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-STL-%E4%B8%AD%E5%AE%B9%E5%99%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%8C%E6%AF%8F%E7%A7%8D%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%B9%E5%99%A8"><span class="nav-number">1.0.7.</span> <span class="nav-text">7.STL 中容器的类型，每种分别有哪些容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E7%9A%84%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99"><span class="nav-number">1.0.8.</span> <span class="nav-text">8.简述一下 C++ 的重载和重写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.0.9.</span> <span class="nav-text">9.简述一下虚函数的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%AE%BE%E7%BD%AE%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.10.</span> <span class="nav-text">10.为什么将析构函数设置成虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%92%8C%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0%EF%BC%8C%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">1.0.11.</span> <span class="nav-text">11.哈希冲突的原因和影响因素，哈希冲突的解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-map%EF%BC%8Cunordered-map-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.0.12.</span> <span class="nav-text">12.map，unordered_map 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">1.0.13.</span> <span class="nav-text">13.红黑树的特性，为什么要有红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-vector-%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%8C%E6%89%A9%E5%AE%B9%E4%BB%A5%E5%90%8E%EF%BC%8C%E5%AE%83%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E4%BC%9A%E5%8F%98%E5%8C%96%E5%90%97%EF%BC%9F"><span class="nav-number">1.0.14.</span> <span class="nav-text">14.vector 的扩容机制，扩容以后，它的内存地址会变化吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-map-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E5%90%84%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%98%AF%E5%A4%9A%E5%B0%91"><span class="nav-number">1.0.15.</span> <span class="nav-text">15.请你说说 map 实现原理，各操作的时间复杂度是多少</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-shared-ptr-%E6%80%8E%E4%B9%88%E7%9F%A5%E9%81%93%E8%B7%9F%E5%AE%83%E5%85%B1%E4%BA%AB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8C%87%E9%92%88%E9%87%8A%E6%94%BE%E4%BA%86"><span class="nav-number">1.0.16.</span> <span class="nav-text">16.shared_ptr 怎么知道跟它共享对象的指针释放了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC%E3%80%81%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">1.0.17.</span> <span class="nav-text">17.请你说说左值、右值、左值引用、右值引用、右值引用的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-weak-ptr-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-shared-ptr-%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">1.0.18.</span> <span class="nav-text">17.weak_ptr 如何解决 shared_ptr 的循环引用问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E8%99%9A%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%90%97"><span class="nav-number">1.0.19.</span> <span class="nav-text">18.请你说说虚函数可以是内联函数吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%E5%8E%9F%E5%9B%A0%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5"><span class="nav-number">1.0.20.</span> <span class="nav-text">19.请你说说迭代器失效原因，有哪些情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-%E8%AF%B7%E4%BD%A0%E8%AF%B4%E8%AF%B4-auto-%E5%92%8C-decltype-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="nav-number">1.0.21.</span> <span class="nav-text">20.请你说说 auto 和 decltype 如何使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-%E8%AF%B4%E8%AF%B4-C-%E4%B8%AD%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.0.22.</span> <span class="nav-text">21.说说 C++ 中智能指针和指针的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B-C-%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.0.23.</span> <span class="nav-text">22.简述一下 C++ 中的四种类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#new-%E5%92%8C-delete-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="nav-number">2.</span> <span class="nav-text">new 和 delete 是如何实现的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%8D%A0%E5%A4%9A%E5%B0%91%E5%AD%97%E8%8A%82"><span class="nav-number">3.</span> <span class="nav-text">指针占多少字节</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="nav-number">4.</span> <span class="nav-text">顶层const和底层const</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">数据库三大范式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E6%88%90%E5%91%98%E7%BB%A7%E6%89%BF%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98"><span class="nav-number">6.</span> <span class="nav-text">类成员继承权限问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">7.</span> <span class="nav-text">禁止隐式转换</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">数组和指针的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E6%AF%94%E8%BE%83%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%A8%A1%E6%9D%BF"><span class="nav-number">9.</span> <span class="nav-text">写一个比较大小的模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">回调函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#delete%E5%92%8Cdelete-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">11.</span> <span class="nav-text">delete和delete[]的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4"><span class="nav-number">12.</span> <span class="nav-text">类的对象存储空间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9C%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F%E5%AF%B9%E8%B1%A1%E8%BF%98%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E7%94%A8delete-this%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">如果在类的析构函数中调用delete this，会发生什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#auto%E5%92%8Cdecltype%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">15.</span> <span class="nav-text">auto和decltype的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lambda%E5%87%BD%E6%95%B0"><span class="nav-number">16.</span> <span class="nav-text">lambda函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL%E4%B8%ADhashtable%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">17.</span> <span class="nav-text">STL中hashtable的实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#vector%E5%A6%82%E4%BD%95%E9%87%8A%E6%94%BE%E7%A9%BA%E9%97%B4"><span class="nav-number">18.</span> <span class="nav-text">vector如何释放空间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="nav-number">19.</span> <span class="nav-text">容器内删除一个元素</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#STL%E6%AF%8F%E7%A7%8D%E5%AE%B9%E5%99%A8%E5%AF%B9%E5%BA%94%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">20.</span> <span class="nav-text">STL每种容器对应的迭代器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sizeof%E5%92%8Cstrlen%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">21.</span> <span class="nav-text">sizeof和strlen的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F%E6%8A%8A%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E9%83%BD%E8%AF%B4%E4%B8%80%E8%AF%B4"><span class="nav-number">22.</span> <span class="nav-text">哪些函数不能是虚函数？把你知道的都说一说</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">23.</span> <span class="nav-text">什么时候必须要自定义析构函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B"><span class="nav-number">24.</span> <span class="nav-text">析构函数的析构过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BC%9A%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">25.</span> <span class="nav-text">何时会调用析构函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E9%87%8D%E5%86%99%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">26.</span> <span class="nav-text">什么时候需要自己重写拷贝构造函数</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="gaotf"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">gaotf</p>
  <div class="site-description" itemprop="description">热爱技术，笔耕不辍</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">33</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/1170300619" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1170300619" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/3469205806@qq.com" title="E-Mail → 3469205806@qq.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/07/05/%E7%89%9B%E5%AE%A2c-%E9%9D%A2%E7%BB%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="gaotf">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="漱石斋笔谈">
      <meta itemprop="description" content="热爱技术，笔耕不辍">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="牛客C++面经 | 漱石斋笔谈">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          牛客C++面经
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-07-05 20:15:56" itemprop="dateCreated datePublished" datetime="2022-07-05T20:15:56+08:00">2022-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-04-26 10:46:43" itemprop="dateModified" datetime="2024-04-26T10:46:43+08:00">2024-04-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">总结笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="一-C-部分"><a href="#一-C-部分" class="headerlink" title="一. C++部分"></a>一. C++部分</h1><h3 id="1-说一说指针和引用的区别"><a href="#1-说一说指针和引用的区别" class="headerlink" title="1.说一说指针和引用的区别"></a>1.说一说指针和引用的区别</h3><p>指针内部保存的是指向的对象的地址信息，而引用是变量的别名；<br>指针可以随时初始化，而引用被定义之后就要初始化，不可以为空<br>sizeof引用是被引用的对象的大小，而sizeof指针是指针类型的大小<br>指针既有顶层const（指针本身不能变），也有底层const（指针指向的对象不能变），而引用只有底层const，顶层const是无意义的。<br>二者的<code>++</code>操作不同，指针<code>++</code>表示指针运算，而引用<code>++</code>表示变量执行<code>++</code>。<br>引用只是C++的语法糖，可以看作是自动取地址解引用的常量指针。在汇编层面是一样的。</p>
<h3 id="2-struct和class的区别"><a href="#2-struct和class的区别" class="headerlink" title="2.struct和class的区别"></a>2.struct和class的区别</h3><p>默认的（继承）访问权限，class是private，struct默认是public<br>class可以实现模板类，而struct不可以<br>struct是值类型，而class是引用类型</p>
<h3 id="3-C-中多态"><a href="#3-C-中多态" class="headerlink" title="3.C++中多态"></a>3.C++中多态</h3><p>为了使代码重用性增加，使得代码可以模块化<br>静态多态：通过重载函数和泛型编程实现，通过基类指针指向的对象不同而调用不同的函数。是在编译器就完成的，编译器根据实参类型来确定。具有更好的类型安全性，因为编译阶段会对所有的绑定类型进行检查。<br>动态多态：通过虚函数和继承实现，运行时确定。虚函数表保存在只读数据段，编译器将类对象的前四个字节设置为指向虚函数表的指针。</p>
<h3 id="4-面向对象"><a href="#4-面向对象" class="headerlink" title="4.面向对象"></a>4.面向对象</h3><p>面向对象的三大特征：封装、继承、多态。封装：将客观事物进行抽象，将其属性和方法合成为一个类，类封装了成员变量和成员函数，同时又实现对属性和方法的权限控制，降低与外界的耦合度 继承：子类继承父类的各种属性和方法，同时子类还可以在父类的基础上重新定义和扩展父类的属性和方法，使其具有不同的功能，继承提高了代码的复用性及可维护性 多态：同一调用语句在父类和子类间使用时具有不同的表现形式，可以使用同一段代码处理不行类型的对象，提高代码的复用性</p>
<h3 id="5-浅拷贝和深拷贝"><a href="#5-浅拷贝和深拷贝" class="headerlink" title="5.浅拷贝和深拷贝"></a>5.浅拷贝和深拷贝</h3><p>浅拷贝 (Shallow Copy) 只复制某个对象的指针, 而不复制对象本身, 新旧对象还是共享同一块内存。在对象析构后，容易产生指针访问一个不存在的对象，从而产生悬空指针。<br>深拷贝 (Deep Copy) 在拷贝的过程中会另外创造一个一模一样的对象. 新对象跟原对象不共享内存, 修改新对象不会改到原对象. </p>
<h3 id="6-STL容器的实现和查找时间复杂度"><a href="#6-STL容器的实现和查找时间复杂度" class="headerlink" title="6.STL容器的实现和查找时间复杂度"></a>6.STL容器的实现和查找时间复杂度</h3><ol>
<li>vector 采用一维数组实现，元素在内存连续存放，不同操作的时间复杂度为： 插入: O(N) 查看: O(1) 删除: O(N) 2. deque 采用双向队列实现，元素在内存连续存放，不同操作的时间复杂度为： 插入: O(N) 查看: O(1) 删除: O(N) 3. list 采用双向链表实现，元素存放在堆中，不同操作的时间复杂度为： 插入: O(1) 查看: O(N) 删除: O(1) 4. map、set、multimap、multiset 上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种。不同操作的时间复杂度近似为: 插入: O(logN) 查看: O(logN) 删除: O(logN) 5. unordered_map、unordered_set、unordered_multimap、 unordered_multiset 上述四种容器采用哈希表实现，不同操作的时间复杂度为： 插入: O(1)，最坏情况O(N) 查看: O(1)，最坏情况O(N) 删除: O(1)，最坏情况O(N) 注意：容器的时间复杂度取决于其底层实现方式。</li>
</ol>
<h3 id="7-STL-中容器的类型，每种分别有哪些容器"><a href="#7-STL-中容器的类型，每种分别有哪些容器" class="headerlink" title="7.STL 中容器的类型，每种分别有哪些容器"></a>7.STL 中容器的类型，每种分别有哪些容器</h3><ol>
<li>序列式容器 array、vector、deque、list、forward_list 2. 关联式容器 map、multimap、set、multiset 3. 无序关联式容器 unordered_map、unordered_multimap、unordered_set、unordered_multiset 4. 容器适配器 stack、queue、priority_queue</li>
</ol>
<h3 id="8-简述一下-C-的重载和重写"><a href="#8-简述一下-C-的重载和重写" class="headerlink" title="8.简述一下 C++ 的重载和重写"></a>8.简述一下 C++ 的重载和重写</h3><ol>
<li>重载<br>a. 重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同（参数列表不同）。调用的时候根据函数的参数来区别不同的函数，函数重载跟返回值无关。<br>b. 重载的规则 - 函数名相同 - 必须具有不同的参数列表 - 可以有不同的访问修饰符<br>c. 重载用来实现静态多态（函数名相同，功能不一样）。<br>d. 重载是多个函数或者同一个类中方法之间的关系，是平行关系。</li>
<li>重写<br>a. 重写（也叫覆盖）是指在派生类中重新对基类中的虚函数重新实现。即函数名和参数都一样，只是函数的实现体不一样。<br>b. 重写的规则： - 方法声明必须完全与父类中被重写的方法相同 - 访问修饰符的权限要大于或者等于父类中被重写的方法的访问修饰符 - 子类重写的方法可以加virtual，也可以不加<br>c. 重写用来实现动态多态（根据调用方法的对象的类型来执行不同的函数）。<br>d. 重写是父类和子类之间的关系，是垂直关系。</li>
</ol>
<p>隐藏的实质是：在函数查找时，名字查找先于类型检查。如果派生类中成员和基类中的成员同名，就隐藏掉。编译器首先在相应作用域中查找函数，如果找到名字一样的则停止查找。</p>
<h3 id="9-简述一下虚函数的实现原理"><a href="#9-简述一下虚函数的实现原理" class="headerlink" title="9.简述一下虚函数的实现原理"></a>9.简述一下虚函数的实现原理</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75172640">https://zhuanlan.zhihu.com/p/75172640</a></p>
<ol>
<li>C++ 中的虚函数的作用主要是实现了动态多态的机制。 2. 虚函数实现原理 编译器处理虚函数时，给每个对象添加一个隐藏的成员。隐藏的成员是一个指针类型的数据，指向的是函数地址数组，这个数组被称为虚函数表（virtual function table，vtbl）。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚函数表中保存的是派生类的虚函数地址，如果派生类没有重写基类中的虚函数，则派生类对象的虚函数表中保存的是父类的虚函数地址。使用虚函数时，对于内存和执行速度方面会有一定的成本： 1. 每个对象都会变大，变大的量为存储虚函数表指针； 2. 对于每个类，编译器都会创建一个虚函数表； 3. 对于每次调用虚函数，都需要额外执行一个操作，就是到表中查找虚函数地址。</li>
</ol>
<h3 id="10-为什么将析构函数设置成虚函数"><a href="#10-为什么将析构函数设置成虚函数" class="headerlink" title="10.为什么将析构函数设置成虚函数"></a>10.为什么将析构函数设置成虚函数</h3><p>虚析构函数的主要作用是为了防止遗漏资源的释放，防止内存泄露。如果基类中的析构函数没有声明为虚函数，基类指针指向派生类对象时，则当基类指针释放时不会调用派生类对象的析构函数，而是调用基类的析构函数，如果派生类析构函数中做了某些释放资源的操作，则这时就会造成内存泄露。</p>
<h3 id="11-哈希冲突的原因和影响因素，哈希冲突的解决方法"><a href="#11-哈希冲突的原因和影响因素，哈希冲突的解决方法" class="headerlink" title="11.哈希冲突的原因和影响因素，哈希冲突的解决方法"></a>11.哈希冲突的原因和影响因素，哈希冲突的解决方法</h3><ol>
<li>哈希冲突产生的原因 哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过哈希函数产生的哈希值是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的值，这时候就产生了哈希冲突。</li>
<li>产生哈希冲突的影响因素 装填因子（装填因子&#x3D;数据总数 &#x2F; 哈希表长）、哈希函数、处理冲突的方法 </li>
<li>哈希冲突的解决方法<br>a.开放地址方法：如果冲突，则根据冲突的值再建立一个值，如果还冲突就重复操作直到不再冲突<br>b.链式地址法：将所有冲突的都放入一个链表中<br>c.建立公共溢出区：基本表和溢出表<br>d.再哈希法：同时构建多个哈希函数，一个发生冲突就使用另一个</li>
</ol>
<h3 id="12-map，unordered-map-的区别"><a href="#12-map，unordered-map-的区别" class="headerlink" title="12.map，unordered_map 的区别"></a>12.map，unordered_map 的区别</h3><p>map：内部实现了一个红黑树，该结构具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素，因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了 map 的效率。<br>unordered_map：内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。</p>
<h3 id="13-红黑树的特性，为什么要有红黑树"><a href="#13-红黑树的特性，为什么要有红黑树" class="headerlink" title="13.红黑树的特性，为什么要有红黑树"></a>13.红黑树的特性，为什么要有红黑树</h3><p>在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树，红黑树具有如下特点：<br> 1、具有二叉查找树的特点；<br> 2、根节点是黑色的；<br> 3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据；<br> 4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；<br> 5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。</p>
<h3 id="14-vector-的扩容机制，扩容以后，它的内存地址会变化吗？"><a href="#14-vector-的扩容机制，扩容以后，它的内存地址会变化吗？" class="headerlink" title="14.vector 的扩容机制，扩容以后，它的内存地址会变化吗？"></a>14.vector 的扩容机制，扩容以后，它的内存地址会变化吗？</h3><p> 当 vector 的大小和容量相等（size&#x3D;&#x3D;capacity）也就是满载时，如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步： 1. 完全弃用现有的内存空间，重新申请更大的内存空间； 2. 将旧内存空间中的数据，按原有顺序移动到新的内存空间中； 3. 最后将旧的内存空间释放。 因为 vector 扩容需要申请新的空间，所以扩容以后它的内存地址会发生改变。vector 扩容是非常耗时的，为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity&gt;&#x3D;size），以便后期使用。<br> vector底层使用三个指针来实现，分别是：顺序表头，顺序表的有效长度位置，顺序表末尾。<br> <a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51723227/article/details/121374795#:~:text=%E5%9C%A8%E6%A0%87%E5%87%86C%2B%2B%E4%B8%AD%2C,%2C%E8%BE%BE%E5%88%B0%E5%AD%98%E5%82%A8%E6%95%88%E6%9E%9C">https://blog.csdn.net/m0_51723227/article/details/121374795#:~:text=%E5%9C%A8%E6%A0%87%E5%87%86C%2B%2B%E4%B8%AD%2C,%2C%E8%BE%BE%E5%88%B0%E5%AD%98%E5%82%A8%E6%95%88%E6%9E%9C</a>.</p>
<h3 id="15-请你说说-map-实现原理，各操作的时间复杂度是多少"><a href="#15-请你说说-map-实现原理，各操作的时间复杂度是多少" class="headerlink" title="15.请你说说 map 实现原理，各操作的时间复杂度是多少"></a>15.请你说说 map 实现原理，各操作的时间复杂度是多少</h3><ol>
<li>map 实现原理 map 内部实现了一个红黑树（红黑树是非严格平衡的二叉搜索树，而 AVL是严格平衡二叉搜索树），红黑树有自动排序的功能，因此 map 内部所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map 中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值，使用中序遍历可将键值按照从小到大遍历出来。 2. 各操作的时间复杂度 插入: O(logN) 查看: O(logN) 删除: O(logN)</li>
</ol>
<h3 id="16-shared-ptr-怎么知道跟它共享对象的指针释放了"><a href="#16-shared-ptr-怎么知道跟它共享对象的指针释放了" class="headerlink" title="16.shared_ptr 怎么知道跟它共享对象的指针释放了"></a>16.shared_ptr 怎么知道跟它共享对象的指针释放了</h3><p>shared_ptr基于”引用计数”模型实现，多个shared_ptr可指向同一个动态对象，并维护一个共享的引用计数器，记录了引用同一对象的shared_ptr实例的数量。当最后一个指向动态对象的shared_ptr销毁时，会自动销毁其所指对象(通过delete操作符)。</p>
<h3 id="17-请你说说左值、右值、左值引用、右值引用、右值引用的使用场景"><a href="#17-请你说说左值、右值、左值引用、右值引用、右值引用的使用场景" class="headerlink" title="17.请你说说左值、右值、左值引用、右值引用、右值引用的使用场景"></a>17.请你说说左值、右值、左值引用、右值引用、右值引用的使用场景</h3><ol>
<li>左值 在 C++ 中可以取地址的、有名字的就是左值 int a &#x3D; 10; &#x2F;&#x2F; 其中 a 就是左值 </li>
<li>右值 不能取地址的、没有名字的就是右值 int a &#x3D; 10; &#x2F;&#x2F; 其中 10 就是右值右值 </li>
<li>左值引用 左值引用就是对一个左值进行引用。传统的 C++ 引用（现在称为左值引用）使得标识符关联到左值。左值是一个表示数据的表达式（如变量名或解除引用的指针），程序可获取其地址。最初，左值可出现在赋值语句的左边，但修饰符 const 的出现使得可以声明这样的标识符，即不能给它赋值，但可获取其地址： int n; int * pt &#x3D; new int; const int b &#x3D; 101; int &amp; rn &#x3D; n; int &amp; rt &#x3D; *pt; const int &amp; rb &#x3D; b; const int &amp; rb &#x3D; 10; </li>
<li>右值引用 右值引用就是对一个右值进行引用。C++ 11 新增了右值引用（rvalue reference），这种引用可指向右值（即可出现在赋值表达式右边的值），但不能对其应用地址运算符。右值包括字面常量（C-风格字符串除外，它表示地址）、诸如 x + y 等表达式以及返回值的函数（条件是该函数返回的不是引用），右值引用使用 &amp;&amp; 声明： int x &#x3D; 10; int y &#x3D; 23; int &amp;&amp; r1 &#x3D; 13; int &amp;&amp; r2 &#x3D; x + y; double &amp;&amp; r3 &#x3D; std::sqrt(2.0); </li>
<li>右值引用的使用场景 右值引用可以实现移动语义、完美转发。</li>
</ol>
<h3 id="17-weak-ptr-如何解决-shared-ptr-的循环引用问题？"><a href="#17-weak-ptr-如何解决-shared-ptr-的循环引用问题？" class="headerlink" title="17.weak_ptr 如何解决 shared_ptr 的循环引用问题？"></a>17.weak_ptr 如何解决 shared_ptr 的循环引用问题？</h3><p>weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数，依此特性可以解决 shared_ptr 的循环引用问题。 weak_ptr 没有解引用 * 和获取指针 -&gt; 运算符，它只能通过 lock 成员函数去获取对应的 shared_ptr 智能指针对象，从而获取对应的地址和内容。 不论是否有 weak_ptr 指向，一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。</p>
<h3 id="18-请你说说虚函数可以是内联函数吗"><a href="#18-请你说说虚函数可以是内联函数吗" class="headerlink" title="18.请你说说虚函数可以是内联函数吗"></a>18.请你说说虚函数可以是内联函数吗</h3><p>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时不可以内联。virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</p>
<h3 id="19-请你说说迭代器失效原因，有哪些情况"><a href="#19-请你说说迭代器失效原因，有哪些情况" class="headerlink" title="19.请你说说迭代器失效原因，有哪些情况"></a>19.请你说说迭代器失效原因，有哪些情况</h3><p>STL 中某些容器调用了某些成员方法后会导致迭代器失效。例如 vector 容器，如果调用 reserve() 来增加容器容量，之前创建好的任何迭代器（例如开始迭代器和结束迭代器）都可能会失效，这是因为，为了增加容器的容量，vector 容器的元素可能已经被复制或移到了新的内存地址。 </p>
<ol>
<li>序列式容器迭代器失效 对于序列式容器，例如 vector、deque，由于序列式容器是组合式容器，当当前元素的迭代器被删除后，其后的所有元素的迭代器都会失效，这是因为 vector、deque都是连续存储的一段空间，所以当对其进行 erase 操作时，其后的每一个元素都会向前移一个位置。解决：erase 返回下一个有效的迭代器。 </li>
<li>关联式容器迭代器失效 对于关联容器，例如如 map、 set，删除当前的迭代器，仅仅会使当前的迭代器失效，只要在 erase 时，递增当前迭代器即可。这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个节点不会对其他点造成影响。erase 迭代器只是被删元素的迭代器失效，但是返回值为 void，所以要采用 erase(iter++) 自增方式删除迭代器。</li>
</ol>
<h3 id="20-请你说说-auto-和-decltype-如何使用"><a href="#20-请你说说-auto-和-decltype-如何使用" class="headerlink" title="20.请你说说 auto 和 decltype 如何使用"></a>20.请你说说 auto 和 decltype 如何使用</h3><p>auto 实现自动类型推断，要求进行显示初始化，让编译器能够将变量的类型设置为初始值的类型<br>decltype 将变量的类型声明为表达式指定的类型。decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型,而且decltype并不会对表达式进行求值。</p>
<h3 id="21-说说-C-中智能指针和指针的区别是什么？"><a href="#21-说说-C-中智能指针和指针的区别是什么？" class="headerlink" title="21.说说 C++ 中智能指针和指针的区别是什么？"></a>21.说说 C++ 中智能指针和指针的区别是什么？</h3><p>智能指针和普通指针的区别在于智能指针实际上是对普通指针加了一层封装机制，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便的管理一个对象的生命期。指针是一种数据类型，用于保存内存地址，而智能指针是类模板。</p>
<h3 id="22-简述一下-C-中的四种类型转换"><a href="#22-简述一下-C-中的四种类型转换" class="headerlink" title="22.简述一下 C++ 中的四种类型转换"></a>22.简述一下 C++ 中的四种类型转换</h3><p>1.static_cast 静态转换 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换 - 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的 - 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的 用于基本数据类型之间的转换，如把 int 转换成 char，把 char 转换成 int。这种转换的安全性也要开发人员来保证<br>2.dynamic_cast 动态转换 dynamic_cast 主要用于类层次间的上行转换和下行转换 在类层次间进行上行转换时，dynamic_cast 和 static_cast 的效果是一样的 在进行下行转换时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全<br>3. const_cast 常量转换 该运算符用来修改类型的const属性 常量指针被转化成非常量指针，并且仍然指向原来的对象 常量引用被转换成非常量引用，并且仍然指向原来的对象 注意:不能直接对非指针和非引用的变量使用 const_cast 操作符<br>4. reinterpret_cast 重新解释转换 这是最不安全的一种转换机制，最有可能出问题 主要用于将一种数据类型从一种类型转换为另一种类型，它可以将一个指针转换成一个整数，也可以将一个整数转换成一个指针</p>
<h1 id="new-和-delete-是如何实现的"><a href="#new-和-delete-是如何实现的" class="headerlink" title="new 和 delete 是如何实现的"></a>new 和 delete 是如何实现的</h1><p>1.new的实现过程是：首先调用名为operator new 的标准库函数，分配足够大的内存来保存指定类型的一个对象，接下来运行该类型的构造函数，用于初始化该对象，最后返回该对象的指针。<br>2.delete的实现过程：对指针指向的对象运行适当的析构函数，然后调用operator delete的标准库函数释放该对象的内存</p>
<h1 id="指针占多少字节"><a href="#指针占多少字节" class="headerlink" title="指针占多少字节"></a>指针占多少字节</h1><p>一个指针占内存的大小跟编译环境有关，而与机器的位数无关。32位编译环境下为4字节，64位编译环境下为8字节</p>
<h1 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h1><p>1.顶层const可以表示任意的对象是常量，这一点对任何数据类型都使用，底层const则与指针和引用的复合类型有关<br>2.当执行对象的拷贝操作时，顶层const不受什么影响，但是底层const的限制不能被忽略。<br>3.对于重载，顶层const不构成重载，底层const构成重载</p>
<h1 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h1><p>1.列不可再分<br>2.属性完全依赖于主键（一张表中包含了多种不同的属性，那么必须要分成多张表）<br>3.属性不依赖于其他非主属性（要求已经分好了多张表的话，一张表中只能有另一张表的ID，而不能有其他任何信息）</p>
<h1 id="类成员继承权限问题"><a href="#类成员继承权限问题" class="headerlink" title="类成员继承权限问题"></a>类成员继承权限问题</h1><p>1.若继承方式是public，基类成员在派生类中的访问权限保持不变，也就是说，基类中的成员访问权限，在派生类中仍然保持原来的访问权限；<br>2.若继承方式是private，基类所有成员在派生类中的访问权限都会变为私有(private)权限；<br>3.若继承方式是protected，基类的共有成员和保护成员在派生类中的访问权限都会变为保护(protected)权限，私有成员在派生类中的访问权限仍然是私有(private)权限。</p>
<h1 id="禁止隐式转换"><a href="#禁止隐式转换" class="headerlink" title="禁止隐式转换"></a>禁止隐式转换</h1><p>C++中提供了explicit关键字，在构造函数声明的时候加上explicit关键字，能够禁止隐式转换。如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为explicit加以制止隐式类型转换，关键字explicit只对一个实参的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需将这些构造函数指定为explicit。</p>
<h1 id="数组和指针的区别"><a href="#数组和指针的区别" class="headerlink" title="数组和指针的区别"></a>数组和指针的区别</h1><p>1.数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间：sizeof（数组名）；数组大小：sizeof(数组名)&#x2F;sizeof(数组元素数据类型)；<br>2.用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。<br>3.在向函数传递参数的时候，如果实参是一个数组，那用于接受的形参为对应的指针。也就是传递过去是数组的首地址而不是整个数组，能够提高效率；</p>
<h1 id="写一个比较大小的模板"><a href="#写一个比较大小的模板" class="headerlink" title="写一个比较大小的模板"></a>写一个比较大小的模板</h1><pre><code>template&lt;typename type1, typename type2&gt;

type1 max(type1 a, type2 b)&#123;
    return a &gt; b ? a : b;
&#125;

void main()&#123;
    cout &lt;&lt; max(5.5, &#39;a&#39;) &lt;&lt; endl;
&#125;
</code></pre>
<p>其实该模板有个比较隐晦的bug，那就是a、b只有在能进行转型的时候才能进行比较，否则 a &gt; b 这一步是会报错的。这个时候往往需要对于 &gt; 号进行重载，这代码量瞬间上来了。</p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数时，我们就说这是回调函数，比如epoll中可以通过回调函数找到对应的红黑树节点。</p>
<h1 id="delete和delete-的区别"><a href="#delete和delete-的区别" class="headerlink" title="delete和delete[]的区别"></a>delete和delete[]的区别</h1><p>delete只会调用一次析构函数。<br>delete[]会调用数组中每个元素的析构函数</p>
<h1 id="类的对象存储空间"><a href="#类的对象存储空间" class="headerlink" title="类的对象存储空间"></a>类的对象存储空间</h1><p>1.非静态成员的数据类型大小之和。<br>2.编译器加入的额外成员变量（如指向虚函数表的指针）。<br>3.为了边缘对齐优化加入的padding。<br>4.空类(无非静态数据成员)的对象的size为1,这样可以保证每个实例均有独占的内存地址，当作为基类时, size为0，如果带有虚函数，则大小比1大，因为还需要包含一个虚函数表指针<br>5.成员函数不占用对象的内存。这是因为所有的函数都是存放在代码区的，不管是全局函数，还是成员函数。</p>
<h1 id="在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？"><a href="#在成员函数中调用delete-this会出现什么问题？对象还可以使用吗？" class="headerlink" title="在成员函数中调用delete this会出现什么问题？对象还可以使用吗？"></a>在成员函数中调用delete this会出现什么问题？对象还可以使用吗？</h1><p>在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码内容，类的成员函数单独放在代码段中。在调用成员函数时，隐含传递一个this指针，让成员函数知道当前是哪个对象在调用它。当调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题</p>
<h1 id="如果在类的析构函数中调用delete-this，会发生什么？"><a href="#如果在类的析构函数中调用delete-this，会发生什么？" class="headerlink" title="如果在类的析构函数中调用delete this，会发生什么？"></a>如果在类的析构函数中调用delete this，会发生什么？</h1><p>会导致堆栈溢出。原因很简单，delete的本质是“为将被释放的内存调用一个或多个析构函数，然后，释放内存”。显然，delete this会去调用本对象的析构函数，而析构函数中又调用delete this，形成无限递归，造成堆栈溢出，系统崩溃。</p>
<h1 id="auto和decltype的区别"><a href="#auto和decltype的区别" class="headerlink" title="auto和decltype的区别"></a>auto和decltype的区别</h1><h1 id="lambda函数"><a href="#lambda函数" class="headerlink" title="lambda函数"></a>lambda函数</h1><p>1.利用lambda表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象；<br>2.每当你定义一个lambda表达式后，编译器会自动生成一个匿名类（这个类当然重载了()运算符），我们称为闭包类型（closure type）。那么在运行时，这个lambda表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的lambda表达式的结果就是一个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉其封装作用域内的变量，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为lambda捕捉块。<br>3.lambda语法如下：</p>
<pre><code>[capture] （parameters） mutable -&gt;return-type &#123;statement&#125;;
</code></pre>
<p>4.lambda必须使用尾置返回来指定返回类型，可以忽略参数列表和返回值，但必须永远包含捕获列表和函数体；</p>
<h1 id="STL中hashtable的实现"><a href="#STL中hashtable的实现" class="headerlink" title="STL中hashtable的实现"></a>STL中hashtable的实现</h1><p>1.STL中的hashtable使用的是开链法解决hash冲突问题<br>2.hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作</p>
<h1 id="vector如何释放空间"><a href="#vector如何释放空间" class="headerlink" title="vector如何释放空间"></a>vector如何释放空间</h1><p>1.由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。<br>2.如果使用vector，可以用swap()来帮助你释放多余内存或者清空全部内存。</p>
<h1 id="容器内删除一个元素"><a href="#容器内删除一个元素" class="headerlink" title="容器内删除一个元素"></a>容器内删除一个元素</h1><p>1.顺序容器（序列式容器，比如vector、deque）<br>erase迭代器不仅使所指向被删除的迭代器失效，而且使被删元素之后的所有迭代器失效(list除外)，所以不能使用erase(it++)的方式，但是erase的返回值是下一个有效迭代器；</p>
<pre><code>it = c.erase(it);
</code></pre>
<p>2.关联容器(关联式容器，比如map、set、multimap、multiset等)<br>erase迭代器只是被删除元素的迭代器失效，但是返回值是void，所以要采用erase(it++)的方式删除迭代器；</p>
<pre><code>c.erase(it++)
</code></pre>
<h1 id="STL每种容器对应的迭代器"><a href="#STL每种容器对应的迭代器" class="headerlink" title="STL每种容器对应的迭代器"></a>STL每种容器对应的迭代器</h1><p>1.vector和deque：随机访问迭代器<br>2.stack、queue、priority_queue：无<br>3.list、(multi)set&#x2F;map：双向迭代器<br>unordered_(multi)set&#x2F;map、forward_list：前向迭代器</p>
<h1 id="sizeof和strlen的区别"><a href="#sizeof和strlen的区别" class="headerlink" title="sizeof和strlen的区别"></a>sizeof和strlen的区别</h1><p>1、sizeof会将空字符\0计算在内，而strlen不会将空字符\0计算在内；<br>2、sizeof会计算到字符串最后一个空字符\0并结束，而strlen如果遇到第一个空字符\0的话就会停止并计算遇到的第一个空字符\0前面的长度。</p>
<pre><code>int main(void)
&#123;
    char str[100] = &quot;abcde&quot;;
    printf(&quot;sizeof(str) = %lu\n&quot;, sizeof(str));     //字节大小为100

    char str1[] = &quot;abcde&quot;;
    printf(&quot;sizeof(str1) = %lu\n&quot;, sizeof(str1));   //字节大小为6

    char str2[] = &quot;\0abcde&quot;;
    printf(&quot;sizeof(str2) = %lu\n&quot;, sizeof(str2));   //字节大小为7

    char str3[] = &quot;\0ab\0c de&quot;;
    printf(&quot;sizeof(str3) = %lu\n&quot;, sizeof(str3));   //字节大小为9

    char str4[] = &quot;abcde&quot;;
    printf(&quot;strlen(str4) = %lu\n&quot;, strlen(str4));   //字符串长度为5

    char str5[100] = &quot;abcde&quot;;
    printf(&quot;strlen(str5) = %lu\n&quot;, strlen(str5));   //字符串长度为5

    char str6[] = &quot;\0abcde&quot;;
    printf(&quot;strlen(str6) = %lu\n&quot;, strlen(str6));   //字符串长度为0

    char str7[] = &quot;ab cde&quot;;
    printf(&quot;strlen(str7) = %lu\n&quot;, strlen(str7));   //字符串长度为6

    return 0;
&#125;
</code></pre>
<h1 id="哪些函数不能是虚函数？把你知道的都说一说"><a href="#哪些函数不能是虚函数？把你知道的都说一说" class="headerlink" title="哪些函数不能是虚函数？把你知道的都说一说"></a>哪些函数不能是虚函数？把你知道的都说一说</h1><p>1.构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造<br>2.内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；<br>3.静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。<br>4.友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。<br>5.普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p>
<h1 id="什么时候必须要自定义析构函数"><a href="#什么时候必须要自定义析构函数" class="headerlink" title="什么时候必须要自定义析构函数"></a>什么时候必须要自定义析构函数</h1><p>如果本类中一个成员变量是别的对象的指针，而且这个指针不是传进来的地址而是这个指针指向的对象，是在本类中(如果是栈里的定位分配，也不用考虑内存)在堆中开辟的空间创建的。并且该指针没有进行过delete操作，那么久需要在析构方法中进行delete操作，此时我们就必须自己写析构函数。</p>
<h1 id="析构函数的析构过程"><a href="#析构函数的析构过程" class="headerlink" title="析构函数的析构过程"></a>析构函数的析构过程</h1><p>析构函数首先执行函数体，然后销毁成员，成员按照初始化顺序的逆序销毁。注意析构函数本身不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的，销毁类类型成员执行它自己的析构函数，销毁内置类型不需要做什么。</p>
<h1 id="何时会调用析构函数"><a href="#何时会调用析构函数" class="headerlink" title="何时会调用析构函数"></a>何时会调用析构函数</h1><ul>
<li>变量在离开其作用域时</li>
<li>当一个对象被销毁时，其成员被销毁</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁</li>
<li>对于动态分配的对象，当指向它的指针应用delete运算符时被销毁</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁</li>
</ul>
<h1 id="什么时候需要自己重写拷贝构造函数"><a href="#什么时候需要自己重写拷贝构造函数" class="headerlink" title="什么时候需要自己重写拷贝构造函数"></a>什么时候需要自己重写拷贝构造函数</h1><p>根据三&#x2F;五法则，如果需要定义一个非空的析构函数，那么通常情况下也需要自定义一个拷贝构造函数。即包含动态分配成员或者包含指针成员的类都应该提供拷贝构造函数，并且考虑重载赋值运算符。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AE%B0/" rel="tag"># 面试笔记</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/04/%E4%B8%AD%E6%9C%9B%E9%9D%A2%E7%BB%8F/" rel="prev" title="中望面经">
                  <i class="fa fa-angle-left"></i> 中望面经
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/" rel="next" title="计算机网络面经">
                  计算机网络面经 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gaotf</span>
  </div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>
-->
    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
